
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model PersonName
 * 
 */
export type PersonName = $Result.DefaultSelection<Prisma.$PersonNamePayload>
/**
 * Model EmailAddress
 * 
 */
export type EmailAddress = $Result.DefaultSelection<Prisma.$EmailAddressPayload>
/**
 * Model Phone
 * 
 */
export type Phone = $Result.DefaultSelection<Prisma.$PhonePayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model AcademicPeriod
 * 
 */
export type AcademicPeriod = $Result.DefaultSelection<Prisma.$AcademicPeriodPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model SectionRegistration
 * 
 */
export type SectionRegistration = $Result.DefaultSelection<Prisma.$SectionRegistrationPayload>
/**
 * Model StudentTranscriptGrade
 * 
 */
export type StudentTranscriptGrade = $Result.DefaultSelection<Prisma.$StudentTranscriptGradePayload>
/**
 * Model AcademicProgram
 * 
 */
export type AcademicProgram = $Result.DefaultSelection<Prisma.$AcademicProgramPayload>
/**
 * Model StudentAcademicProgram
 * 
 */
export type StudentAcademicProgram = $Result.DefaultSelection<Prisma.$StudentAcademicProgramPayload>
/**
 * Model AcademicCredential
 * 
 */
export type AcademicCredential = $Result.DefaultSelection<Prisma.$AcademicCredentialPayload>
/**
 * Model StudentRisk
 * 
 */
export type StudentRisk = $Result.DefaultSelection<Prisma.$StudentRiskPayload>
/**
 * Model SimulationState
 * 
 */
export type SimulationState = $Result.DefaultSelection<Prisma.$SimulationStatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RiskBucket: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type RiskBucket = (typeof RiskBucket)[keyof typeof RiskBucket]

}

export type RiskBucket = $Enums.RiskBucket

export const RiskBucket: typeof $Enums.RiskBucket

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more People
 * const people = await prisma.person.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more People
   * const people = await prisma.person.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personName`: Exposes CRUD operations for the **PersonName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonNames
    * const personNames = await prisma.personName.findMany()
    * ```
    */
  get personName(): Prisma.PersonNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAddress`: Exposes CRUD operations for the **EmailAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAddresses
    * const emailAddresses = await prisma.emailAddress.findMany()
    * ```
    */
  get emailAddress(): Prisma.EmailAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phone`: Exposes CRUD operations for the **Phone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phones
    * const phones = await prisma.phone.findMany()
    * ```
    */
  get phone(): Prisma.PhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicPeriod`: Exposes CRUD operations for the **AcademicPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPeriods
    * const academicPeriods = await prisma.academicPeriod.findMany()
    * ```
    */
  get academicPeriod(): Prisma.AcademicPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sectionRegistration`: Exposes CRUD operations for the **SectionRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectionRegistrations
    * const sectionRegistrations = await prisma.sectionRegistration.findMany()
    * ```
    */
  get sectionRegistration(): Prisma.SectionRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentTranscriptGrade`: Exposes CRUD operations for the **StudentTranscriptGrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTranscriptGrades
    * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany()
    * ```
    */
  get studentTranscriptGrade(): Prisma.StudentTranscriptGradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicProgram`: Exposes CRUD operations for the **AcademicProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPrograms
    * const academicPrograms = await prisma.academicProgram.findMany()
    * ```
    */
  get academicProgram(): Prisma.AcademicProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAcademicProgram`: Exposes CRUD operations for the **StudentAcademicProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAcademicPrograms
    * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany()
    * ```
    */
  get studentAcademicProgram(): Prisma.StudentAcademicProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicCredential`: Exposes CRUD operations for the **AcademicCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicCredentials
    * const academicCredentials = await prisma.academicCredential.findMany()
    * ```
    */
  get academicCredential(): Prisma.AcademicCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentRisk`: Exposes CRUD operations for the **StudentRisk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentRisks
    * const studentRisks = await prisma.studentRisk.findMany()
    * ```
    */
  get studentRisk(): Prisma.StudentRiskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulationState`: Exposes CRUD operations for the **SimulationState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationStates
    * const simulationStates = await prisma.simulationState.findMany()
    * ```
    */
  get simulationState(): Prisma.SimulationStateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Person: 'Person',
    PersonName: 'PersonName',
    EmailAddress: 'EmailAddress',
    Phone: 'Phone',
    Address: 'Address',
    Student: 'Student',
    AcademicPeriod: 'AcademicPeriod',
    Course: 'Course',
    Section: 'Section',
    SectionRegistration: 'SectionRegistration',
    StudentTranscriptGrade: 'StudentTranscriptGrade',
    AcademicProgram: 'AcademicProgram',
    StudentAcademicProgram: 'StudentAcademicProgram',
    AcademicCredential: 'AcademicCredential',
    StudentRisk: 'StudentRisk',
    SimulationState: 'SimulationState'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "person" | "personName" | "emailAddress" | "phone" | "address" | "student" | "academicPeriod" | "course" | "section" | "sectionRegistration" | "studentTranscriptGrade" | "academicProgram" | "studentAcademicProgram" | "academicCredential" | "studentRisk" | "simulationState"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      PersonName: {
        payload: Prisma.$PersonNamePayload<ExtArgs>
        fields: Prisma.PersonNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          findFirst: {
            args: Prisma.PersonNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          findMany: {
            args: Prisma.PersonNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>[]
          }
          create: {
            args: Prisma.PersonNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          createMany: {
            args: Prisma.PersonNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>[]
          }
          delete: {
            args: Prisma.PersonNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          update: {
            args: Prisma.PersonNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          deleteMany: {
            args: Prisma.PersonNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonNameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>[]
          }
          upsert: {
            args: Prisma.PersonNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          aggregate: {
            args: Prisma.PersonNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonName>
          }
          groupBy: {
            args: Prisma.PersonNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonNameCountArgs<ExtArgs>
            result: $Utils.Optional<PersonNameCountAggregateOutputType> | number
          }
        }
      }
      EmailAddress: {
        payload: Prisma.$EmailAddressPayload<ExtArgs>
        fields: Prisma.EmailAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          findFirst: {
            args: Prisma.EmailAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          findMany: {
            args: Prisma.EmailAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>[]
          }
          create: {
            args: Prisma.EmailAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          createMany: {
            args: Prisma.EmailAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>[]
          }
          delete: {
            args: Prisma.EmailAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          update: {
            args: Prisma.EmailAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          deleteMany: {
            args: Prisma.EmailAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>[]
          }
          upsert: {
            args: Prisma.EmailAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          aggregate: {
            args: Prisma.EmailAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAddress>
          }
          groupBy: {
            args: Prisma.EmailAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAddressCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAddressCountAggregateOutputType> | number
          }
        }
      }
      Phone: {
        payload: Prisma.$PhonePayload<ExtArgs>
        fields: Prisma.PhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          findFirst: {
            args: Prisma.PhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          findMany: {
            args: Prisma.PhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>[]
          }
          create: {
            args: Prisma.PhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          createMany: {
            args: Prisma.PhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>[]
          }
          delete: {
            args: Prisma.PhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          update: {
            args: Prisma.PhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          deleteMany: {
            args: Prisma.PhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>[]
          }
          upsert: {
            args: Prisma.PhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          aggregate: {
            args: Prisma.PhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhone>
          }
          groupBy: {
            args: Prisma.PhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      AcademicPeriod: {
        payload: Prisma.$AcademicPeriodPayload<ExtArgs>
        fields: Prisma.AcademicPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findFirst: {
            args: Prisma.AcademicPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findMany: {
            args: Prisma.AcademicPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          create: {
            args: Prisma.AcademicPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          createMany: {
            args: Prisma.AcademicPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          delete: {
            args: Prisma.AcademicPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          update: {
            args: Prisma.AcademicPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          deleteMany: {
            args: Prisma.AcademicPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          upsert: {
            args: Prisma.AcademicPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          aggregate: {
            args: Prisma.AcademicPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicPeriod>
          }
          groupBy: {
            args: Prisma.AcademicPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      SectionRegistration: {
        payload: Prisma.$SectionRegistrationPayload<ExtArgs>
        fields: Prisma.SectionRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          findFirst: {
            args: Prisma.SectionRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          findMany: {
            args: Prisma.SectionRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>[]
          }
          create: {
            args: Prisma.SectionRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          createMany: {
            args: Prisma.SectionRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>[]
          }
          delete: {
            args: Prisma.SectionRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          update: {
            args: Prisma.SectionRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.SectionRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.SectionRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          aggregate: {
            args: Prisma.SectionRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectionRegistration>
          }
          groupBy: {
            args: Prisma.SectionRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<SectionRegistrationCountAggregateOutputType> | number
          }
        }
      }
      StudentTranscriptGrade: {
        payload: Prisma.$StudentTranscriptGradePayload<ExtArgs>
        fields: Prisma.StudentTranscriptGradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTranscriptGradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          findFirst: {
            args: Prisma.StudentTranscriptGradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          findMany: {
            args: Prisma.StudentTranscriptGradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>[]
          }
          create: {
            args: Prisma.StudentTranscriptGradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          createMany: {
            args: Prisma.StudentTranscriptGradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>[]
          }
          delete: {
            args: Prisma.StudentTranscriptGradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          update: {
            args: Prisma.StudentTranscriptGradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          deleteMany: {
            args: Prisma.StudentTranscriptGradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTranscriptGradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentTranscriptGradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>[]
          }
          upsert: {
            args: Prisma.StudentTranscriptGradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          aggregate: {
            args: Prisma.StudentTranscriptGradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTranscriptGrade>
          }
          groupBy: {
            args: Prisma.StudentTranscriptGradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTranscriptGradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTranscriptGradeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTranscriptGradeCountAggregateOutputType> | number
          }
        }
      }
      AcademicProgram: {
        payload: Prisma.$AcademicProgramPayload<ExtArgs>
        fields: Prisma.AcademicProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          findFirst: {
            args: Prisma.AcademicProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          findMany: {
            args: Prisma.AcademicProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>[]
          }
          create: {
            args: Prisma.AcademicProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          createMany: {
            args: Prisma.AcademicProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>[]
          }
          delete: {
            args: Prisma.AcademicProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          update: {
            args: Prisma.AcademicProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          deleteMany: {
            args: Prisma.AcademicProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>[]
          }
          upsert: {
            args: Prisma.AcademicProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          aggregate: {
            args: Prisma.AcademicProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicProgram>
          }
          groupBy: {
            args: Prisma.AcademicProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicProgramCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicProgramCountAggregateOutputType> | number
          }
        }
      }
      StudentAcademicProgram: {
        payload: Prisma.$StudentAcademicProgramPayload<ExtArgs>
        fields: Prisma.StudentAcademicProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAcademicProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          findFirst: {
            args: Prisma.StudentAcademicProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          findMany: {
            args: Prisma.StudentAcademicProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>[]
          }
          create: {
            args: Prisma.StudentAcademicProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          createMany: {
            args: Prisma.StudentAcademicProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>[]
          }
          delete: {
            args: Prisma.StudentAcademicProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          update: {
            args: Prisma.StudentAcademicProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          deleteMany: {
            args: Prisma.StudentAcademicProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAcademicProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentAcademicProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>[]
          }
          upsert: {
            args: Prisma.StudentAcademicProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          aggregate: {
            args: Prisma.StudentAcademicProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAcademicProgram>
          }
          groupBy: {
            args: Prisma.StudentAcademicProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAcademicProgramCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicProgramCountAggregateOutputType> | number
          }
        }
      }
      AcademicCredential: {
        payload: Prisma.$AcademicCredentialPayload<ExtArgs>
        fields: Prisma.AcademicCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          findFirst: {
            args: Prisma.AcademicCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          findMany: {
            args: Prisma.AcademicCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>[]
          }
          create: {
            args: Prisma.AcademicCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          createMany: {
            args: Prisma.AcademicCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>[]
          }
          delete: {
            args: Prisma.AcademicCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          update: {
            args: Prisma.AcademicCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          deleteMany: {
            args: Prisma.AcademicCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicCredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>[]
          }
          upsert: {
            args: Prisma.AcademicCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          aggregate: {
            args: Prisma.AcademicCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicCredential>
          }
          groupBy: {
            args: Prisma.AcademicCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicCredentialCountAggregateOutputType> | number
          }
        }
      }
      StudentRisk: {
        payload: Prisma.$StudentRiskPayload<ExtArgs>
        fields: Prisma.StudentRiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentRiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentRiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          findFirst: {
            args: Prisma.StudentRiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentRiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          findMany: {
            args: Prisma.StudentRiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>[]
          }
          create: {
            args: Prisma.StudentRiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          createMany: {
            args: Prisma.StudentRiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentRiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>[]
          }
          delete: {
            args: Prisma.StudentRiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          update: {
            args: Prisma.StudentRiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          deleteMany: {
            args: Prisma.StudentRiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentRiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentRiskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>[]
          }
          upsert: {
            args: Prisma.StudentRiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          aggregate: {
            args: Prisma.StudentRiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentRisk>
          }
          groupBy: {
            args: Prisma.StudentRiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentRiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentRiskCountArgs<ExtArgs>
            result: $Utils.Optional<StudentRiskCountAggregateOutputType> | number
          }
        }
      }
      SimulationState: {
        payload: Prisma.$SimulationStatePayload<ExtArgs>
        fields: Prisma.SimulationStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          findFirst: {
            args: Prisma.SimulationStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          findMany: {
            args: Prisma.SimulationStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
          }
          create: {
            args: Prisma.SimulationStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          createMany: {
            args: Prisma.SimulationStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
          }
          delete: {
            args: Prisma.SimulationStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          update: {
            args: Prisma.SimulationStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          deleteMany: {
            args: Prisma.SimulationStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
          }
          upsert: {
            args: Prisma.SimulationStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          aggregate: {
            args: Prisma.SimulationStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationState>
          }
          groupBy: {
            args: Prisma.SimulationStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationStateCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationStateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    person?: PersonOmit
    personName?: PersonNameOmit
    emailAddress?: EmailAddressOmit
    phone?: PhoneOmit
    address?: AddressOmit
    student?: StudentOmit
    academicPeriod?: AcademicPeriodOmit
    course?: CourseOmit
    section?: SectionOmit
    sectionRegistration?: SectionRegistrationOmit
    studentTranscriptGrade?: StudentTranscriptGradeOmit
    academicProgram?: AcademicProgramOmit
    studentAcademicProgram?: StudentAcademicProgramOmit
    academicCredential?: AcademicCredentialOmit
    studentRisk?: StudentRiskOmit
    simulationState?: SimulationStateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    names: number
    emails: number
    phones: number
    addresses: number
    sections: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    names?: boolean | PersonCountOutputTypeCountNamesArgs
    emails?: boolean | PersonCountOutputTypeCountEmailsArgs
    phones?: boolean | PersonCountOutputTypeCountPhonesArgs
    addresses?: boolean | PersonCountOutputTypeCountAddressesArgs
    sections?: boolean | PersonCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonNameWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAddressWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    sectionRegistrations: number
    studentAcademicPrograms: number
    academicCredentials: number
    transcriptGrades: number
    studentRisks: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sectionRegistrations?: boolean | StudentCountOutputTypeCountSectionRegistrationsArgs
    studentAcademicPrograms?: boolean | StudentCountOutputTypeCountStudentAcademicProgramsArgs
    academicCredentials?: boolean | StudentCountOutputTypeCountAcademicCredentialsArgs
    transcriptGrades?: boolean | StudentCountOutputTypeCountTranscriptGradesArgs
    studentRisks?: boolean | StudentCountOutputTypeCountStudentRisksArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAcademicProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAcademicCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
  }


  /**
   * Count Type AcademicPeriodCountOutputType
   */

  export type AcademicPeriodCountOutputType = {
    sections: number
    sectionRegistrations: number
    transcriptGrades: number
    entryStudents: number
    credentialPeriods: number
    studentRisks: number
  }

  export type AcademicPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicPeriodCountOutputTypeCountSectionsArgs
    sectionRegistrations?: boolean | AcademicPeriodCountOutputTypeCountSectionRegistrationsArgs
    transcriptGrades?: boolean | AcademicPeriodCountOutputTypeCountTranscriptGradesArgs
    entryStudents?: boolean | AcademicPeriodCountOutputTypeCountEntryStudentsArgs
    credentialPeriods?: boolean | AcademicPeriodCountOutputTypeCountCredentialPeriodsArgs
    studentRisks?: boolean | AcademicPeriodCountOutputTypeCountStudentRisksArgs
  }

  // Custom InputTypes
  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriodCountOutputType
     */
    select?: AcademicPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountEntryStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountCredentialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountStudentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    sections: number
    transcriptGrades: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | CourseCountOutputTypeCountSectionsArgs
    transcriptGrades?: boolean | CourseCountOutputTypeCountTranscriptGradesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    sectionRegistrations: number
    transcriptGrades: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sectionRegistrations?: boolean | SectionCountOutputTypeCountSectionRegistrationsArgs
    transcriptGrades?: boolean | SectionCountOutputTypeCountTranscriptGradesArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }


  /**
   * Count Type AcademicProgramCountOutputType
   */

  export type AcademicProgramCountOutputType = {
    studentPrograms: number
    credentials: number
  }

  export type AcademicProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPrograms?: boolean | AcademicProgramCountOutputTypeCountStudentProgramsArgs
    credentials?: boolean | AcademicProgramCountOutputTypeCountCredentialsArgs
  }

  // Custom InputTypes
  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgramCountOutputType
     */
    select?: AcademicProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeCountStudentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeCountCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    birthDate: number
    gender: number
    citizenshipStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date
    updatedAt: Date
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    names?: boolean | Person$namesArgs<ExtArgs>
    emails?: boolean | Person$emailsArgs<ExtArgs>
    phones?: boolean | Person$phonesArgs<ExtArgs>
    addresses?: boolean | Person$addressesArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    sections?: boolean | Person$sectionsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "birthDate" | "gender" | "citizenshipStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    names?: boolean | Person$namesArgs<ExtArgs>
    emails?: boolean | Person$emailsArgs<ExtArgs>
    phones?: boolean | Person$phonesArgs<ExtArgs>
    addresses?: boolean | Person$addressesArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    sections?: boolean | Person$sectionsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      names: Prisma.$PersonNamePayload<ExtArgs>[]
      emails: Prisma.$EmailAddressPayload<ExtArgs>[]
      phones: Prisma.$PhonePayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
      sections: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      birthDate: Date | null
      gender: string | null
      citizenshipStatus: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People and returns the data updated in the database.
     * @param {PersonUpdateManyAndReturnArgs} args - Arguments to update many People.
     * @example
     * // Update many People
     * const person = await prisma.person.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more People and only return the `id`
     * const personWithIdOnly = await prisma.person.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    names<T extends Person$namesArgs<ExtArgs> = {}>(args?: Subset<T, Person$namesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends Person$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Person$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phones<T extends Person$phonesArgs<ExtArgs> = {}>(args?: Subset<T, Person$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends Person$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Person$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends Person$studentArgs<ExtArgs> = {}>(args?: Subset<T, Person$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sections<T extends Person$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Person$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly birthDate: FieldRef<"Person", 'DateTime'>
    readonly gender: FieldRef<"Person", 'String'>
    readonly citizenshipStatus: FieldRef<"Person", 'String'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
    readonly updatedAt: FieldRef<"Person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person updateManyAndReturn
   */
  export type PersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * Person.names
   */
  export type Person$namesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    where?: PersonNameWhereInput
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    cursor?: PersonNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * Person.emails
   */
  export type Person$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    where?: EmailAddressWhereInput
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    cursor?: EmailAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * Person.phones
   */
  export type Person$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    where?: PhoneWhereInput
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    cursor?: PhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Person.addresses
   */
  export type Person$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Person.student
   */
  export type Person$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Person.sections
   */
  export type Person$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model PersonName
   */

  export type AggregatePersonName = {
    _count: PersonNameCountAggregateOutputType | null
    _min: PersonNameMinAggregateOutputType | null
    _max: PersonNameMaxAggregateOutputType | null
  }

  export type PersonNameMinAggregateOutputType = {
    id: string | null
    personId: string | null
    given: string | null
    middle: string | null
    family: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonNameMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    given: string | null
    middle: string | null
    family: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonNameCountAggregateOutputType = {
    id: number
    personId: number
    given: number
    middle: number
    family: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonNameMinAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonNameMaxAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonNameCountAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonName to aggregate.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonNames
    **/
    _count?: true | PersonNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonNameMaxAggregateInputType
  }

  export type GetPersonNameAggregateType<T extends PersonNameAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonName[P]>
      : GetScalarType<T[P], AggregatePersonName[P]>
  }




  export type PersonNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonNameWhereInput
    orderBy?: PersonNameOrderByWithAggregationInput | PersonNameOrderByWithAggregationInput[]
    by: PersonNameScalarFieldEnum[] | PersonNameScalarFieldEnum
    having?: PersonNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonNameCountAggregateInputType | true
    _min?: PersonNameMinAggregateInputType
    _max?: PersonNameMaxAggregateInputType
  }

  export type PersonNameGroupByOutputType = {
    id: string
    personId: string
    given: string
    middle: string | null
    family: string
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: PersonNameCountAggregateOutputType | null
    _min: PersonNameMinAggregateOutputType | null
    _max: PersonNameMaxAggregateOutputType | null
  }

  type GetPersonNameGroupByPayload<T extends PersonNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonNameGroupByOutputType[P]>
            : GetScalarType<T[P], PersonNameGroupByOutputType[P]>
        }
      >
    >


  export type PersonNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personName"]>

  export type PersonNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personName"]>

  export type PersonNameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personName"]>

  export type PersonNameSelectScalar = {
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "given" | "middle" | "family" | "type" | "preferred" | "createdAt" | "updatedAt", ExtArgs["result"]["personName"]>
  export type PersonNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PersonNameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PersonNameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $PersonNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonName"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      given: string
      middle: string | null
      family: string
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personName"]>
    composites: {}
  }

  type PersonNameGetPayload<S extends boolean | null | undefined | PersonNameDefaultArgs> = $Result.GetResult<Prisma.$PersonNamePayload, S>

  type PersonNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonNameCountAggregateInputType | true
    }

  export interface PersonNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonName'], meta: { name: 'PersonName' } }
    /**
     * Find zero or one PersonName that matches the filter.
     * @param {PersonNameFindUniqueArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonNameFindUniqueArgs>(args: SelectSubset<T, PersonNameFindUniqueArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonNameFindUniqueOrThrowArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonNameFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindFirstArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonNameFindFirstArgs>(args?: SelectSubset<T, PersonNameFindFirstArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindFirstOrThrowArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonNameFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonNames
     * const personNames = await prisma.personName.findMany()
     * 
     * // Get first 10 PersonNames
     * const personNames = await prisma.personName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personNameWithIdOnly = await prisma.personName.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonNameFindManyArgs>(args?: SelectSubset<T, PersonNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonName.
     * @param {PersonNameCreateArgs} args - Arguments to create a PersonName.
     * @example
     * // Create one PersonName
     * const PersonName = await prisma.personName.create({
     *   data: {
     *     // ... data to create a PersonName
     *   }
     * })
     * 
     */
    create<T extends PersonNameCreateArgs>(args: SelectSubset<T, PersonNameCreateArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonNames.
     * @param {PersonNameCreateManyArgs} args - Arguments to create many PersonNames.
     * @example
     * // Create many PersonNames
     * const personName = await prisma.personName.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonNameCreateManyArgs>(args?: SelectSubset<T, PersonNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonNames and returns the data saved in the database.
     * @param {PersonNameCreateManyAndReturnArgs} args - Arguments to create many PersonNames.
     * @example
     * // Create many PersonNames
     * const personName = await prisma.personName.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonNames and only return the `id`
     * const personNameWithIdOnly = await prisma.personName.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonNameCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonName.
     * @param {PersonNameDeleteArgs} args - Arguments to delete one PersonName.
     * @example
     * // Delete one PersonName
     * const PersonName = await prisma.personName.delete({
     *   where: {
     *     // ... filter to delete one PersonName
     *   }
     * })
     * 
     */
    delete<T extends PersonNameDeleteArgs>(args: SelectSubset<T, PersonNameDeleteArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonName.
     * @param {PersonNameUpdateArgs} args - Arguments to update one PersonName.
     * @example
     * // Update one PersonName
     * const personName = await prisma.personName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonNameUpdateArgs>(args: SelectSubset<T, PersonNameUpdateArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonNames.
     * @param {PersonNameDeleteManyArgs} args - Arguments to filter PersonNames to delete.
     * @example
     * // Delete a few PersonNames
     * const { count } = await prisma.personName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonNameDeleteManyArgs>(args?: SelectSubset<T, PersonNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonNames
     * const personName = await prisma.personName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonNameUpdateManyArgs>(args: SelectSubset<T, PersonNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonNames and returns the data updated in the database.
     * @param {PersonNameUpdateManyAndReturnArgs} args - Arguments to update many PersonNames.
     * @example
     * // Update many PersonNames
     * const personName = await prisma.personName.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonNames and only return the `id`
     * const personNameWithIdOnly = await prisma.personName.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonNameUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonNameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonName.
     * @param {PersonNameUpsertArgs} args - Arguments to update or create a PersonName.
     * @example
     * // Update or create a PersonName
     * const personName = await prisma.personName.upsert({
     *   create: {
     *     // ... data to create a PersonName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonName we want to update
     *   }
     * })
     */
    upsert<T extends PersonNameUpsertArgs>(args: SelectSubset<T, PersonNameUpsertArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameCountArgs} args - Arguments to filter PersonNames to count.
     * @example
     * // Count the number of PersonNames
     * const count = await prisma.personName.count({
     *   where: {
     *     // ... the filter for the PersonNames we want to count
     *   }
     * })
    **/
    count<T extends PersonNameCountArgs>(
      args?: Subset<T, PersonNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonNameAggregateArgs>(args: Subset<T, PersonNameAggregateArgs>): Prisma.PrismaPromise<GetPersonNameAggregateType<T>>

    /**
     * Group by PersonName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonNameGroupByArgs['orderBy'] }
        : { orderBy?: PersonNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonName model
   */
  readonly fields: PersonNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonName model
   */
  interface PersonNameFieldRefs {
    readonly id: FieldRef<"PersonName", 'String'>
    readonly personId: FieldRef<"PersonName", 'String'>
    readonly given: FieldRef<"PersonName", 'String'>
    readonly middle: FieldRef<"PersonName", 'String'>
    readonly family: FieldRef<"PersonName", 'String'>
    readonly type: FieldRef<"PersonName", 'String'>
    readonly preferred: FieldRef<"PersonName", 'Boolean'>
    readonly createdAt: FieldRef<"PersonName", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonName", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonName findUnique
   */
  export type PersonNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName findUniqueOrThrow
   */
  export type PersonNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName findFirst
   */
  export type PersonNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonNames.
     */
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName findFirstOrThrow
   */
  export type PersonNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonNames.
     */
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName findMany
   */
  export type PersonNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonNames to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName create
   */
  export type PersonNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonName.
     */
    data: XOR<PersonNameCreateInput, PersonNameUncheckedCreateInput>
  }

  /**
   * PersonName createMany
   */
  export type PersonNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonNames.
     */
    data: PersonNameCreateManyInput | PersonNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonName createManyAndReturn
   */
  export type PersonNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * The data used to create many PersonNames.
     */
    data: PersonNameCreateManyInput | PersonNameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonName update
   */
  export type PersonNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonName.
     */
    data: XOR<PersonNameUpdateInput, PersonNameUncheckedUpdateInput>
    /**
     * Choose, which PersonName to update.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName updateMany
   */
  export type PersonNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonNames.
     */
    data: XOR<PersonNameUpdateManyMutationInput, PersonNameUncheckedUpdateManyInput>
    /**
     * Filter which PersonNames to update
     */
    where?: PersonNameWhereInput
    /**
     * Limit how many PersonNames to update.
     */
    limit?: number
  }

  /**
   * PersonName updateManyAndReturn
   */
  export type PersonNameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * The data used to update PersonNames.
     */
    data: XOR<PersonNameUpdateManyMutationInput, PersonNameUncheckedUpdateManyInput>
    /**
     * Filter which PersonNames to update
     */
    where?: PersonNameWhereInput
    /**
     * Limit how many PersonNames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonName upsert
   */
  export type PersonNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonName to update in case it exists.
     */
    where: PersonNameWhereUniqueInput
    /**
     * In case the PersonName found by the `where` argument doesn't exist, create a new PersonName with this data.
     */
    create: XOR<PersonNameCreateInput, PersonNameUncheckedCreateInput>
    /**
     * In case the PersonName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonNameUpdateInput, PersonNameUncheckedUpdateInput>
  }

  /**
   * PersonName delete
   */
  export type PersonNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter which PersonName to delete.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName deleteMany
   */
  export type PersonNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonNames to delete
     */
    where?: PersonNameWhereInput
    /**
     * Limit how many PersonNames to delete.
     */
    limit?: number
  }

  /**
   * PersonName without action
   */
  export type PersonNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonName
     */
    omit?: PersonNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
  }


  /**
   * Model EmailAddress
   */

  export type AggregateEmailAddress = {
    _count: EmailAddressCountAggregateOutputType | null
    _min: EmailAddressMinAggregateOutputType | null
    _max: EmailAddressMaxAggregateOutputType | null
  }

  export type EmailAddressMinAggregateOutputType = {
    id: string | null
    personId: string | null
    address: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAddressMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    address: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAddressCountAggregateOutputType = {
    id: number
    personId: number
    address: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailAddressMinAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAddressMaxAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAddressCountAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAddress to aggregate.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAddresses
    **/
    _count?: true | EmailAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAddressMaxAggregateInputType
  }

  export type GetEmailAddressAggregateType<T extends EmailAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAddress[P]>
      : GetScalarType<T[P], AggregateEmailAddress[P]>
  }




  export type EmailAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAddressWhereInput
    orderBy?: EmailAddressOrderByWithAggregationInput | EmailAddressOrderByWithAggregationInput[]
    by: EmailAddressScalarFieldEnum[] | EmailAddressScalarFieldEnum
    having?: EmailAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAddressCountAggregateInputType | true
    _min?: EmailAddressMinAggregateInputType
    _max?: EmailAddressMaxAggregateInputType
  }

  export type EmailAddressGroupByOutputType = {
    id: string
    personId: string
    address: string
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailAddressCountAggregateOutputType | null
    _min: EmailAddressMinAggregateOutputType | null
    _max: EmailAddressMaxAggregateOutputType | null
  }

  type GetEmailAddressGroupByPayload<T extends EmailAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAddressGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAddressGroupByOutputType[P]>
        }
      >
    >


  export type EmailAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAddress"]>

  export type EmailAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAddress"]>

  export type EmailAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAddress"]>

  export type EmailAddressSelectScalar = {
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "address" | "type" | "preferred" | "createdAt" | "updatedAt", ExtArgs["result"]["emailAddress"]>
  export type EmailAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type EmailAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type EmailAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $EmailAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAddress"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      address: string
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailAddress"]>
    composites: {}
  }

  type EmailAddressGetPayload<S extends boolean | null | undefined | EmailAddressDefaultArgs> = $Result.GetResult<Prisma.$EmailAddressPayload, S>

  type EmailAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAddressCountAggregateInputType | true
    }

  export interface EmailAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAddress'], meta: { name: 'EmailAddress' } }
    /**
     * Find zero or one EmailAddress that matches the filter.
     * @param {EmailAddressFindUniqueArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAddressFindUniqueArgs>(args: SelectSubset<T, EmailAddressFindUniqueArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAddressFindUniqueOrThrowArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindFirstArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAddressFindFirstArgs>(args?: SelectSubset<T, EmailAddressFindFirstArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindFirstOrThrowArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAddresses
     * const emailAddresses = await prisma.emailAddress.findMany()
     * 
     * // Get first 10 EmailAddresses
     * const emailAddresses = await prisma.emailAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAddressWithIdOnly = await prisma.emailAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAddressFindManyArgs>(args?: SelectSubset<T, EmailAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAddress.
     * @param {EmailAddressCreateArgs} args - Arguments to create a EmailAddress.
     * @example
     * // Create one EmailAddress
     * const EmailAddress = await prisma.emailAddress.create({
     *   data: {
     *     // ... data to create a EmailAddress
     *   }
     * })
     * 
     */
    create<T extends EmailAddressCreateArgs>(args: SelectSubset<T, EmailAddressCreateArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAddresses.
     * @param {EmailAddressCreateManyArgs} args - Arguments to create many EmailAddresses.
     * @example
     * // Create many EmailAddresses
     * const emailAddress = await prisma.emailAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAddressCreateManyArgs>(args?: SelectSubset<T, EmailAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAddresses and returns the data saved in the database.
     * @param {EmailAddressCreateManyAndReturnArgs} args - Arguments to create many EmailAddresses.
     * @example
     * // Create many EmailAddresses
     * const emailAddress = await prisma.emailAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAddresses and only return the `id`
     * const emailAddressWithIdOnly = await prisma.emailAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAddress.
     * @param {EmailAddressDeleteArgs} args - Arguments to delete one EmailAddress.
     * @example
     * // Delete one EmailAddress
     * const EmailAddress = await prisma.emailAddress.delete({
     *   where: {
     *     // ... filter to delete one EmailAddress
     *   }
     * })
     * 
     */
    delete<T extends EmailAddressDeleteArgs>(args: SelectSubset<T, EmailAddressDeleteArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAddress.
     * @param {EmailAddressUpdateArgs} args - Arguments to update one EmailAddress.
     * @example
     * // Update one EmailAddress
     * const emailAddress = await prisma.emailAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAddressUpdateArgs>(args: SelectSubset<T, EmailAddressUpdateArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAddresses.
     * @param {EmailAddressDeleteManyArgs} args - Arguments to filter EmailAddresses to delete.
     * @example
     * // Delete a few EmailAddresses
     * const { count } = await prisma.emailAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAddressDeleteManyArgs>(args?: SelectSubset<T, EmailAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAddresses
     * const emailAddress = await prisma.emailAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAddressUpdateManyArgs>(args: SelectSubset<T, EmailAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAddresses and returns the data updated in the database.
     * @param {EmailAddressUpdateManyAndReturnArgs} args - Arguments to update many EmailAddresses.
     * @example
     * // Update many EmailAddresses
     * const emailAddress = await prisma.emailAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAddresses and only return the `id`
     * const emailAddressWithIdOnly = await prisma.emailAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAddress.
     * @param {EmailAddressUpsertArgs} args - Arguments to update or create a EmailAddress.
     * @example
     * // Update or create a EmailAddress
     * const emailAddress = await prisma.emailAddress.upsert({
     *   create: {
     *     // ... data to create a EmailAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAddress we want to update
     *   }
     * })
     */
    upsert<T extends EmailAddressUpsertArgs>(args: SelectSubset<T, EmailAddressUpsertArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressCountArgs} args - Arguments to filter EmailAddresses to count.
     * @example
     * // Count the number of EmailAddresses
     * const count = await prisma.emailAddress.count({
     *   where: {
     *     // ... the filter for the EmailAddresses we want to count
     *   }
     * })
    **/
    count<T extends EmailAddressCountArgs>(
      args?: Subset<T, EmailAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAddressAggregateArgs>(args: Subset<T, EmailAddressAggregateArgs>): Prisma.PrismaPromise<GetEmailAddressAggregateType<T>>

    /**
     * Group by EmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAddressGroupByArgs['orderBy'] }
        : { orderBy?: EmailAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAddress model
   */
  readonly fields: EmailAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAddress model
   */
  interface EmailAddressFieldRefs {
    readonly id: FieldRef<"EmailAddress", 'String'>
    readonly personId: FieldRef<"EmailAddress", 'String'>
    readonly address: FieldRef<"EmailAddress", 'String'>
    readonly type: FieldRef<"EmailAddress", 'String'>
    readonly preferred: FieldRef<"EmailAddress", 'Boolean'>
    readonly createdAt: FieldRef<"EmailAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAddress findUnique
   */
  export type EmailAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress findUniqueOrThrow
   */
  export type EmailAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress findFirst
   */
  export type EmailAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAddresses.
     */
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress findFirstOrThrow
   */
  export type EmailAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAddresses.
     */
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress findMany
   */
  export type EmailAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddresses to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress create
   */
  export type EmailAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAddress.
     */
    data: XOR<EmailAddressCreateInput, EmailAddressUncheckedCreateInput>
  }

  /**
   * EmailAddress createMany
   */
  export type EmailAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAddresses.
     */
    data: EmailAddressCreateManyInput | EmailAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAddress createManyAndReturn
   */
  export type EmailAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAddresses.
     */
    data: EmailAddressCreateManyInput | EmailAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAddress update
   */
  export type EmailAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAddress.
     */
    data: XOR<EmailAddressUpdateInput, EmailAddressUncheckedUpdateInput>
    /**
     * Choose, which EmailAddress to update.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress updateMany
   */
  export type EmailAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAddresses.
     */
    data: XOR<EmailAddressUpdateManyMutationInput, EmailAddressUncheckedUpdateManyInput>
    /**
     * Filter which EmailAddresses to update
     */
    where?: EmailAddressWhereInput
    /**
     * Limit how many EmailAddresses to update.
     */
    limit?: number
  }

  /**
   * EmailAddress updateManyAndReturn
   */
  export type EmailAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * The data used to update EmailAddresses.
     */
    data: XOR<EmailAddressUpdateManyMutationInput, EmailAddressUncheckedUpdateManyInput>
    /**
     * Filter which EmailAddresses to update
     */
    where?: EmailAddressWhereInput
    /**
     * Limit how many EmailAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAddress upsert
   */
  export type EmailAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAddress to update in case it exists.
     */
    where: EmailAddressWhereUniqueInput
    /**
     * In case the EmailAddress found by the `where` argument doesn't exist, create a new EmailAddress with this data.
     */
    create: XOR<EmailAddressCreateInput, EmailAddressUncheckedCreateInput>
    /**
     * In case the EmailAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAddressUpdateInput, EmailAddressUncheckedUpdateInput>
  }

  /**
   * EmailAddress delete
   */
  export type EmailAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter which EmailAddress to delete.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress deleteMany
   */
  export type EmailAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAddresses to delete
     */
    where?: EmailAddressWhereInput
    /**
     * Limit how many EmailAddresses to delete.
     */
    limit?: number
  }

  /**
   * EmailAddress without action
   */
  export type EmailAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAddress
     */
    omit?: EmailAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
  }


  /**
   * Model Phone
   */

  export type AggregatePhone = {
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  export type PhoneMinAggregateOutputType = {
    id: string | null
    personId: string | null
    number: string | null
    extension: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    number: string | null
    extension: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneCountAggregateOutputType = {
    id: number
    personId: number
    number: number
    extension: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhoneMinAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneMaxAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneCountAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phone to aggregate.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phones
    **/
    _count?: true | PhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneMaxAggregateInputType
  }

  export type GetPhoneAggregateType<T extends PhoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhone[P]>
      : GetScalarType<T[P], AggregatePhone[P]>
  }




  export type PhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneWhereInput
    orderBy?: PhoneOrderByWithAggregationInput | PhoneOrderByWithAggregationInput[]
    by: PhoneScalarFieldEnum[] | PhoneScalarFieldEnum
    having?: PhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneCountAggregateInputType | true
    _min?: PhoneMinAggregateInputType
    _max?: PhoneMaxAggregateInputType
  }

  export type PhoneGroupByOutputType = {
    id: string
    personId: string
    number: string
    extension: string | null
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  type GetPhoneGroupByPayload<T extends PhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneGroupByOutputType[P]>
        }
      >
    >


  export type PhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phone"]>

  export type PhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phone"]>

  export type PhoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phone"]>

  export type PhoneSelectScalar = {
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "number" | "extension" | "type" | "preferred" | "createdAt" | "updatedAt", ExtArgs["result"]["phone"]>
  export type PhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PhoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $PhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phone"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      number: string
      extension: string | null
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phone"]>
    composites: {}
  }

  type PhoneGetPayload<S extends boolean | null | undefined | PhoneDefaultArgs> = $Result.GetResult<Prisma.$PhonePayload, S>

  type PhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhoneCountAggregateInputType | true
    }

  export interface PhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phone'], meta: { name: 'Phone' } }
    /**
     * Find zero or one Phone that matches the filter.
     * @param {PhoneFindUniqueArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneFindUniqueArgs>(args: SelectSubset<T, PhoneFindUniqueArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Phone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneFindUniqueOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneFindFirstArgs>(args?: SelectSubset<T, PhoneFindFirstArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Phones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phones
     * const phones = await prisma.phone.findMany()
     * 
     * // Get first 10 Phones
     * const phones = await prisma.phone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneWithIdOnly = await prisma.phone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhoneFindManyArgs>(args?: SelectSubset<T, PhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Phone.
     * @param {PhoneCreateArgs} args - Arguments to create a Phone.
     * @example
     * // Create one Phone
     * const Phone = await prisma.phone.create({
     *   data: {
     *     // ... data to create a Phone
     *   }
     * })
     * 
     */
    create<T extends PhoneCreateArgs>(args: SelectSubset<T, PhoneCreateArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Phones.
     * @param {PhoneCreateManyArgs} args - Arguments to create many Phones.
     * @example
     * // Create many Phones
     * const phone = await prisma.phone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneCreateManyArgs>(args?: SelectSubset<T, PhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phones and returns the data saved in the database.
     * @param {PhoneCreateManyAndReturnArgs} args - Arguments to create many Phones.
     * @example
     * // Create many Phones
     * const phone = await prisma.phone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phones and only return the `id`
     * const phoneWithIdOnly = await prisma.phone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, PhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Phone.
     * @param {PhoneDeleteArgs} args - Arguments to delete one Phone.
     * @example
     * // Delete one Phone
     * const Phone = await prisma.phone.delete({
     *   where: {
     *     // ... filter to delete one Phone
     *   }
     * })
     * 
     */
    delete<T extends PhoneDeleteArgs>(args: SelectSubset<T, PhoneDeleteArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Phone.
     * @param {PhoneUpdateArgs} args - Arguments to update one Phone.
     * @example
     * // Update one Phone
     * const phone = await prisma.phone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneUpdateArgs>(args: SelectSubset<T, PhoneUpdateArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Phones.
     * @param {PhoneDeleteManyArgs} args - Arguments to filter Phones to delete.
     * @example
     * // Delete a few Phones
     * const { count } = await prisma.phone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneDeleteManyArgs>(args?: SelectSubset<T, PhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phones
     * const phone = await prisma.phone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneUpdateManyArgs>(args: SelectSubset<T, PhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phones and returns the data updated in the database.
     * @param {PhoneUpdateManyAndReturnArgs} args - Arguments to update many Phones.
     * @example
     * // Update many Phones
     * const phone = await prisma.phone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Phones and only return the `id`
     * const phoneWithIdOnly = await prisma.phone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhoneUpdateManyAndReturnArgs>(args: SelectSubset<T, PhoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Phone.
     * @param {PhoneUpsertArgs} args - Arguments to update or create a Phone.
     * @example
     * // Update or create a Phone
     * const phone = await prisma.phone.upsert({
     *   create: {
     *     // ... data to create a Phone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phone we want to update
     *   }
     * })
     */
    upsert<T extends PhoneUpsertArgs>(args: SelectSubset<T, PhoneUpsertArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCountArgs} args - Arguments to filter Phones to count.
     * @example
     * // Count the number of Phones
     * const count = await prisma.phone.count({
     *   where: {
     *     // ... the filter for the Phones we want to count
     *   }
     * })
    **/
    count<T extends PhoneCountArgs>(
      args?: Subset<T, PhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneAggregateArgs>(args: Subset<T, PhoneAggregateArgs>): Prisma.PrismaPromise<GetPhoneAggregateType<T>>

    /**
     * Group by Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneGroupByArgs['orderBy'] }
        : { orderBy?: PhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phone model
   */
  readonly fields: PhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phone model
   */
  interface PhoneFieldRefs {
    readonly id: FieldRef<"Phone", 'String'>
    readonly personId: FieldRef<"Phone", 'String'>
    readonly number: FieldRef<"Phone", 'String'>
    readonly extension: FieldRef<"Phone", 'String'>
    readonly type: FieldRef<"Phone", 'String'>
    readonly preferred: FieldRef<"Phone", 'Boolean'>
    readonly createdAt: FieldRef<"Phone", 'DateTime'>
    readonly updatedAt: FieldRef<"Phone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Phone findUnique
   */
  export type PhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone findUniqueOrThrow
   */
  export type PhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone findFirst
   */
  export type PhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone findFirstOrThrow
   */
  export type PhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone findMany
   */
  export type PhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phones to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone create
   */
  export type PhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Phone.
     */
    data: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
  }

  /**
   * Phone createMany
   */
  export type PhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phones.
     */
    data: PhoneCreateManyInput | PhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phone createManyAndReturn
   */
  export type PhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * The data used to create many Phones.
     */
    data: PhoneCreateManyInput | PhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phone update
   */
  export type PhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Phone.
     */
    data: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
    /**
     * Choose, which Phone to update.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone updateMany
   */
  export type PhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phones.
     */
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyInput>
    /**
     * Filter which Phones to update
     */
    where?: PhoneWhereInput
    /**
     * Limit how many Phones to update.
     */
    limit?: number
  }

  /**
   * Phone updateManyAndReturn
   */
  export type PhoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * The data used to update Phones.
     */
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyInput>
    /**
     * Filter which Phones to update
     */
    where?: PhoneWhereInput
    /**
     * Limit how many Phones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phone upsert
   */
  export type PhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Phone to update in case it exists.
     */
    where: PhoneWhereUniqueInput
    /**
     * In case the Phone found by the `where` argument doesn't exist, create a new Phone with this data.
     */
    create: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
    /**
     * In case the Phone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
  }

  /**
   * Phone delete
   */
  export type PhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter which Phone to delete.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone deleteMany
   */
  export type PhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phones to delete
     */
    where?: PhoneWhereInput
    /**
     * Limit how many Phones to delete.
     */
    limit?: number
  }

  /**
   * Phone without action
   */
  export type PhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phone
     */
    omit?: PhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    personId: number
    type: number
    line1: number
    line2: number
    city: number
    state: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    personId: string
    type: string
    line1: string
    line2: string | null
    city: string
    state: string
    postalCode: string
    country: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "type" | "line1" | "line2" | "city" | "state" | "postalCode" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      type: string
      line1: string
      line2: string | null
      city: string
      state: string
      postalCode: string
      country: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly personId: FieldRef<"Address", 'String'>
    readonly type: FieldRef<"Address", 'String'>
    readonly line1: FieldRef<"Address", 'String'>
    readonly line2: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    workHoursPerWeek: number | null
    commuteMinutes: number | null
  }

  export type StudentSumAggregateOutputType = {
    workHoursPerWeek: number | null
    commuteMinutes: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    status: string | null
    startOn: Date | null
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string | null
    isFirstGen: boolean | null
    isPellEligible: boolean | null
    isInState: boolean | null
    workHoursPerWeek: number | null
    commuteMinutes: number | null
    hasHousingInstability: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    status: string | null
    startOn: Date | null
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string | null
    isFirstGen: boolean | null
    isPellEligible: boolean | null
    isInState: boolean | null
    workHoursPerWeek: number | null
    commuteMinutes: number | null
    hasHousingInstability: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    personId: number
    type: number
    status: number
    startOn: number
    entryAcademicPeriodId: number
    academicLevel: number
    residency: number
    studentClassification: number
    studentLoad: number
    academicStandingCode: number
    studentNumber: number
    isFirstGen: number
    isPellEligible: number
    isInState: number
    workHoursPerWeek: number
    commuteMinutes: number
    hasHousingInstability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    workHoursPerWeek?: true
    commuteMinutes?: true
  }

  export type StudentSumAggregateInputType = {
    workHoursPerWeek?: true
    commuteMinutes?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    personId: string
    type: string
    status: string
    startOn: Date
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string
    isFirstGen: boolean
    isPellEligible: boolean
    isInState: boolean
    workHoursPerWeek: number
    commuteMinutes: number
    hasHousingInstability: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
    sectionRegistrations?: boolean | Student$sectionRegistrationsArgs<ExtArgs>
    studentAcademicPrograms?: boolean | Student$studentAcademicProgramsArgs<ExtArgs>
    academicCredentials?: boolean | Student$academicCredentialsArgs<ExtArgs>
    transcriptGrades?: boolean | Student$transcriptGradesArgs<ExtArgs>
    studentRisks?: boolean | Student$studentRisksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "type" | "status" | "startOn" | "entryAcademicPeriodId" | "academicLevel" | "residency" | "studentClassification" | "studentLoad" | "academicStandingCode" | "studentNumber" | "isFirstGen" | "isPellEligible" | "isInState" | "workHoursPerWeek" | "commuteMinutes" | "hasHousingInstability" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
    sectionRegistrations?: boolean | Student$sectionRegistrationsArgs<ExtArgs>
    studentAcademicPrograms?: boolean | Student$studentAcademicProgramsArgs<ExtArgs>
    academicCredentials?: boolean | Student$academicCredentialsArgs<ExtArgs>
    transcriptGrades?: boolean | Student$transcriptGradesArgs<ExtArgs>
    studentRisks?: boolean | Student$studentRisksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      entryAcademicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      studentAcademicPrograms: Prisma.$StudentAcademicProgramPayload<ExtArgs>[]
      academicCredentials: Prisma.$AcademicCredentialPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
      studentRisks: Prisma.$StudentRiskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      type: string
      status: string
      startOn: Date
      entryAcademicPeriodId: string | null
      academicLevel: string | null
      residency: string | null
      studentClassification: string | null
      studentLoad: string | null
      academicStandingCode: string | null
      studentNumber: string
      isFirstGen: boolean
      isPellEligible: boolean
      isInState: boolean
      workHoursPerWeek: number
      commuteMinutes: number
      hasHousingInstability: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entryAcademicPeriod<T extends Student$entryAcademicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, Student$entryAcademicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sectionRegistrations<T extends Student$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentAcademicPrograms<T extends Student$studentAcademicProgramsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentAcademicProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicCredentials<T extends Student$academicCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, Student$academicCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcriptGrades<T extends Student$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Student$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentRisks<T extends Student$studentRisksArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentRisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly personId: FieldRef<"Student", 'String'>
    readonly type: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'String'>
    readonly startOn: FieldRef<"Student", 'DateTime'>
    readonly entryAcademicPeriodId: FieldRef<"Student", 'String'>
    readonly academicLevel: FieldRef<"Student", 'String'>
    readonly residency: FieldRef<"Student", 'String'>
    readonly studentClassification: FieldRef<"Student", 'String'>
    readonly studentLoad: FieldRef<"Student", 'String'>
    readonly academicStandingCode: FieldRef<"Student", 'String'>
    readonly studentNumber: FieldRef<"Student", 'String'>
    readonly isFirstGen: FieldRef<"Student", 'Boolean'>
    readonly isPellEligible: FieldRef<"Student", 'Boolean'>
    readonly isInState: FieldRef<"Student", 'Boolean'>
    readonly workHoursPerWeek: FieldRef<"Student", 'Int'>
    readonly commuteMinutes: FieldRef<"Student", 'Int'>
    readonly hasHousingInstability: FieldRef<"Student", 'Boolean'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.entryAcademicPeriod
   */
  export type Student$entryAcademicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * Student.sectionRegistrations
   */
  export type Student$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * Student.studentAcademicPrograms
   */
  export type Student$studentAcademicProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    cursor?: StudentAcademicProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * Student.academicCredentials
   */
  export type Student$academicCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * Student.transcriptGrades
   */
  export type Student$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Student.studentRisks
   */
  export type Student$studentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    cursor?: StudentRiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model AcademicPeriod
   */

  export type AggregateAcademicPeriod = {
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  export type AcademicPeriodMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    startOn: Date | null
    endOn: Date | null
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicPeriodMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    startOn: Date | null
    endOn: Date | null
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicPeriodCountAggregateOutputType = {
    id: number
    code: number
    title: number
    type: number
    startOn: number
    endOn: number
    censusOn: number
    registrationStartOn: number
    registrationEndOn: number
    academicYear: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicPeriodMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicPeriodMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicPeriodCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriod to aggregate.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPeriods
    **/
    _count?: true | AcademicPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type GetAcademicPeriodAggregateType<T extends AcademicPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicPeriod[P]>
      : GetScalarType<T[P], AggregateAcademicPeriod[P]>
  }




  export type AcademicPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPeriodWhereInput
    orderBy?: AcademicPeriodOrderByWithAggregationInput | AcademicPeriodOrderByWithAggregationInput[]
    by: AcademicPeriodScalarFieldEnum[] | AcademicPeriodScalarFieldEnum
    having?: AcademicPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicPeriodCountAggregateInputType | true
    _min?: AcademicPeriodMinAggregateInputType
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type AcademicPeriodGroupByOutputType = {
    id: string
    code: string
    title: string
    type: string
    startOn: Date
    endOn: Date
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  type GetAcademicPeriodGroupByPayload<T extends AcademicPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
        }
      >
    >


  export type AcademicPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | AcademicPeriod$sectionsArgs<ExtArgs>
    sectionRegistrations?: boolean | AcademicPeriod$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | AcademicPeriod$transcriptGradesArgs<ExtArgs>
    entryStudents?: boolean | AcademicPeriod$entryStudentsArgs<ExtArgs>
    credentialPeriods?: boolean | AcademicPeriod$credentialPeriodsArgs<ExtArgs>
    studentRisks?: boolean | AcademicPeriod$studentRisksArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "title" | "type" | "startOn" | "endOn" | "censusOn" | "registrationStartOn" | "registrationEndOn" | "academicYear" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["academicPeriod"]>
  export type AcademicPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicPeriod$sectionsArgs<ExtArgs>
    sectionRegistrations?: boolean | AcademicPeriod$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | AcademicPeriod$transcriptGradesArgs<ExtArgs>
    entryStudents?: boolean | AcademicPeriod$entryStudentsArgs<ExtArgs>
    credentialPeriods?: boolean | AcademicPeriod$credentialPeriodsArgs<ExtArgs>
    studentRisks?: boolean | AcademicPeriod$studentRisksArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AcademicPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicPeriod"
    objects: {
      sections: Prisma.$SectionPayload<ExtArgs>[]
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
      entryStudents: Prisma.$StudentPayload<ExtArgs>[]
      credentialPeriods: Prisma.$AcademicCredentialPayload<ExtArgs>[]
      studentRisks: Prisma.$StudentRiskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      type: string
      startOn: Date
      endOn: Date
      censusOn: Date | null
      registrationStartOn: Date | null
      registrationEndOn: Date | null
      academicYear: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicPeriod"]>
    composites: {}
  }

  type AcademicPeriodGetPayload<S extends boolean | null | undefined | AcademicPeriodDefaultArgs> = $Result.GetResult<Prisma.$AcademicPeriodPayload, S>

  type AcademicPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicPeriodCountAggregateInputType | true
    }

  export interface AcademicPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicPeriod'], meta: { name: 'AcademicPeriod' } }
    /**
     * Find zero or one AcademicPeriod that matches the filter.
     * @param {AcademicPeriodFindUniqueArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicPeriodFindUniqueArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicPeriodFindUniqueOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicPeriodFindFirstArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany()
     * 
     * // Get first 10 AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicPeriodFindManyArgs>(args?: SelectSubset<T, AcademicPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicPeriod.
     * @param {AcademicPeriodCreateArgs} args - Arguments to create a AcademicPeriod.
     * @example
     * // Create one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.create({
     *   data: {
     *     // ... data to create a AcademicPeriod
     *   }
     * })
     * 
     */
    create<T extends AcademicPeriodCreateArgs>(args: SelectSubset<T, AcademicPeriodCreateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicPeriods.
     * @param {AcademicPeriodCreateManyArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicPeriodCreateManyArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPeriods and returns the data saved in the database.
     * @param {AcademicPeriodCreateManyAndReturnArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPeriods and only return the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicPeriod.
     * @param {AcademicPeriodDeleteArgs} args - Arguments to delete one AcademicPeriod.
     * @example
     * // Delete one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.delete({
     *   where: {
     *     // ... filter to delete one AcademicPeriod
     *   }
     * })
     * 
     */
    delete<T extends AcademicPeriodDeleteArgs>(args: SelectSubset<T, AcademicPeriodDeleteArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicPeriod.
     * @param {AcademicPeriodUpdateArgs} args - Arguments to update one AcademicPeriod.
     * @example
     * // Update one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicPeriodUpdateArgs>(args: SelectSubset<T, AcademicPeriodUpdateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicPeriods.
     * @param {AcademicPeriodDeleteManyArgs} args - Arguments to filter AcademicPeriods to delete.
     * @example
     * // Delete a few AcademicPeriods
     * const { count } = await prisma.academicPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicPeriodDeleteManyArgs>(args?: SelectSubset<T, AcademicPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicPeriodUpdateManyArgs>(args: SelectSubset<T, AcademicPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPeriods and returns the data updated in the database.
     * @param {AcademicPeriodUpdateManyAndReturnArgs} args - Arguments to update many AcademicPeriods.
     * @example
     * // Update many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicPeriods and only return the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicPeriod.
     * @param {AcademicPeriodUpsertArgs} args - Arguments to update or create a AcademicPeriod.
     * @example
     * // Update or create a AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.upsert({
     *   create: {
     *     // ... data to create a AcademicPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicPeriod we want to update
     *   }
     * })
     */
    upsert<T extends AcademicPeriodUpsertArgs>(args: SelectSubset<T, AcademicPeriodUpsertArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodCountArgs} args - Arguments to filter AcademicPeriods to count.
     * @example
     * // Count the number of AcademicPeriods
     * const count = await prisma.academicPeriod.count({
     *   where: {
     *     // ... the filter for the AcademicPeriods we want to count
     *   }
     * })
    **/
    count<T extends AcademicPeriodCountArgs>(
      args?: Subset<T, AcademicPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicPeriodAggregateArgs>(args: Subset<T, AcademicPeriodAggregateArgs>): Prisma.PrismaPromise<GetAcademicPeriodAggregateType<T>>

    /**
     * Group by AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicPeriodGroupByArgs['orderBy'] }
        : { orderBy?: AcademicPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicPeriod model
   */
  readonly fields: AcademicPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends AcademicPeriod$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sectionRegistrations<T extends AcademicPeriod$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcriptGrades<T extends AcademicPeriod$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entryStudents<T extends AcademicPeriod$entryStudentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$entryStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credentialPeriods<T extends AcademicPeriod$credentialPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$credentialPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentRisks<T extends AcademicPeriod$studentRisksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$studentRisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicPeriod model
   */
  interface AcademicPeriodFieldRefs {
    readonly id: FieldRef<"AcademicPeriod", 'String'>
    readonly code: FieldRef<"AcademicPeriod", 'String'>
    readonly title: FieldRef<"AcademicPeriod", 'String'>
    readonly type: FieldRef<"AcademicPeriod", 'String'>
    readonly startOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly endOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly censusOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly registrationStartOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly registrationEndOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly academicYear: FieldRef<"AcademicPeriod", 'String'>
    readonly status: FieldRef<"AcademicPeriod", 'String'>
    readonly createdAt: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicPeriod findUnique
   */
  export type AcademicPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findUniqueOrThrow
   */
  export type AcademicPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findFirst
   */
  export type AcademicPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findFirstOrThrow
   */
  export type AcademicPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findMany
   */
  export type AcademicPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriods to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod create
   */
  export type AcademicPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicPeriod.
     */
    data: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
  }

  /**
   * AcademicPeriod createMany
   */
  export type AcademicPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPeriod createManyAndReturn
   */
  export type AcademicPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPeriod update
   */
  export type AcademicPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicPeriod.
     */
    data: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
    /**
     * Choose, which AcademicPeriod to update.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod updateMany
   */
  export type AcademicPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPeriods.
     */
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPeriods to update
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to update.
     */
    limit?: number
  }

  /**
   * AcademicPeriod updateManyAndReturn
   */
  export type AcademicPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * The data used to update AcademicPeriods.
     */
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPeriods to update
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to update.
     */
    limit?: number
  }

  /**
   * AcademicPeriod upsert
   */
  export type AcademicPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicPeriod to update in case it exists.
     */
    where: AcademicPeriodWhereUniqueInput
    /**
     * In case the AcademicPeriod found by the `where` argument doesn't exist, create a new AcademicPeriod with this data.
     */
    create: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
    /**
     * In case the AcademicPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
  }

  /**
   * AcademicPeriod delete
   */
  export type AcademicPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter which AcademicPeriod to delete.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod deleteMany
   */
  export type AcademicPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriods to delete
     */
    where?: AcademicPeriodWhereInput
    /**
     * Limit how many AcademicPeriods to delete.
     */
    limit?: number
  }

  /**
   * AcademicPeriod.sections
   */
  export type AcademicPeriod$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.sectionRegistrations
   */
  export type AcademicPeriod$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.transcriptGrades
   */
  export type AcademicPeriod$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.entryStudents
   */
  export type AcademicPeriod$entryStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.credentialPeriods
   */
  export type AcademicPeriod$credentialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.studentRisks
   */
  export type AcademicPeriod$studentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    cursor?: StudentRiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * AcademicPeriod without action
   */
  export type AcademicPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
  }

  export type CourseSumAggregateOutputType = {
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    subjectCode: string | null
    number: string | null
    title: string | null
    description: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
    courseLevel: string | null
    status: string | null
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    subjectCode: string | null
    number: string | null
    title: string | null
    description: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
    courseLevel: string | null
    status: string | null
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    subjectCode: number
    number: number
    title: number
    description: number
    creditType: number
    creditsMinimum: number
    creditsMaximum: number
    creditsIncrement: number
    courseLevel: number
    status: number
    effectiveStartDate: number
    effectiveEndDate: number
    catalogYear: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
  }

  export type CourseSumAggregateInputType = {
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    subjectCode: string
    number: string
    title: string
    description: string | null
    creditType: string
    creditsMinimum: Decimal
    creditsMaximum: Decimal
    creditsIncrement: Decimal | null
    courseLevel: string
    status: string
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    transcriptGrades?: boolean | Course$transcriptGradesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjectCode" | "number" | "title" | "description" | "creditType" | "creditsMinimum" | "creditsMaximum" | "creditsIncrement" | "courseLevel" | "status" | "effectiveStartDate" | "effectiveEndDate" | "catalogYear" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    transcriptGrades?: boolean | Course$transcriptGradesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      sections: Prisma.$SectionPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectCode: string
      number: string
      title: string
      description: string | null
      creditType: string
      creditsMinimum: Prisma.Decimal
      creditsMaximum: Prisma.Decimal
      creditsIncrement: Prisma.Decimal | null
      courseLevel: string
      status: string
      effectiveStartDate: Date | null
      effectiveEndDate: Date | null
      catalogYear: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends Course$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcriptGrades<T extends Course$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Course$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly subjectCode: FieldRef<"Course", 'String'>
    readonly number: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly creditType: FieldRef<"Course", 'String'>
    readonly creditsMinimum: FieldRef<"Course", 'Decimal'>
    readonly creditsMaximum: FieldRef<"Course", 'Decimal'>
    readonly creditsIncrement: FieldRef<"Course", 'Decimal'>
    readonly courseLevel: FieldRef<"Course", 'String'>
    readonly status: FieldRef<"Course", 'String'>
    readonly effectiveStartDate: FieldRef<"Course", 'DateTime'>
    readonly effectiveEndDate: FieldRef<"Course", 'DateTime'>
    readonly catalogYear: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.sections
   */
  export type Course$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Course.transcriptGrades
   */
  export type Course$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
  }

  export type SectionSumAggregateOutputType = {
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicPeriodId: string | null
    number: string | null
    title: string | null
    crn: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    instructorPersonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicPeriodId: string | null
    number: string | null
    title: string | null
    crn: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    instructorPersonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    courseId: number
    academicPeriodId: number
    number: number
    title: number
    crn: number
    startOn: number
    endOn: number
    status: number
    capacity: number
    enrolled: number
    available: number
    waitlistCapacity: number
    waitlistEnrolled: number
    instructionalMethodCode: number
    daysOfWeek: number
    startTime: number
    endTime: number
    building: number
    roomNumber: number
    creditType: number
    creditsMinimum: number
    creditsMaximum: number
    instructorPersonId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    creditsMinimum?: true
    creditsMaximum?: true
  }

  export type SectionSumAggregateInputType = {
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    creditsMinimum?: true
    creditsMaximum?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    daysOfWeek?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    courseId: string
    academicPeriodId: string
    number: string
    title: string | null
    crn: string
    startOn: Date
    endOn: Date
    status: string
    capacity: number
    enrolled: number
    available: number
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    daysOfWeek: string[]
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string
    creditsMinimum: Decimal
    creditsMaximum: Decimal
    instructorPersonId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
    sectionRegistrations?: boolean | Section$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | Section$transcriptGradesArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "academicPeriodId" | "number" | "title" | "crn" | "startOn" | "endOn" | "status" | "capacity" | "enrolled" | "available" | "waitlistCapacity" | "waitlistEnrolled" | "instructionalMethodCode" | "daysOfWeek" | "startTime" | "endTime" | "building" | "roomNumber" | "creditType" | "creditsMinimum" | "creditsMaximum" | "instructorPersonId" | "createdAt" | "updatedAt", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
    sectionRegistrations?: boolean | Section$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | Section$transcriptGradesArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      instructor: Prisma.$PersonPayload<ExtArgs> | null
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      academicPeriodId: string
      number: string
      title: string | null
      crn: string
      startOn: Date
      endOn: Date
      status: string
      capacity: number
      enrolled: number
      available: number
      waitlistCapacity: number | null
      waitlistEnrolled: number | null
      instructionalMethodCode: string | null
      daysOfWeek: string[]
      startTime: string | null
      endTime: string | null
      building: string | null
      roomNumber: string | null
      creditType: string
      creditsMinimum: Prisma.Decimal
      creditsMaximum: Prisma.Decimal
      instructorPersonId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instructor<T extends Section$instructorArgs<ExtArgs> = {}>(args?: Subset<T, Section$instructorArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sectionRegistrations<T extends Section$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Section$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcriptGrades<T extends Section$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Section$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly courseId: FieldRef<"Section", 'String'>
    readonly academicPeriodId: FieldRef<"Section", 'String'>
    readonly number: FieldRef<"Section", 'String'>
    readonly title: FieldRef<"Section", 'String'>
    readonly crn: FieldRef<"Section", 'String'>
    readonly startOn: FieldRef<"Section", 'DateTime'>
    readonly endOn: FieldRef<"Section", 'DateTime'>
    readonly status: FieldRef<"Section", 'String'>
    readonly capacity: FieldRef<"Section", 'Int'>
    readonly enrolled: FieldRef<"Section", 'Int'>
    readonly available: FieldRef<"Section", 'Int'>
    readonly waitlistCapacity: FieldRef<"Section", 'Int'>
    readonly waitlistEnrolled: FieldRef<"Section", 'Int'>
    readonly instructionalMethodCode: FieldRef<"Section", 'String'>
    readonly daysOfWeek: FieldRef<"Section", 'String[]'>
    readonly startTime: FieldRef<"Section", 'String'>
    readonly endTime: FieldRef<"Section", 'String'>
    readonly building: FieldRef<"Section", 'String'>
    readonly roomNumber: FieldRef<"Section", 'String'>
    readonly creditType: FieldRef<"Section", 'String'>
    readonly creditsMinimum: FieldRef<"Section", 'Decimal'>
    readonly creditsMaximum: FieldRef<"Section", 'Decimal'>
    readonly instructorPersonId: FieldRef<"Section", 'String'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.instructor
   */
  export type Section$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * Section.sectionRegistrations
   */
  export type Section$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * Section.transcriptGrades
   */
  export type Section$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model SectionRegistration
   */

  export type AggregateSectionRegistration = {
    _count: SectionRegistrationCountAggregateOutputType | null
    _avg: SectionRegistrationAvgAggregateOutputType | null
    _sum: SectionRegistrationSumAggregateOutputType | null
    _min: SectionRegistrationMinAggregateOutputType | null
    _max: SectionRegistrationMaxAggregateOutputType | null
  }

  export type SectionRegistrationAvgAggregateOutputType = {
    credits: Decimal | null
    attendanceRate: number | null
  }

  export type SectionRegistrationSumAggregateOutputType = {
    credits: Decimal | null
    attendanceRate: number | null
  }

  export type SectionRegistrationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    statusCode: string | null
    registrationDate: Date | null
    registeredOn: Date | null
    creditType: string | null
    credits: Decimal | null
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionRegistrationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    statusCode: string | null
    registrationDate: Date | null
    registeredOn: Date | null
    creditType: string | null
    credits: Decimal | null
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionRegistrationCountAggregateOutputType = {
    id: number
    studentId: number
    sectionId: number
    academicPeriodId: number
    statusCode: number
    registrationDate: number
    registeredOn: number
    creditType: number
    credits: number
    gradingOptionCode: number
    academicLoad: number
    residencyStatus: number
    attendanceRate: number
    midtermGrade: number
    finalGrade: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionRegistrationAvgAggregateInputType = {
    credits?: true
    attendanceRate?: true
  }

  export type SectionRegistrationSumAggregateInputType = {
    credits?: true
    attendanceRate?: true
  }

  export type SectionRegistrationMinAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionRegistrationMaxAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionRegistrationCountAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionRegistration to aggregate.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectionRegistrations
    **/
    _count?: true | SectionRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionRegistrationMaxAggregateInputType
  }

  export type GetSectionRegistrationAggregateType<T extends SectionRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSectionRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectionRegistration[P]>
      : GetScalarType<T[P], AggregateSectionRegistration[P]>
  }




  export type SectionRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithAggregationInput | SectionRegistrationOrderByWithAggregationInput[]
    by: SectionRegistrationScalarFieldEnum[] | SectionRegistrationScalarFieldEnum
    having?: SectionRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionRegistrationCountAggregateInputType | true
    _avg?: SectionRegistrationAvgAggregateInputType
    _sum?: SectionRegistrationSumAggregateInputType
    _min?: SectionRegistrationMinAggregateInputType
    _max?: SectionRegistrationMaxAggregateInputType
  }

  export type SectionRegistrationGroupByOutputType = {
    id: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date
    registeredOn: Date
    creditType: string
    credits: Decimal
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date
    updatedAt: Date
    _count: SectionRegistrationCountAggregateOutputType | null
    _avg: SectionRegistrationAvgAggregateOutputType | null
    _sum: SectionRegistrationSumAggregateOutputType | null
    _min: SectionRegistrationMinAggregateOutputType | null
    _max: SectionRegistrationMaxAggregateOutputType | null
  }

  type GetSectionRegistrationGroupByPayload<T extends SectionRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], SectionRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type SectionRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    transcriptGrade?: boolean | SectionRegistration$transcriptGradeArgs<ExtArgs>
  }, ExtArgs["result"]["sectionRegistration"]>

  export type SectionRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectionRegistration"]>

  export type SectionRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectionRegistration"]>

  export type SectionRegistrationSelectScalar = {
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "sectionId" | "academicPeriodId" | "statusCode" | "registrationDate" | "registeredOn" | "creditType" | "credits" | "gradingOptionCode" | "academicLoad" | "residencyStatus" | "attendanceRate" | "midtermGrade" | "finalGrade" | "createdAt" | "updatedAt", ExtArgs["result"]["sectionRegistration"]>
  export type SectionRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    transcriptGrade?: boolean | SectionRegistration$transcriptGradeArgs<ExtArgs>
  }
  export type SectionRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }
  export type SectionRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }

  export type $SectionRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectionRegistration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      transcriptGrade: Prisma.$StudentTranscriptGradePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sectionId: string
      academicPeriodId: string
      statusCode: string
      registrationDate: Date
      registeredOn: Date
      creditType: string
      credits: Prisma.Decimal
      gradingOptionCode: string | null
      academicLoad: string | null
      residencyStatus: string | null
      attendanceRate: number | null
      midtermGrade: string | null
      finalGrade: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sectionRegistration"]>
    composites: {}
  }

  type SectionRegistrationGetPayload<S extends boolean | null | undefined | SectionRegistrationDefaultArgs> = $Result.GetResult<Prisma.$SectionRegistrationPayload, S>

  type SectionRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionRegistrationCountAggregateInputType | true
    }

  export interface SectionRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionRegistration'], meta: { name: 'SectionRegistration' } }
    /**
     * Find zero or one SectionRegistration that matches the filter.
     * @param {SectionRegistrationFindUniqueArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionRegistrationFindUniqueArgs>(args: SelectSubset<T, SectionRegistrationFindUniqueArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SectionRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionRegistrationFindUniqueOrThrowArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindFirstArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionRegistrationFindFirstArgs>(args?: SelectSubset<T, SectionRegistrationFindFirstArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindFirstOrThrowArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SectionRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectionRegistrations
     * const sectionRegistrations = await prisma.sectionRegistration.findMany()
     * 
     * // Get first 10 SectionRegistrations
     * const sectionRegistrations = await prisma.sectionRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionRegistrationWithIdOnly = await prisma.sectionRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionRegistrationFindManyArgs>(args?: SelectSubset<T, SectionRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SectionRegistration.
     * @param {SectionRegistrationCreateArgs} args - Arguments to create a SectionRegistration.
     * @example
     * // Create one SectionRegistration
     * const SectionRegistration = await prisma.sectionRegistration.create({
     *   data: {
     *     // ... data to create a SectionRegistration
     *   }
     * })
     * 
     */
    create<T extends SectionRegistrationCreateArgs>(args: SelectSubset<T, SectionRegistrationCreateArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SectionRegistrations.
     * @param {SectionRegistrationCreateManyArgs} args - Arguments to create many SectionRegistrations.
     * @example
     * // Create many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionRegistrationCreateManyArgs>(args?: SelectSubset<T, SectionRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SectionRegistrations and returns the data saved in the database.
     * @param {SectionRegistrationCreateManyAndReturnArgs} args - Arguments to create many SectionRegistrations.
     * @example
     * // Create many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SectionRegistrations and only return the `id`
     * const sectionRegistrationWithIdOnly = await prisma.sectionRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SectionRegistration.
     * @param {SectionRegistrationDeleteArgs} args - Arguments to delete one SectionRegistration.
     * @example
     * // Delete one SectionRegistration
     * const SectionRegistration = await prisma.sectionRegistration.delete({
     *   where: {
     *     // ... filter to delete one SectionRegistration
     *   }
     * })
     * 
     */
    delete<T extends SectionRegistrationDeleteArgs>(args: SelectSubset<T, SectionRegistrationDeleteArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SectionRegistration.
     * @param {SectionRegistrationUpdateArgs} args - Arguments to update one SectionRegistration.
     * @example
     * // Update one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionRegistrationUpdateArgs>(args: SelectSubset<T, SectionRegistrationUpdateArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SectionRegistrations.
     * @param {SectionRegistrationDeleteManyArgs} args - Arguments to filter SectionRegistrations to delete.
     * @example
     * // Delete a few SectionRegistrations
     * const { count } = await prisma.sectionRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionRegistrationDeleteManyArgs>(args?: SelectSubset<T, SectionRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionRegistrationUpdateManyArgs>(args: SelectSubset<T, SectionRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionRegistrations and returns the data updated in the database.
     * @param {SectionRegistrationUpdateManyAndReturnArgs} args - Arguments to update many SectionRegistrations.
     * @example
     * // Update many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SectionRegistrations and only return the `id`
     * const sectionRegistrationWithIdOnly = await prisma.sectionRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SectionRegistration.
     * @param {SectionRegistrationUpsertArgs} args - Arguments to update or create a SectionRegistration.
     * @example
     * // Update or create a SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.upsert({
     *   create: {
     *     // ... data to create a SectionRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectionRegistration we want to update
     *   }
     * })
     */
    upsert<T extends SectionRegistrationUpsertArgs>(args: SelectSubset<T, SectionRegistrationUpsertArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SectionRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationCountArgs} args - Arguments to filter SectionRegistrations to count.
     * @example
     * // Count the number of SectionRegistrations
     * const count = await prisma.sectionRegistration.count({
     *   where: {
     *     // ... the filter for the SectionRegistrations we want to count
     *   }
     * })
    **/
    count<T extends SectionRegistrationCountArgs>(
      args?: Subset<T, SectionRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectionRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionRegistrationAggregateArgs>(args: Subset<T, SectionRegistrationAggregateArgs>): Prisma.PrismaPromise<GetSectionRegistrationAggregateType<T>>

    /**
     * Group by SectionRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: SectionRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectionRegistration model
   */
  readonly fields: SectionRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectionRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transcriptGrade<T extends SectionRegistration$transcriptGradeArgs<ExtArgs> = {}>(args?: Subset<T, SectionRegistration$transcriptGradeArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectionRegistration model
   */
  interface SectionRegistrationFieldRefs {
    readonly id: FieldRef<"SectionRegistration", 'String'>
    readonly studentId: FieldRef<"SectionRegistration", 'String'>
    readonly sectionId: FieldRef<"SectionRegistration", 'String'>
    readonly academicPeriodId: FieldRef<"SectionRegistration", 'String'>
    readonly statusCode: FieldRef<"SectionRegistration", 'String'>
    readonly registrationDate: FieldRef<"SectionRegistration", 'DateTime'>
    readonly registeredOn: FieldRef<"SectionRegistration", 'DateTime'>
    readonly creditType: FieldRef<"SectionRegistration", 'String'>
    readonly credits: FieldRef<"SectionRegistration", 'Decimal'>
    readonly gradingOptionCode: FieldRef<"SectionRegistration", 'String'>
    readonly academicLoad: FieldRef<"SectionRegistration", 'String'>
    readonly residencyStatus: FieldRef<"SectionRegistration", 'String'>
    readonly attendanceRate: FieldRef<"SectionRegistration", 'Float'>
    readonly midtermGrade: FieldRef<"SectionRegistration", 'String'>
    readonly finalGrade: FieldRef<"SectionRegistration", 'String'>
    readonly createdAt: FieldRef<"SectionRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"SectionRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SectionRegistration findUnique
   */
  export type SectionRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration findUniqueOrThrow
   */
  export type SectionRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration findFirst
   */
  export type SectionRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionRegistrations.
     */
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration findFirstOrThrow
   */
  export type SectionRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionRegistrations.
     */
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration findMany
   */
  export type SectionRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistrations to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration create
   */
  export type SectionRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a SectionRegistration.
     */
    data: XOR<SectionRegistrationCreateInput, SectionRegistrationUncheckedCreateInput>
  }

  /**
   * SectionRegistration createMany
   */
  export type SectionRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectionRegistrations.
     */
    data: SectionRegistrationCreateManyInput | SectionRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectionRegistration createManyAndReturn
   */
  export type SectionRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many SectionRegistrations.
     */
    data: SectionRegistrationCreateManyInput | SectionRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SectionRegistration update
   */
  export type SectionRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a SectionRegistration.
     */
    data: XOR<SectionRegistrationUpdateInput, SectionRegistrationUncheckedUpdateInput>
    /**
     * Choose, which SectionRegistration to update.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration updateMany
   */
  export type SectionRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectionRegistrations.
     */
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SectionRegistrations to update
     */
    where?: SectionRegistrationWhereInput
    /**
     * Limit how many SectionRegistrations to update.
     */
    limit?: number
  }

  /**
   * SectionRegistration updateManyAndReturn
   */
  export type SectionRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update SectionRegistrations.
     */
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SectionRegistrations to update
     */
    where?: SectionRegistrationWhereInput
    /**
     * Limit how many SectionRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SectionRegistration upsert
   */
  export type SectionRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the SectionRegistration to update in case it exists.
     */
    where: SectionRegistrationWhereUniqueInput
    /**
     * In case the SectionRegistration found by the `where` argument doesn't exist, create a new SectionRegistration with this data.
     */
    create: XOR<SectionRegistrationCreateInput, SectionRegistrationUncheckedCreateInput>
    /**
     * In case the SectionRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionRegistrationUpdateInput, SectionRegistrationUncheckedUpdateInput>
  }

  /**
   * SectionRegistration delete
   */
  export type SectionRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter which SectionRegistration to delete.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration deleteMany
   */
  export type SectionRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionRegistrations to delete
     */
    where?: SectionRegistrationWhereInput
    /**
     * Limit how many SectionRegistrations to delete.
     */
    limit?: number
  }

  /**
   * SectionRegistration.transcriptGrade
   */
  export type SectionRegistration$transcriptGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * SectionRegistration without action
   */
  export type SectionRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionRegistration
     */
    omit?: SectionRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model StudentTranscriptGrade
   */

  export type AggregateStudentTranscriptGrade = {
    _count: StudentTranscriptGradeCountAggregateOutputType | null
    _avg: StudentTranscriptGradeAvgAggregateOutputType | null
    _sum: StudentTranscriptGradeSumAggregateOutputType | null
    _min: StudentTranscriptGradeMinAggregateOutputType | null
    _max: StudentTranscriptGradeMaxAggregateOutputType | null
  }

  export type StudentTranscriptGradeAvgAggregateOutputType = {
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
  }

  export type StudentTranscriptGradeSumAggregateOutputType = {
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
  }

  export type StudentTranscriptGradeMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionRegistrationId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    courseId: string | null
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
    finalGradeDate: Date | null
    status: string | null
    incomplete: boolean | null
    repeat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTranscriptGradeMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionRegistrationId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    courseId: string | null
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
    finalGradeDate: Date | null
    status: string | null
    incomplete: boolean | null
    repeat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTranscriptGradeCountAggregateOutputType = {
    id: number
    studentId: number
    sectionRegistrationId: number
    sectionId: number
    academicPeriodId: number
    courseId: number
    gradeSchemeCode: number
    gradeValue: number
    gradePoints: number
    qualityPoints: number
    creditsAttempted: number
    creditsEarned: number
    finalGradeDate: number
    status: number
    incomplete: number
    repeat: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentTranscriptGradeAvgAggregateInputType = {
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
  }

  export type StudentTranscriptGradeSumAggregateInputType = {
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
  }

  export type StudentTranscriptGradeMinAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTranscriptGradeMaxAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTranscriptGradeCountAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentTranscriptGradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTranscriptGrade to aggregate.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTranscriptGrades
    **/
    _count?: true | StudentTranscriptGradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTranscriptGradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTranscriptGradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTranscriptGradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTranscriptGradeMaxAggregateInputType
  }

  export type GetStudentTranscriptGradeAggregateType<T extends StudentTranscriptGradeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTranscriptGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTranscriptGrade[P]>
      : GetScalarType<T[P], AggregateStudentTranscriptGrade[P]>
  }




  export type StudentTranscriptGradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithAggregationInput | StudentTranscriptGradeOrderByWithAggregationInput[]
    by: StudentTranscriptGradeScalarFieldEnum[] | StudentTranscriptGradeScalarFieldEnum
    having?: StudentTranscriptGradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTranscriptGradeCountAggregateInputType | true
    _avg?: StudentTranscriptGradeAvgAggregateInputType
    _sum?: StudentTranscriptGradeSumAggregateInputType
    _min?: StudentTranscriptGradeMinAggregateInputType
    _max?: StudentTranscriptGradeMaxAggregateInputType
  }

  export type StudentTranscriptGradeGroupByOutputType = {
    id: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal
    creditsEarned: Decimal
    finalGradeDate: Date | null
    status: string
    incomplete: boolean
    repeat: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentTranscriptGradeCountAggregateOutputType | null
    _avg: StudentTranscriptGradeAvgAggregateOutputType | null
    _sum: StudentTranscriptGradeSumAggregateOutputType | null
    _min: StudentTranscriptGradeMinAggregateOutputType | null
    _max: StudentTranscriptGradeMaxAggregateOutputType | null
  }

  type GetStudentTranscriptGradeGroupByPayload<T extends StudentTranscriptGradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTranscriptGradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTranscriptGradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTranscriptGradeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTranscriptGradeGroupByOutputType[P]>
        }
      >
    >


  export type StudentTranscriptGradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTranscriptGrade"]>

  export type StudentTranscriptGradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTranscriptGrade"]>

  export type StudentTranscriptGradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTranscriptGrade"]>

  export type StudentTranscriptGradeSelectScalar = {
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentTranscriptGradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "sectionRegistrationId" | "sectionId" | "academicPeriodId" | "courseId" | "gradeSchemeCode" | "gradeValue" | "gradePoints" | "qualityPoints" | "creditsAttempted" | "creditsEarned" | "finalGradeDate" | "status" | "incomplete" | "repeat" | "createdAt" | "updatedAt", ExtArgs["result"]["studentTranscriptGrade"]>
  export type StudentTranscriptGradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type StudentTranscriptGradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type StudentTranscriptGradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $StudentTranscriptGradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTranscriptGrade"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      sectionRegistration: Prisma.$SectionRegistrationPayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sectionRegistrationId: string
      sectionId: string
      academicPeriodId: string
      courseId: string
      gradeSchemeCode: string | null
      gradeValue: string | null
      gradePoints: Prisma.Decimal | null
      qualityPoints: Prisma.Decimal | null
      creditsAttempted: Prisma.Decimal
      creditsEarned: Prisma.Decimal
      finalGradeDate: Date | null
      status: string
      incomplete: boolean
      repeat: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentTranscriptGrade"]>
    composites: {}
  }

  type StudentTranscriptGradeGetPayload<S extends boolean | null | undefined | StudentTranscriptGradeDefaultArgs> = $Result.GetResult<Prisma.$StudentTranscriptGradePayload, S>

  type StudentTranscriptGradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentTranscriptGradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentTranscriptGradeCountAggregateInputType | true
    }

  export interface StudentTranscriptGradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTranscriptGrade'], meta: { name: 'StudentTranscriptGrade' } }
    /**
     * Find zero or one StudentTranscriptGrade that matches the filter.
     * @param {StudentTranscriptGradeFindUniqueArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTranscriptGradeFindUniqueArgs>(args: SelectSubset<T, StudentTranscriptGradeFindUniqueArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentTranscriptGrade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentTranscriptGradeFindUniqueOrThrowArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTranscriptGradeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTranscriptGrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindFirstArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTranscriptGradeFindFirstArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindFirstArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTranscriptGrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindFirstOrThrowArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTranscriptGradeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentTranscriptGrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTranscriptGrades
     * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany()
     * 
     * // Get first 10 StudentTranscriptGrades
     * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTranscriptGradeWithIdOnly = await prisma.studentTranscriptGrade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTranscriptGradeFindManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentTranscriptGrade.
     * @param {StudentTranscriptGradeCreateArgs} args - Arguments to create a StudentTranscriptGrade.
     * @example
     * // Create one StudentTranscriptGrade
     * const StudentTranscriptGrade = await prisma.studentTranscriptGrade.create({
     *   data: {
     *     // ... data to create a StudentTranscriptGrade
     *   }
     * })
     * 
     */
    create<T extends StudentTranscriptGradeCreateArgs>(args: SelectSubset<T, StudentTranscriptGradeCreateArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentTranscriptGrades.
     * @param {StudentTranscriptGradeCreateManyArgs} args - Arguments to create many StudentTranscriptGrades.
     * @example
     * // Create many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTranscriptGradeCreateManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTranscriptGrades and returns the data saved in the database.
     * @param {StudentTranscriptGradeCreateManyAndReturnArgs} args - Arguments to create many StudentTranscriptGrades.
     * @example
     * // Create many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTranscriptGrades and only return the `id`
     * const studentTranscriptGradeWithIdOnly = await prisma.studentTranscriptGrade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTranscriptGradeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentTranscriptGrade.
     * @param {StudentTranscriptGradeDeleteArgs} args - Arguments to delete one StudentTranscriptGrade.
     * @example
     * // Delete one StudentTranscriptGrade
     * const StudentTranscriptGrade = await prisma.studentTranscriptGrade.delete({
     *   where: {
     *     // ... filter to delete one StudentTranscriptGrade
     *   }
     * })
     * 
     */
    delete<T extends StudentTranscriptGradeDeleteArgs>(args: SelectSubset<T, StudentTranscriptGradeDeleteArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentTranscriptGrade.
     * @param {StudentTranscriptGradeUpdateArgs} args - Arguments to update one StudentTranscriptGrade.
     * @example
     * // Update one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTranscriptGradeUpdateArgs>(args: SelectSubset<T, StudentTranscriptGradeUpdateArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentTranscriptGrades.
     * @param {StudentTranscriptGradeDeleteManyArgs} args - Arguments to filter StudentTranscriptGrades to delete.
     * @example
     * // Delete a few StudentTranscriptGrades
     * const { count } = await prisma.studentTranscriptGrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTranscriptGradeDeleteManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTranscriptGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTranscriptGradeUpdateManyArgs>(args: SelectSubset<T, StudentTranscriptGradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTranscriptGrades and returns the data updated in the database.
     * @param {StudentTranscriptGradeUpdateManyAndReturnArgs} args - Arguments to update many StudentTranscriptGrades.
     * @example
     * // Update many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentTranscriptGrades and only return the `id`
     * const studentTranscriptGradeWithIdOnly = await prisma.studentTranscriptGrade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentTranscriptGradeUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentTranscriptGradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentTranscriptGrade.
     * @param {StudentTranscriptGradeUpsertArgs} args - Arguments to update or create a StudentTranscriptGrade.
     * @example
     * // Update or create a StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.upsert({
     *   create: {
     *     // ... data to create a StudentTranscriptGrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTranscriptGrade we want to update
     *   }
     * })
     */
    upsert<T extends StudentTranscriptGradeUpsertArgs>(args: SelectSubset<T, StudentTranscriptGradeUpsertArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentTranscriptGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeCountArgs} args - Arguments to filter StudentTranscriptGrades to count.
     * @example
     * // Count the number of StudentTranscriptGrades
     * const count = await prisma.studentTranscriptGrade.count({
     *   where: {
     *     // ... the filter for the StudentTranscriptGrades we want to count
     *   }
     * })
    **/
    count<T extends StudentTranscriptGradeCountArgs>(
      args?: Subset<T, StudentTranscriptGradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTranscriptGradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTranscriptGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTranscriptGradeAggregateArgs>(args: Subset<T, StudentTranscriptGradeAggregateArgs>): Prisma.PrismaPromise<GetStudentTranscriptGradeAggregateType<T>>

    /**
     * Group by StudentTranscriptGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTranscriptGradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTranscriptGradeGroupByArgs['orderBy'] }
        : { orderBy?: StudentTranscriptGradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTranscriptGradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTranscriptGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTranscriptGrade model
   */
  readonly fields: StudentTranscriptGradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTranscriptGrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTranscriptGradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sectionRegistration<T extends SectionRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionRegistrationDefaultArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTranscriptGrade model
   */
  interface StudentTranscriptGradeFieldRefs {
    readonly id: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly studentId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly sectionRegistrationId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly sectionId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly academicPeriodId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly courseId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradeSchemeCode: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradeValue: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradePoints: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly qualityPoints: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly creditsAttempted: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly creditsEarned: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly finalGradeDate: FieldRef<"StudentTranscriptGrade", 'DateTime'>
    readonly status: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly incomplete: FieldRef<"StudentTranscriptGrade", 'Boolean'>
    readonly repeat: FieldRef<"StudentTranscriptGrade", 'Boolean'>
    readonly createdAt: FieldRef<"StudentTranscriptGrade", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentTranscriptGrade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentTranscriptGrade findUnique
   */
  export type StudentTranscriptGradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade findUniqueOrThrow
   */
  export type StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade findFirst
   */
  export type StudentTranscriptGradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTranscriptGrades.
     */
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade findFirstOrThrow
   */
  export type StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTranscriptGrades.
     */
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade findMany
   */
  export type StudentTranscriptGradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrades to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade create
   */
  export type StudentTranscriptGradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTranscriptGrade.
     */
    data: XOR<StudentTranscriptGradeCreateInput, StudentTranscriptGradeUncheckedCreateInput>
  }

  /**
   * StudentTranscriptGrade createMany
   */
  export type StudentTranscriptGradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTranscriptGrades.
     */
    data: StudentTranscriptGradeCreateManyInput | StudentTranscriptGradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTranscriptGrade createManyAndReturn
   */
  export type StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * The data used to create many StudentTranscriptGrades.
     */
    data: StudentTranscriptGradeCreateManyInput | StudentTranscriptGradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTranscriptGrade update
   */
  export type StudentTranscriptGradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTranscriptGrade.
     */
    data: XOR<StudentTranscriptGradeUpdateInput, StudentTranscriptGradeUncheckedUpdateInput>
    /**
     * Choose, which StudentTranscriptGrade to update.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade updateMany
   */
  export type StudentTranscriptGradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTranscriptGrades.
     */
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyInput>
    /**
     * Filter which StudentTranscriptGrades to update
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * Limit how many StudentTranscriptGrades to update.
     */
    limit?: number
  }

  /**
   * StudentTranscriptGrade updateManyAndReturn
   */
  export type StudentTranscriptGradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * The data used to update StudentTranscriptGrades.
     */
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyInput>
    /**
     * Filter which StudentTranscriptGrades to update
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * Limit how many StudentTranscriptGrades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTranscriptGrade upsert
   */
  export type StudentTranscriptGradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTranscriptGrade to update in case it exists.
     */
    where: StudentTranscriptGradeWhereUniqueInput
    /**
     * In case the StudentTranscriptGrade found by the `where` argument doesn't exist, create a new StudentTranscriptGrade with this data.
     */
    create: XOR<StudentTranscriptGradeCreateInput, StudentTranscriptGradeUncheckedCreateInput>
    /**
     * In case the StudentTranscriptGrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTranscriptGradeUpdateInput, StudentTranscriptGradeUncheckedUpdateInput>
  }

  /**
   * StudentTranscriptGrade delete
   */
  export type StudentTranscriptGradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter which StudentTranscriptGrade to delete.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade deleteMany
   */
  export type StudentTranscriptGradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTranscriptGrades to delete
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * Limit how many StudentTranscriptGrades to delete.
     */
    limit?: number
  }

  /**
   * StudentTranscriptGrade without action
   */
  export type StudentTranscriptGradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTranscriptGrade
     */
    omit?: StudentTranscriptGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
  }


  /**
   * Model AcademicProgram
   */

  export type AggregateAcademicProgram = {
    _count: AcademicProgramCountAggregateOutputType | null
    _avg: AcademicProgramAvgAggregateOutputType | null
    _sum: AcademicProgramSumAggregateOutputType | null
    _min: AcademicProgramMinAggregateOutputType | null
    _max: AcademicProgramMaxAggregateOutputType | null
  }

  export type AcademicProgramAvgAggregateOutputType = {
    creditsRequired: number | null
  }

  export type AcademicProgramSumAggregateOutputType = {
    creditsRequired: number | null
  }

  export type AcademicProgramMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    level: string | null
    degreeCode: string | null
    status: string | null
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicProgramMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    level: string | null
    degreeCode: string | null
    status: string | null
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicProgramCountAggregateOutputType = {
    id: number
    code: number
    title: number
    type: number
    level: number
    degreeCode: number
    status: number
    startOn: number
    endOn: number
    accreditationCode: number
    creditsRequired: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicProgramAvgAggregateInputType = {
    creditsRequired?: true
  }

  export type AcademicProgramSumAggregateInputType = {
    creditsRequired?: true
  }

  export type AcademicProgramMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicProgramMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicProgramCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicProgram to aggregate.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPrograms
    **/
    _count?: true | AcademicProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicProgramMaxAggregateInputType
  }

  export type GetAcademicProgramAggregateType<T extends AcademicProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicProgram[P]>
      : GetScalarType<T[P], AggregateAcademicProgram[P]>
  }




  export type AcademicProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicProgramWhereInput
    orderBy?: AcademicProgramOrderByWithAggregationInput | AcademicProgramOrderByWithAggregationInput[]
    by: AcademicProgramScalarFieldEnum[] | AcademicProgramScalarFieldEnum
    having?: AcademicProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicProgramCountAggregateInputType | true
    _avg?: AcademicProgramAvgAggregateInputType
    _sum?: AcademicProgramSumAggregateInputType
    _min?: AcademicProgramMinAggregateInputType
    _max?: AcademicProgramMaxAggregateInputType
  }

  export type AcademicProgramGroupByOutputType = {
    id: string
    code: string
    title: string
    type: string
    level: string
    degreeCode: string | null
    status: string
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AcademicProgramCountAggregateOutputType | null
    _avg: AcademicProgramAvgAggregateOutputType | null
    _sum: AcademicProgramSumAggregateOutputType | null
    _min: AcademicProgramMinAggregateOutputType | null
    _max: AcademicProgramMaxAggregateOutputType | null
  }

  type GetAcademicProgramGroupByPayload<T extends AcademicProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicProgramGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicProgramGroupByOutputType[P]>
        }
      >
    >


  export type AcademicProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentPrograms?: boolean | AcademicProgram$studentProgramsArgs<ExtArgs>
    credentials?: boolean | AcademicProgram$credentialsArgs<ExtArgs>
    _count?: boolean | AcademicProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicProgram"]>

  export type AcademicProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicProgram"]>

  export type AcademicProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicProgram"]>

  export type AcademicProgramSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "title" | "type" | "level" | "degreeCode" | "status" | "startOn" | "endOn" | "accreditationCode" | "creditsRequired" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["academicProgram"]>
  export type AcademicProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPrograms?: boolean | AcademicProgram$studentProgramsArgs<ExtArgs>
    credentials?: boolean | AcademicProgram$credentialsArgs<ExtArgs>
    _count?: boolean | AcademicProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AcademicProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicProgram"
    objects: {
      studentPrograms: Prisma.$StudentAcademicProgramPayload<ExtArgs>[]
      credentials: Prisma.$AcademicCredentialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      type: string
      level: string
      degreeCode: string | null
      status: string
      startOn: Date | null
      endOn: Date | null
      accreditationCode: string | null
      creditsRequired: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicProgram"]>
    composites: {}
  }

  type AcademicProgramGetPayload<S extends boolean | null | undefined | AcademicProgramDefaultArgs> = $Result.GetResult<Prisma.$AcademicProgramPayload, S>

  type AcademicProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicProgramCountAggregateInputType | true
    }

  export interface AcademicProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicProgram'], meta: { name: 'AcademicProgram' } }
    /**
     * Find zero or one AcademicProgram that matches the filter.
     * @param {AcademicProgramFindUniqueArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicProgramFindUniqueArgs>(args: SelectSubset<T, AcademicProgramFindUniqueArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicProgramFindUniqueOrThrowArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindFirstArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicProgramFindFirstArgs>(args?: SelectSubset<T, AcademicProgramFindFirstArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindFirstOrThrowArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPrograms
     * const academicPrograms = await prisma.academicProgram.findMany()
     * 
     * // Get first 10 AcademicPrograms
     * const academicPrograms = await prisma.academicProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicProgramWithIdOnly = await prisma.academicProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicProgramFindManyArgs>(args?: SelectSubset<T, AcademicProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicProgram.
     * @param {AcademicProgramCreateArgs} args - Arguments to create a AcademicProgram.
     * @example
     * // Create one AcademicProgram
     * const AcademicProgram = await prisma.academicProgram.create({
     *   data: {
     *     // ... data to create a AcademicProgram
     *   }
     * })
     * 
     */
    create<T extends AcademicProgramCreateArgs>(args: SelectSubset<T, AcademicProgramCreateArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicPrograms.
     * @param {AcademicProgramCreateManyArgs} args - Arguments to create many AcademicPrograms.
     * @example
     * // Create many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicProgramCreateManyArgs>(args?: SelectSubset<T, AcademicProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPrograms and returns the data saved in the database.
     * @param {AcademicProgramCreateManyAndReturnArgs} args - Arguments to create many AcademicPrograms.
     * @example
     * // Create many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPrograms and only return the `id`
     * const academicProgramWithIdOnly = await prisma.academicProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicProgram.
     * @param {AcademicProgramDeleteArgs} args - Arguments to delete one AcademicProgram.
     * @example
     * // Delete one AcademicProgram
     * const AcademicProgram = await prisma.academicProgram.delete({
     *   where: {
     *     // ... filter to delete one AcademicProgram
     *   }
     * })
     * 
     */
    delete<T extends AcademicProgramDeleteArgs>(args: SelectSubset<T, AcademicProgramDeleteArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicProgram.
     * @param {AcademicProgramUpdateArgs} args - Arguments to update one AcademicProgram.
     * @example
     * // Update one AcademicProgram
     * const academicProgram = await prisma.academicProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicProgramUpdateArgs>(args: SelectSubset<T, AcademicProgramUpdateArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicPrograms.
     * @param {AcademicProgramDeleteManyArgs} args - Arguments to filter AcademicPrograms to delete.
     * @example
     * // Delete a few AcademicPrograms
     * const { count } = await prisma.academicProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicProgramDeleteManyArgs>(args?: SelectSubset<T, AcademicProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicProgramUpdateManyArgs>(args: SelectSubset<T, AcademicProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPrograms and returns the data updated in the database.
     * @param {AcademicProgramUpdateManyAndReturnArgs} args - Arguments to update many AcademicPrograms.
     * @example
     * // Update many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicPrograms and only return the `id`
     * const academicProgramWithIdOnly = await prisma.academicProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicProgram.
     * @param {AcademicProgramUpsertArgs} args - Arguments to update or create a AcademicProgram.
     * @example
     * // Update or create a AcademicProgram
     * const academicProgram = await prisma.academicProgram.upsert({
     *   create: {
     *     // ... data to create a AcademicProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicProgram we want to update
     *   }
     * })
     */
    upsert<T extends AcademicProgramUpsertArgs>(args: SelectSubset<T, AcademicProgramUpsertArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramCountArgs} args - Arguments to filter AcademicPrograms to count.
     * @example
     * // Count the number of AcademicPrograms
     * const count = await prisma.academicProgram.count({
     *   where: {
     *     // ... the filter for the AcademicPrograms we want to count
     *   }
     * })
    **/
    count<T extends AcademicProgramCountArgs>(
      args?: Subset<T, AcademicProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicProgramAggregateArgs>(args: Subset<T, AcademicProgramAggregateArgs>): Prisma.PrismaPromise<GetAcademicProgramAggregateType<T>>

    /**
     * Group by AcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicProgramGroupByArgs['orderBy'] }
        : { orderBy?: AcademicProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicProgram model
   */
  readonly fields: AcademicProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentPrograms<T extends AcademicProgram$studentProgramsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgram$studentProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credentials<T extends AcademicProgram$credentialsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgram$credentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicProgram model
   */
  interface AcademicProgramFieldRefs {
    readonly id: FieldRef<"AcademicProgram", 'String'>
    readonly code: FieldRef<"AcademicProgram", 'String'>
    readonly title: FieldRef<"AcademicProgram", 'String'>
    readonly type: FieldRef<"AcademicProgram", 'String'>
    readonly level: FieldRef<"AcademicProgram", 'String'>
    readonly degreeCode: FieldRef<"AcademicProgram", 'String'>
    readonly status: FieldRef<"AcademicProgram", 'String'>
    readonly startOn: FieldRef<"AcademicProgram", 'DateTime'>
    readonly endOn: FieldRef<"AcademicProgram", 'DateTime'>
    readonly accreditationCode: FieldRef<"AcademicProgram", 'String'>
    readonly creditsRequired: FieldRef<"AcademicProgram", 'Int'>
    readonly description: FieldRef<"AcademicProgram", 'String'>
    readonly createdAt: FieldRef<"AcademicProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicProgram findUnique
   */
  export type AcademicProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram findUniqueOrThrow
   */
  export type AcademicProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram findFirst
   */
  export type AcademicProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPrograms.
     */
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram findFirstOrThrow
   */
  export type AcademicProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPrograms.
     */
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram findMany
   */
  export type AcademicProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPrograms to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram create
   */
  export type AcademicProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicProgram.
     */
    data: XOR<AcademicProgramCreateInput, AcademicProgramUncheckedCreateInput>
  }

  /**
   * AcademicProgram createMany
   */
  export type AcademicProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPrograms.
     */
    data: AcademicProgramCreateManyInput | AcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicProgram createManyAndReturn
   */
  export type AcademicProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicPrograms.
     */
    data: AcademicProgramCreateManyInput | AcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicProgram update
   */
  export type AcademicProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicProgram.
     */
    data: XOR<AcademicProgramUpdateInput, AcademicProgramUncheckedUpdateInput>
    /**
     * Choose, which AcademicProgram to update.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram updateMany
   */
  export type AcademicProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPrograms.
     */
    data: XOR<AcademicProgramUpdateManyMutationInput, AcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPrograms to update
     */
    where?: AcademicProgramWhereInput
    /**
     * Limit how many AcademicPrograms to update.
     */
    limit?: number
  }

  /**
   * AcademicProgram updateManyAndReturn
   */
  export type AcademicProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * The data used to update AcademicPrograms.
     */
    data: XOR<AcademicProgramUpdateManyMutationInput, AcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPrograms to update
     */
    where?: AcademicProgramWhereInput
    /**
     * Limit how many AcademicPrograms to update.
     */
    limit?: number
  }

  /**
   * AcademicProgram upsert
   */
  export type AcademicProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicProgram to update in case it exists.
     */
    where: AcademicProgramWhereUniqueInput
    /**
     * In case the AcademicProgram found by the `where` argument doesn't exist, create a new AcademicProgram with this data.
     */
    create: XOR<AcademicProgramCreateInput, AcademicProgramUncheckedCreateInput>
    /**
     * In case the AcademicProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicProgramUpdateInput, AcademicProgramUncheckedUpdateInput>
  }

  /**
   * AcademicProgram delete
   */
  export type AcademicProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter which AcademicProgram to delete.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram deleteMany
   */
  export type AcademicProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPrograms to delete
     */
    where?: AcademicProgramWhereInput
    /**
     * Limit how many AcademicPrograms to delete.
     */
    limit?: number
  }

  /**
   * AcademicProgram.studentPrograms
   */
  export type AcademicProgram$studentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    cursor?: StudentAcademicProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram.credentials
   */
  export type AcademicProgram$credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicProgram without action
   */
  export type AcademicProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
  }


  /**
   * Model StudentAcademicProgram
   */

  export type AggregateStudentAcademicProgram = {
    _count: StudentAcademicProgramCountAggregateOutputType | null
    _min: StudentAcademicProgramMinAggregateOutputType | null
    _max: StudentAcademicProgramMaxAggregateOutputType | null
  }

  export type StudentAcademicProgramMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicProgramId: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    catalogYear: string | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAcademicProgramMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicProgramId: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    catalogYear: string | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAcademicProgramCountAggregateOutputType = {
    id: number
    studentId: number
    academicProgramId: number
    startOn: number
    endOn: number
    status: number
    catalogYear: number
    primary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAcademicProgramMinAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAcademicProgramMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAcademicProgramCountAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAcademicProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicProgram to aggregate.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAcademicPrograms
    **/
    _count?: true | StudentAcademicProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAcademicProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAcademicProgramMaxAggregateInputType
  }

  export type GetStudentAcademicProgramAggregateType<T extends StudentAcademicProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAcademicProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAcademicProgram[P]>
      : GetScalarType<T[P], AggregateStudentAcademicProgram[P]>
  }




  export type StudentAcademicProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithAggregationInput | StudentAcademicProgramOrderByWithAggregationInput[]
    by: StudentAcademicProgramScalarFieldEnum[] | StudentAcademicProgramScalarFieldEnum
    having?: StudentAcademicProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAcademicProgramCountAggregateInputType | true
    _min?: StudentAcademicProgramMinAggregateInputType
    _max?: StudentAcademicProgramMaxAggregateInputType
  }

  export type StudentAcademicProgramGroupByOutputType = {
    id: string
    studentId: string
    academicProgramId: string
    startOn: Date
    endOn: Date | null
    status: string
    catalogYear: string | null
    primary: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentAcademicProgramCountAggregateOutputType | null
    _min: StudentAcademicProgramMinAggregateOutputType | null
    _max: StudentAcademicProgramMaxAggregateOutputType | null
  }

  type GetStudentAcademicProgramGroupByPayload<T extends StudentAcademicProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAcademicProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAcademicProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAcademicProgramGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAcademicProgramGroupByOutputType[P]>
        }
      >
    >


  export type StudentAcademicProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicProgram"]>

  export type StudentAcademicProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicProgram"]>

  export type StudentAcademicProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicProgram"]>

  export type StudentAcademicProgramSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAcademicProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "academicProgramId" | "startOn" | "endOn" | "status" | "catalogYear" | "primary" | "createdAt" | "updatedAt", ExtArgs["result"]["studentAcademicProgram"]>
  export type StudentAcademicProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }
  export type StudentAcademicProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }
  export type StudentAcademicProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }

  export type $StudentAcademicProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAcademicProgram"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicProgram: Prisma.$AcademicProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicProgramId: string
      startOn: Date
      endOn: Date | null
      status: string
      catalogYear: string | null
      primary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAcademicProgram"]>
    composites: {}
  }

  type StudentAcademicProgramGetPayload<S extends boolean | null | undefined | StudentAcademicProgramDefaultArgs> = $Result.GetResult<Prisma.$StudentAcademicProgramPayload, S>

  type StudentAcademicProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAcademicProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAcademicProgramCountAggregateInputType | true
    }

  export interface StudentAcademicProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAcademicProgram'], meta: { name: 'StudentAcademicProgram' } }
    /**
     * Find zero or one StudentAcademicProgram that matches the filter.
     * @param {StudentAcademicProgramFindUniqueArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAcademicProgramFindUniqueArgs>(args: SelectSubset<T, StudentAcademicProgramFindUniqueArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAcademicProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAcademicProgramFindUniqueOrThrowArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAcademicProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindFirstArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAcademicProgramFindFirstArgs>(args?: SelectSubset<T, StudentAcademicProgramFindFirstArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindFirstOrThrowArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAcademicProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAcademicPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAcademicPrograms
     * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany()
     * 
     * // Get first 10 StudentAcademicPrograms
     * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAcademicProgramWithIdOnly = await prisma.studentAcademicProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAcademicProgramFindManyArgs>(args?: SelectSubset<T, StudentAcademicProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAcademicProgram.
     * @param {StudentAcademicProgramCreateArgs} args - Arguments to create a StudentAcademicProgram.
     * @example
     * // Create one StudentAcademicProgram
     * const StudentAcademicProgram = await prisma.studentAcademicProgram.create({
     *   data: {
     *     // ... data to create a StudentAcademicProgram
     *   }
     * })
     * 
     */
    create<T extends StudentAcademicProgramCreateArgs>(args: SelectSubset<T, StudentAcademicProgramCreateArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAcademicPrograms.
     * @param {StudentAcademicProgramCreateManyArgs} args - Arguments to create many StudentAcademicPrograms.
     * @example
     * // Create many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAcademicProgramCreateManyArgs>(args?: SelectSubset<T, StudentAcademicProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAcademicPrograms and returns the data saved in the database.
     * @param {StudentAcademicProgramCreateManyAndReturnArgs} args - Arguments to create many StudentAcademicPrograms.
     * @example
     * // Create many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAcademicPrograms and only return the `id`
     * const studentAcademicProgramWithIdOnly = await prisma.studentAcademicProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAcademicProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentAcademicProgram.
     * @param {StudentAcademicProgramDeleteArgs} args - Arguments to delete one StudentAcademicProgram.
     * @example
     * // Delete one StudentAcademicProgram
     * const StudentAcademicProgram = await prisma.studentAcademicProgram.delete({
     *   where: {
     *     // ... filter to delete one StudentAcademicProgram
     *   }
     * })
     * 
     */
    delete<T extends StudentAcademicProgramDeleteArgs>(args: SelectSubset<T, StudentAcademicProgramDeleteArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAcademicProgram.
     * @param {StudentAcademicProgramUpdateArgs} args - Arguments to update one StudentAcademicProgram.
     * @example
     * // Update one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAcademicProgramUpdateArgs>(args: SelectSubset<T, StudentAcademicProgramUpdateArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAcademicPrograms.
     * @param {StudentAcademicProgramDeleteManyArgs} args - Arguments to filter StudentAcademicPrograms to delete.
     * @example
     * // Delete a few StudentAcademicPrograms
     * const { count } = await prisma.studentAcademicProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAcademicProgramDeleteManyArgs>(args?: SelectSubset<T, StudentAcademicProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAcademicProgramUpdateManyArgs>(args: SelectSubset<T, StudentAcademicProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicPrograms and returns the data updated in the database.
     * @param {StudentAcademicProgramUpdateManyAndReturnArgs} args - Arguments to update many StudentAcademicPrograms.
     * @example
     * // Update many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentAcademicPrograms and only return the `id`
     * const studentAcademicProgramWithIdOnly = await prisma.studentAcademicProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentAcademicProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentAcademicProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentAcademicProgram.
     * @param {StudentAcademicProgramUpsertArgs} args - Arguments to update or create a StudentAcademicProgram.
     * @example
     * // Update or create a StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.upsert({
     *   create: {
     *     // ... data to create a StudentAcademicProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAcademicProgram we want to update
     *   }
     * })
     */
    upsert<T extends StudentAcademicProgramUpsertArgs>(args: SelectSubset<T, StudentAcademicProgramUpsertArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramCountArgs} args - Arguments to filter StudentAcademicPrograms to count.
     * @example
     * // Count the number of StudentAcademicPrograms
     * const count = await prisma.studentAcademicProgram.count({
     *   where: {
     *     // ... the filter for the StudentAcademicPrograms we want to count
     *   }
     * })
    **/
    count<T extends StudentAcademicProgramCountArgs>(
      args?: Subset<T, StudentAcademicProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAcademicProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAcademicProgramAggregateArgs>(args: Subset<T, StudentAcademicProgramAggregateArgs>): Prisma.PrismaPromise<GetStudentAcademicProgramAggregateType<T>>

    /**
     * Group by StudentAcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAcademicProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAcademicProgramGroupByArgs['orderBy'] }
        : { orderBy?: StudentAcademicProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAcademicProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAcademicProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAcademicProgram model
   */
  readonly fields: StudentAcademicProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAcademicProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAcademicProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicProgram<T extends AcademicProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgramDefaultArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAcademicProgram model
   */
  interface StudentAcademicProgramFieldRefs {
    readonly id: FieldRef<"StudentAcademicProgram", 'String'>
    readonly studentId: FieldRef<"StudentAcademicProgram", 'String'>
    readonly academicProgramId: FieldRef<"StudentAcademicProgram", 'String'>
    readonly startOn: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly endOn: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly status: FieldRef<"StudentAcademicProgram", 'String'>
    readonly catalogYear: FieldRef<"StudentAcademicProgram", 'String'>
    readonly primary: FieldRef<"StudentAcademicProgram", 'Boolean'>
    readonly createdAt: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAcademicProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAcademicProgram findUnique
   */
  export type StudentAcademicProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram findUniqueOrThrow
   */
  export type StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram findFirst
   */
  export type StudentAcademicProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicPrograms.
     */
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram findFirstOrThrow
   */
  export type StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicPrograms.
     */
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram findMany
   */
  export type StudentAcademicProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicPrograms to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram create
   */
  export type StudentAcademicProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAcademicProgram.
     */
    data: XOR<StudentAcademicProgramCreateInput, StudentAcademicProgramUncheckedCreateInput>
  }

  /**
   * StudentAcademicProgram createMany
   */
  export type StudentAcademicProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAcademicPrograms.
     */
    data: StudentAcademicProgramCreateManyInput | StudentAcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAcademicProgram createManyAndReturn
   */
  export type StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * The data used to create many StudentAcademicPrograms.
     */
    data: StudentAcademicProgramCreateManyInput | StudentAcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAcademicProgram update
   */
  export type StudentAcademicProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAcademicProgram.
     */
    data: XOR<StudentAcademicProgramUpdateInput, StudentAcademicProgramUncheckedUpdateInput>
    /**
     * Choose, which StudentAcademicProgram to update.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram updateMany
   */
  export type StudentAcademicProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAcademicPrograms.
     */
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicPrograms to update
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * Limit how many StudentAcademicPrograms to update.
     */
    limit?: number
  }

  /**
   * StudentAcademicProgram updateManyAndReturn
   */
  export type StudentAcademicProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * The data used to update StudentAcademicPrograms.
     */
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicPrograms to update
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * Limit how many StudentAcademicPrograms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAcademicProgram upsert
   */
  export type StudentAcademicProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAcademicProgram to update in case it exists.
     */
    where: StudentAcademicProgramWhereUniqueInput
    /**
     * In case the StudentAcademicProgram found by the `where` argument doesn't exist, create a new StudentAcademicProgram with this data.
     */
    create: XOR<StudentAcademicProgramCreateInput, StudentAcademicProgramUncheckedCreateInput>
    /**
     * In case the StudentAcademicProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAcademicProgramUpdateInput, StudentAcademicProgramUncheckedUpdateInput>
  }

  /**
   * StudentAcademicProgram delete
   */
  export type StudentAcademicProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter which StudentAcademicProgram to delete.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram deleteMany
   */
  export type StudentAcademicProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicPrograms to delete
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * Limit how many StudentAcademicPrograms to delete.
     */
    limit?: number
  }

  /**
   * StudentAcademicProgram without action
   */
  export type StudentAcademicProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicProgram
     */
    omit?: StudentAcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
  }


  /**
   * Model AcademicCredential
   */

  export type AggregateAcademicCredential = {
    _count: AcademicCredentialCountAggregateOutputType | null
    _min: AcademicCredentialMinAggregateOutputType | null
    _max: AcademicCredentialMaxAggregateOutputType | null
  }

  export type AcademicCredentialMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    credentialCode: string | null
    academicProgramId: string | null
    awardedOn: Date | null
    status: string | null
    academicPeriodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicCredentialMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    credentialCode: string | null
    academicProgramId: string | null
    awardedOn: Date | null
    status: string | null
    academicPeriodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicCredentialCountAggregateOutputType = {
    id: number
    studentId: number
    credentialCode: number
    academicProgramId: number
    awardedOn: number
    status: number
    academicPeriodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicCredentialMinAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicCredentialMaxAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicCredentialCountAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCredential to aggregate.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicCredentials
    **/
    _count?: true | AcademicCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicCredentialMaxAggregateInputType
  }

  export type GetAcademicCredentialAggregateType<T extends AcademicCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicCredential[P]>
      : GetScalarType<T[P], AggregateAcademicCredential[P]>
  }




  export type AcademicCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithAggregationInput | AcademicCredentialOrderByWithAggregationInput[]
    by: AcademicCredentialScalarFieldEnum[] | AcademicCredentialScalarFieldEnum
    having?: AcademicCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicCredentialCountAggregateInputType | true
    _min?: AcademicCredentialMinAggregateInputType
    _max?: AcademicCredentialMaxAggregateInputType
  }

  export type AcademicCredentialGroupByOutputType = {
    id: string
    studentId: string
    credentialCode: string
    academicProgramId: string | null
    awardedOn: Date
    status: string
    academicPeriodId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AcademicCredentialCountAggregateOutputType | null
    _min: AcademicCredentialMinAggregateOutputType | null
    _max: AcademicCredentialMaxAggregateOutputType | null
  }

  type GetAcademicCredentialGroupByPayload<T extends AcademicCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicCredentialGroupByOutputType[P]>
        }
      >
    >


  export type AcademicCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["academicCredential"]>

  export type AcademicCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["academicCredential"]>

  export type AcademicCredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["academicCredential"]>

  export type AcademicCredentialSelectScalar = {
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "credentialCode" | "academicProgramId" | "awardedOn" | "status" | "academicPeriodId" | "createdAt" | "updatedAt", ExtArgs["result"]["academicCredential"]>
  export type AcademicCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }
  export type AcademicCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }
  export type AcademicCredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }

  export type $AcademicCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicCredential"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicProgram: Prisma.$AcademicProgramPayload<ExtArgs> | null
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      credentialCode: string
      academicProgramId: string | null
      awardedOn: Date
      status: string
      academicPeriodId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicCredential"]>
    composites: {}
  }

  type AcademicCredentialGetPayload<S extends boolean | null | undefined | AcademicCredentialDefaultArgs> = $Result.GetResult<Prisma.$AcademicCredentialPayload, S>

  type AcademicCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicCredentialCountAggregateInputType | true
    }

  export interface AcademicCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicCredential'], meta: { name: 'AcademicCredential' } }
    /**
     * Find zero or one AcademicCredential that matches the filter.
     * @param {AcademicCredentialFindUniqueArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicCredentialFindUniqueArgs>(args: SelectSubset<T, AcademicCredentialFindUniqueArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicCredentialFindUniqueOrThrowArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindFirstArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicCredentialFindFirstArgs>(args?: SelectSubset<T, AcademicCredentialFindFirstArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindFirstOrThrowArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicCredentials
     * const academicCredentials = await prisma.academicCredential.findMany()
     * 
     * // Get first 10 AcademicCredentials
     * const academicCredentials = await prisma.academicCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicCredentialWithIdOnly = await prisma.academicCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicCredentialFindManyArgs>(args?: SelectSubset<T, AcademicCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicCredential.
     * @param {AcademicCredentialCreateArgs} args - Arguments to create a AcademicCredential.
     * @example
     * // Create one AcademicCredential
     * const AcademicCredential = await prisma.academicCredential.create({
     *   data: {
     *     // ... data to create a AcademicCredential
     *   }
     * })
     * 
     */
    create<T extends AcademicCredentialCreateArgs>(args: SelectSubset<T, AcademicCredentialCreateArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicCredentials.
     * @param {AcademicCredentialCreateManyArgs} args - Arguments to create many AcademicCredentials.
     * @example
     * // Create many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicCredentialCreateManyArgs>(args?: SelectSubset<T, AcademicCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicCredentials and returns the data saved in the database.
     * @param {AcademicCredentialCreateManyAndReturnArgs} args - Arguments to create many AcademicCredentials.
     * @example
     * // Create many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicCredentials and only return the `id`
     * const academicCredentialWithIdOnly = await prisma.academicCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicCredential.
     * @param {AcademicCredentialDeleteArgs} args - Arguments to delete one AcademicCredential.
     * @example
     * // Delete one AcademicCredential
     * const AcademicCredential = await prisma.academicCredential.delete({
     *   where: {
     *     // ... filter to delete one AcademicCredential
     *   }
     * })
     * 
     */
    delete<T extends AcademicCredentialDeleteArgs>(args: SelectSubset<T, AcademicCredentialDeleteArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicCredential.
     * @param {AcademicCredentialUpdateArgs} args - Arguments to update one AcademicCredential.
     * @example
     * // Update one AcademicCredential
     * const academicCredential = await prisma.academicCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicCredentialUpdateArgs>(args: SelectSubset<T, AcademicCredentialUpdateArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicCredentials.
     * @param {AcademicCredentialDeleteManyArgs} args - Arguments to filter AcademicCredentials to delete.
     * @example
     * // Delete a few AcademicCredentials
     * const { count } = await prisma.academicCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicCredentialDeleteManyArgs>(args?: SelectSubset<T, AcademicCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicCredentialUpdateManyArgs>(args: SelectSubset<T, AcademicCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicCredentials and returns the data updated in the database.
     * @param {AcademicCredentialUpdateManyAndReturnArgs} args - Arguments to update many AcademicCredentials.
     * @example
     * // Update many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicCredentials and only return the `id`
     * const academicCredentialWithIdOnly = await prisma.academicCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicCredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicCredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicCredential.
     * @param {AcademicCredentialUpsertArgs} args - Arguments to update or create a AcademicCredential.
     * @example
     * // Update or create a AcademicCredential
     * const academicCredential = await prisma.academicCredential.upsert({
     *   create: {
     *     // ... data to create a AcademicCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicCredential we want to update
     *   }
     * })
     */
    upsert<T extends AcademicCredentialUpsertArgs>(args: SelectSubset<T, AcademicCredentialUpsertArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialCountArgs} args - Arguments to filter AcademicCredentials to count.
     * @example
     * // Count the number of AcademicCredentials
     * const count = await prisma.academicCredential.count({
     *   where: {
     *     // ... the filter for the AcademicCredentials we want to count
     *   }
     * })
    **/
    count<T extends AcademicCredentialCountArgs>(
      args?: Subset<T, AcademicCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicCredentialAggregateArgs>(args: Subset<T, AcademicCredentialAggregateArgs>): Prisma.PrismaPromise<GetAcademicCredentialAggregateType<T>>

    /**
     * Group by AcademicCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicCredentialGroupByArgs['orderBy'] }
        : { orderBy?: AcademicCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicCredential model
   */
  readonly fields: AcademicCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicProgram<T extends AcademicCredential$academicProgramArgs<ExtArgs> = {}>(args?: Subset<T, AcademicCredential$academicProgramArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends AcademicCredential$academicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, AcademicCredential$academicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicCredential model
   */
  interface AcademicCredentialFieldRefs {
    readonly id: FieldRef<"AcademicCredential", 'String'>
    readonly studentId: FieldRef<"AcademicCredential", 'String'>
    readonly credentialCode: FieldRef<"AcademicCredential", 'String'>
    readonly academicProgramId: FieldRef<"AcademicCredential", 'String'>
    readonly awardedOn: FieldRef<"AcademicCredential", 'DateTime'>
    readonly status: FieldRef<"AcademicCredential", 'String'>
    readonly academicPeriodId: FieldRef<"AcademicCredential", 'String'>
    readonly createdAt: FieldRef<"AcademicCredential", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicCredential findUnique
   */
  export type AcademicCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential findUniqueOrThrow
   */
  export type AcademicCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential findFirst
   */
  export type AcademicCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCredentials.
     */
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential findFirstOrThrow
   */
  export type AcademicCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCredentials.
     */
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential findMany
   */
  export type AcademicCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredentials to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential create
   */
  export type AcademicCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicCredential.
     */
    data: XOR<AcademicCredentialCreateInput, AcademicCredentialUncheckedCreateInput>
  }

  /**
   * AcademicCredential createMany
   */
  export type AcademicCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicCredentials.
     */
    data: AcademicCredentialCreateManyInput | AcademicCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicCredential createManyAndReturn
   */
  export type AcademicCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicCredentials.
     */
    data: AcademicCredentialCreateManyInput | AcademicCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicCredential update
   */
  export type AcademicCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicCredential.
     */
    data: XOR<AcademicCredentialUpdateInput, AcademicCredentialUncheckedUpdateInput>
    /**
     * Choose, which AcademicCredential to update.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential updateMany
   */
  export type AcademicCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicCredentials.
     */
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyInput>
    /**
     * Filter which AcademicCredentials to update
     */
    where?: AcademicCredentialWhereInput
    /**
     * Limit how many AcademicCredentials to update.
     */
    limit?: number
  }

  /**
   * AcademicCredential updateManyAndReturn
   */
  export type AcademicCredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * The data used to update AcademicCredentials.
     */
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyInput>
    /**
     * Filter which AcademicCredentials to update
     */
    where?: AcademicCredentialWhereInput
    /**
     * Limit how many AcademicCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicCredential upsert
   */
  export type AcademicCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicCredential to update in case it exists.
     */
    where: AcademicCredentialWhereUniqueInput
    /**
     * In case the AcademicCredential found by the `where` argument doesn't exist, create a new AcademicCredential with this data.
     */
    create: XOR<AcademicCredentialCreateInput, AcademicCredentialUncheckedCreateInput>
    /**
     * In case the AcademicCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicCredentialUpdateInput, AcademicCredentialUncheckedUpdateInput>
  }

  /**
   * AcademicCredential delete
   */
  export type AcademicCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter which AcademicCredential to delete.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential deleteMany
   */
  export type AcademicCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCredentials to delete
     */
    where?: AcademicCredentialWhereInput
    /**
     * Limit how many AcademicCredentials to delete.
     */
    limit?: number
  }

  /**
   * AcademicCredential.academicProgram
   */
  export type AcademicCredential$academicProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicProgram
     */
    omit?: AcademicProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    where?: AcademicProgramWhereInput
  }

  /**
   * AcademicCredential.academicPeriod
   */
  export type AcademicCredential$academicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicPeriod
     */
    omit?: AcademicPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * AcademicCredential without action
   */
  export type AcademicCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicCredential
     */
    omit?: AcademicCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
  }


  /**
   * Model StudentRisk
   */

  export type AggregateStudentRisk = {
    _count: StudentRiskCountAggregateOutputType | null
    _avg: StudentRiskAvgAggregateOutputType | null
    _sum: StudentRiskSumAggregateOutputType | null
    _min: StudentRiskMinAggregateOutputType | null
    _max: StudentRiskMaxAggregateOutputType | null
  }

  export type StudentRiskAvgAggregateOutputType = {
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
  }

  export type StudentRiskSumAggregateOutputType = {
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
  }

  export type StudentRiskMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicPeriodId: string | null
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
    overallRiskBucket: $Enums.RiskBucket | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type StudentRiskMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicPeriodId: string | null
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
    overallRiskBucket: $Enums.RiskBucket | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type StudentRiskCountAggregateOutputType = {
    id: number
    studentId: number
    academicPeriodId: number
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type StudentRiskAvgAggregateInputType = {
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
  }

  export type StudentRiskSumAggregateInputType = {
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
  }

  export type StudentRiskMinAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
  }

  export type StudentRiskMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
  }

  export type StudentRiskCountAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type StudentRiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRisk to aggregate.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentRisks
    **/
    _count?: true | StudentRiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentRiskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentRiskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentRiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentRiskMaxAggregateInputType
  }

  export type GetStudentRiskAggregateType<T extends StudentRiskAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentRisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentRisk[P]>
      : GetScalarType<T[P], AggregateStudentRisk[P]>
  }




  export type StudentRiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithAggregationInput | StudentRiskOrderByWithAggregationInput[]
    by: StudentRiskScalarFieldEnum[] | StudentRiskScalarFieldEnum
    having?: StudentRiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentRiskCountAggregateInputType | true
    _avg?: StudentRiskAvgAggregateInputType
    _sum?: StudentRiskSumAggregateInputType
    _min?: StudentRiskMinAggregateInputType
    _max?: StudentRiskMaxAggregateInputType
  }

  export type StudentRiskGroupByOutputType = {
    id: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt: Date
    createdAt: Date
    _count: StudentRiskCountAggregateOutputType | null
    _avg: StudentRiskAvgAggregateOutputType | null
    _sum: StudentRiskSumAggregateOutputType | null
    _min: StudentRiskMinAggregateOutputType | null
    _max: StudentRiskMaxAggregateOutputType | null
  }

  type GetStudentRiskGroupByPayload<T extends StudentRiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentRiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentRiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentRiskGroupByOutputType[P]>
            : GetScalarType<T[P], StudentRiskGroupByOutputType[P]>
        }
      >
    >


  export type StudentRiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRisk"]>

  export type StudentRiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRisk"]>

  export type StudentRiskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRisk"]>

  export type StudentRiskSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type StudentRiskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "academicPeriodId" | "attendanceRiskScore" | "academicSupportRiskScore" | "overallRiskBucket" | "updatedAt" | "createdAt", ExtArgs["result"]["studentRisk"]>
  export type StudentRiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }
  export type StudentRiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }
  export type StudentRiskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }

  export type $StudentRiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentRisk"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicPeriodId: string
      attendanceRiskScore: number
      academicSupportRiskScore: number
      overallRiskBucket: $Enums.RiskBucket
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["studentRisk"]>
    composites: {}
  }

  type StudentRiskGetPayload<S extends boolean | null | undefined | StudentRiskDefaultArgs> = $Result.GetResult<Prisma.$StudentRiskPayload, S>

  type StudentRiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentRiskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentRiskCountAggregateInputType | true
    }

  export interface StudentRiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentRisk'], meta: { name: 'StudentRisk' } }
    /**
     * Find zero or one StudentRisk that matches the filter.
     * @param {StudentRiskFindUniqueArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentRiskFindUniqueArgs>(args: SelectSubset<T, StudentRiskFindUniqueArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentRisk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentRiskFindUniqueOrThrowArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentRiskFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentRiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentRisk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindFirstArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentRiskFindFirstArgs>(args?: SelectSubset<T, StudentRiskFindFirstArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentRisk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindFirstOrThrowArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentRiskFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentRiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentRisks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentRisks
     * const studentRisks = await prisma.studentRisk.findMany()
     * 
     * // Get first 10 StudentRisks
     * const studentRisks = await prisma.studentRisk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentRiskWithIdOnly = await prisma.studentRisk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentRiskFindManyArgs>(args?: SelectSubset<T, StudentRiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentRisk.
     * @param {StudentRiskCreateArgs} args - Arguments to create a StudentRisk.
     * @example
     * // Create one StudentRisk
     * const StudentRisk = await prisma.studentRisk.create({
     *   data: {
     *     // ... data to create a StudentRisk
     *   }
     * })
     * 
     */
    create<T extends StudentRiskCreateArgs>(args: SelectSubset<T, StudentRiskCreateArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentRisks.
     * @param {StudentRiskCreateManyArgs} args - Arguments to create many StudentRisks.
     * @example
     * // Create many StudentRisks
     * const studentRisk = await prisma.studentRisk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentRiskCreateManyArgs>(args?: SelectSubset<T, StudentRiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentRisks and returns the data saved in the database.
     * @param {StudentRiskCreateManyAndReturnArgs} args - Arguments to create many StudentRisks.
     * @example
     * // Create many StudentRisks
     * const studentRisk = await prisma.studentRisk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentRisks and only return the `id`
     * const studentRiskWithIdOnly = await prisma.studentRisk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentRiskCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentRiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentRisk.
     * @param {StudentRiskDeleteArgs} args - Arguments to delete one StudentRisk.
     * @example
     * // Delete one StudentRisk
     * const StudentRisk = await prisma.studentRisk.delete({
     *   where: {
     *     // ... filter to delete one StudentRisk
     *   }
     * })
     * 
     */
    delete<T extends StudentRiskDeleteArgs>(args: SelectSubset<T, StudentRiskDeleteArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentRisk.
     * @param {StudentRiskUpdateArgs} args - Arguments to update one StudentRisk.
     * @example
     * // Update one StudentRisk
     * const studentRisk = await prisma.studentRisk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentRiskUpdateArgs>(args: SelectSubset<T, StudentRiskUpdateArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentRisks.
     * @param {StudentRiskDeleteManyArgs} args - Arguments to filter StudentRisks to delete.
     * @example
     * // Delete a few StudentRisks
     * const { count } = await prisma.studentRisk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentRiskDeleteManyArgs>(args?: SelectSubset<T, StudentRiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentRisks
     * const studentRisk = await prisma.studentRisk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentRiskUpdateManyArgs>(args: SelectSubset<T, StudentRiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentRisks and returns the data updated in the database.
     * @param {StudentRiskUpdateManyAndReturnArgs} args - Arguments to update many StudentRisks.
     * @example
     * // Update many StudentRisks
     * const studentRisk = await prisma.studentRisk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentRisks and only return the `id`
     * const studentRiskWithIdOnly = await prisma.studentRisk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentRiskUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentRiskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentRisk.
     * @param {StudentRiskUpsertArgs} args - Arguments to update or create a StudentRisk.
     * @example
     * // Update or create a StudentRisk
     * const studentRisk = await prisma.studentRisk.upsert({
     *   create: {
     *     // ... data to create a StudentRisk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentRisk we want to update
     *   }
     * })
     */
    upsert<T extends StudentRiskUpsertArgs>(args: SelectSubset<T, StudentRiskUpsertArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskCountArgs} args - Arguments to filter StudentRisks to count.
     * @example
     * // Count the number of StudentRisks
     * const count = await prisma.studentRisk.count({
     *   where: {
     *     // ... the filter for the StudentRisks we want to count
     *   }
     * })
    **/
    count<T extends StudentRiskCountArgs>(
      args?: Subset<T, StudentRiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentRiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentRiskAggregateArgs>(args: Subset<T, StudentRiskAggregateArgs>): Prisma.PrismaPromise<GetStudentRiskAggregateType<T>>

    /**
     * Group by StudentRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentRiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentRiskGroupByArgs['orderBy'] }
        : { orderBy?: StudentRiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentRiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentRiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentRisk model
   */
  readonly fields: StudentRiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentRisk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentRiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentRisk model
   */
  interface StudentRiskFieldRefs {
    readonly id: FieldRef<"StudentRisk", 'String'>
    readonly studentId: FieldRef<"StudentRisk", 'String'>
    readonly academicPeriodId: FieldRef<"StudentRisk", 'String'>
    readonly attendanceRiskScore: FieldRef<"StudentRisk", 'Float'>
    readonly academicSupportRiskScore: FieldRef<"StudentRisk", 'Float'>
    readonly overallRiskBucket: FieldRef<"StudentRisk", 'RiskBucket'>
    readonly updatedAt: FieldRef<"StudentRisk", 'DateTime'>
    readonly createdAt: FieldRef<"StudentRisk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentRisk findUnique
   */
  export type StudentRiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk findUniqueOrThrow
   */
  export type StudentRiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk findFirst
   */
  export type StudentRiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRisks.
     */
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk findFirstOrThrow
   */
  export type StudentRiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRisks.
     */
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk findMany
   */
  export type StudentRiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisks to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk create
   */
  export type StudentRiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentRisk.
     */
    data: XOR<StudentRiskCreateInput, StudentRiskUncheckedCreateInput>
  }

  /**
   * StudentRisk createMany
   */
  export type StudentRiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentRisks.
     */
    data: StudentRiskCreateManyInput | StudentRiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentRisk createManyAndReturn
   */
  export type StudentRiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * The data used to create many StudentRisks.
     */
    data: StudentRiskCreateManyInput | StudentRiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentRisk update
   */
  export type StudentRiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentRisk.
     */
    data: XOR<StudentRiskUpdateInput, StudentRiskUncheckedUpdateInput>
    /**
     * Choose, which StudentRisk to update.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk updateMany
   */
  export type StudentRiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentRisks.
     */
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyInput>
    /**
     * Filter which StudentRisks to update
     */
    where?: StudentRiskWhereInput
    /**
     * Limit how many StudentRisks to update.
     */
    limit?: number
  }

  /**
   * StudentRisk updateManyAndReturn
   */
  export type StudentRiskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * The data used to update StudentRisks.
     */
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyInput>
    /**
     * Filter which StudentRisks to update
     */
    where?: StudentRiskWhereInput
    /**
     * Limit how many StudentRisks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentRisk upsert
   */
  export type StudentRiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentRisk to update in case it exists.
     */
    where: StudentRiskWhereUniqueInput
    /**
     * In case the StudentRisk found by the `where` argument doesn't exist, create a new StudentRisk with this data.
     */
    create: XOR<StudentRiskCreateInput, StudentRiskUncheckedCreateInput>
    /**
     * In case the StudentRisk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentRiskUpdateInput, StudentRiskUncheckedUpdateInput>
  }

  /**
   * StudentRisk delete
   */
  export type StudentRiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter which StudentRisk to delete.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk deleteMany
   */
  export type StudentRiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRisks to delete
     */
    where?: StudentRiskWhereInput
    /**
     * Limit how many StudentRisks to delete.
     */
    limit?: number
  }

  /**
   * StudentRisk without action
   */
  export type StudentRiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRisk
     */
    omit?: StudentRiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
  }


  /**
   * Model SimulationState
   */

  export type AggregateSimulationState = {
    _count: SimulationStateCountAggregateOutputType | null
    _min: SimulationStateMinAggregateOutputType | null
    _max: SimulationStateMaxAggregateOutputType | null
  }

  export type SimulationStateMinAggregateOutputType = {
    id: string | null
    currentSimDate: Date | null
    lastTickDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationStateMaxAggregateOutputType = {
    id: string | null
    currentSimDate: Date | null
    lastTickDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationStateCountAggregateOutputType = {
    id: number
    currentSimDate: number
    lastTickDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SimulationStateMinAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationStateMaxAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationStateCountAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SimulationStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationState to aggregate.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationStates
    **/
    _count?: true | SimulationStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationStateMaxAggregateInputType
  }

  export type GetSimulationStateAggregateType<T extends SimulationStateAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationState[P]>
      : GetScalarType<T[P], AggregateSimulationState[P]>
  }




  export type SimulationStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationStateWhereInput
    orderBy?: SimulationStateOrderByWithAggregationInput | SimulationStateOrderByWithAggregationInput[]
    by: SimulationStateScalarFieldEnum[] | SimulationStateScalarFieldEnum
    having?: SimulationStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationStateCountAggregateInputType | true
    _min?: SimulationStateMinAggregateInputType
    _max?: SimulationStateMaxAggregateInputType
  }

  export type SimulationStateGroupByOutputType = {
    id: string
    currentSimDate: Date
    lastTickDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SimulationStateCountAggregateOutputType | null
    _min: SimulationStateMinAggregateOutputType | null
    _max: SimulationStateMaxAggregateOutputType | null
  }

  type GetSimulationStateGroupByPayload<T extends SimulationStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationStateGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationStateGroupByOutputType[P]>
        }
      >
    >


  export type SimulationStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simulationState"]>

  export type SimulationStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simulationState"]>

  export type SimulationStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simulationState"]>

  export type SimulationStateSelectScalar = {
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SimulationStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currentSimDate" | "lastTickDate" | "createdAt" | "updatedAt", ExtArgs["result"]["simulationState"]>

  export type $SimulationStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currentSimDate: Date
      lastTickDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["simulationState"]>
    composites: {}
  }

  type SimulationStateGetPayload<S extends boolean | null | undefined | SimulationStateDefaultArgs> = $Result.GetResult<Prisma.$SimulationStatePayload, S>

  type SimulationStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationStateCountAggregateInputType | true
    }

  export interface SimulationStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationState'], meta: { name: 'SimulationState' } }
    /**
     * Find zero or one SimulationState that matches the filter.
     * @param {SimulationStateFindUniqueArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationStateFindUniqueArgs>(args: SelectSubset<T, SimulationStateFindUniqueArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimulationState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationStateFindUniqueOrThrowArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationStateFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindFirstArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationStateFindFirstArgs>(args?: SelectSubset<T, SimulationStateFindFirstArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindFirstOrThrowArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationStateFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimulationStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationStates
     * const simulationStates = await prisma.simulationState.findMany()
     * 
     * // Get first 10 SimulationStates
     * const simulationStates = await prisma.simulationState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationStateWithIdOnly = await prisma.simulationState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationStateFindManyArgs>(args?: SelectSubset<T, SimulationStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimulationState.
     * @param {SimulationStateCreateArgs} args - Arguments to create a SimulationState.
     * @example
     * // Create one SimulationState
     * const SimulationState = await prisma.simulationState.create({
     *   data: {
     *     // ... data to create a SimulationState
     *   }
     * })
     * 
     */
    create<T extends SimulationStateCreateArgs>(args: SelectSubset<T, SimulationStateCreateArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimulationStates.
     * @param {SimulationStateCreateManyArgs} args - Arguments to create many SimulationStates.
     * @example
     * // Create many SimulationStates
     * const simulationState = await prisma.simulationState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationStateCreateManyArgs>(args?: SelectSubset<T, SimulationStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationStates and returns the data saved in the database.
     * @param {SimulationStateCreateManyAndReturnArgs} args - Arguments to create many SimulationStates.
     * @example
     * // Create many SimulationStates
     * const simulationState = await prisma.simulationState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationStates and only return the `id`
     * const simulationStateWithIdOnly = await prisma.simulationState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationStateCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimulationState.
     * @param {SimulationStateDeleteArgs} args - Arguments to delete one SimulationState.
     * @example
     * // Delete one SimulationState
     * const SimulationState = await prisma.simulationState.delete({
     *   where: {
     *     // ... filter to delete one SimulationState
     *   }
     * })
     * 
     */
    delete<T extends SimulationStateDeleteArgs>(args: SelectSubset<T, SimulationStateDeleteArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimulationState.
     * @param {SimulationStateUpdateArgs} args - Arguments to update one SimulationState.
     * @example
     * // Update one SimulationState
     * const simulationState = await prisma.simulationState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationStateUpdateArgs>(args: SelectSubset<T, SimulationStateUpdateArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimulationStates.
     * @param {SimulationStateDeleteManyArgs} args - Arguments to filter SimulationStates to delete.
     * @example
     * // Delete a few SimulationStates
     * const { count } = await prisma.simulationState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationStateDeleteManyArgs>(args?: SelectSubset<T, SimulationStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationStates
     * const simulationState = await prisma.simulationState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationStateUpdateManyArgs>(args: SelectSubset<T, SimulationStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationStates and returns the data updated in the database.
     * @param {SimulationStateUpdateManyAndReturnArgs} args - Arguments to update many SimulationStates.
     * @example
     * // Update many SimulationStates
     * const simulationState = await prisma.simulationState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimulationStates and only return the `id`
     * const simulationStateWithIdOnly = await prisma.simulationState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationStateUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimulationState.
     * @param {SimulationStateUpsertArgs} args - Arguments to update or create a SimulationState.
     * @example
     * // Update or create a SimulationState
     * const simulationState = await prisma.simulationState.upsert({
     *   create: {
     *     // ... data to create a SimulationState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationState we want to update
     *   }
     * })
     */
    upsert<T extends SimulationStateUpsertArgs>(args: SelectSubset<T, SimulationStateUpsertArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimulationStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateCountArgs} args - Arguments to filter SimulationStates to count.
     * @example
     * // Count the number of SimulationStates
     * const count = await prisma.simulationState.count({
     *   where: {
     *     // ... the filter for the SimulationStates we want to count
     *   }
     * })
    **/
    count<T extends SimulationStateCountArgs>(
      args?: Subset<T, SimulationStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationStateAggregateArgs>(args: Subset<T, SimulationStateAggregateArgs>): Prisma.PrismaPromise<GetSimulationStateAggregateType<T>>

    /**
     * Group by SimulationState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationStateGroupByArgs['orderBy'] }
        : { orderBy?: SimulationStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationState model
   */
  readonly fields: SimulationStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationState model
   */
  interface SimulationStateFieldRefs {
    readonly id: FieldRef<"SimulationState", 'String'>
    readonly currentSimDate: FieldRef<"SimulationState", 'DateTime'>
    readonly lastTickDate: FieldRef<"SimulationState", 'DateTime'>
    readonly createdAt: FieldRef<"SimulationState", 'DateTime'>
    readonly updatedAt: FieldRef<"SimulationState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimulationState findUnique
   */
  export type SimulationStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState findUniqueOrThrow
   */
  export type SimulationStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState findFirst
   */
  export type SimulationStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationStates.
     */
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState findFirstOrThrow
   */
  export type SimulationStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationStates.
     */
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState findMany
   */
  export type SimulationStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter, which SimulationStates to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState create
   */
  export type SimulationStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * The data needed to create a SimulationState.
     */
    data: XOR<SimulationStateCreateInput, SimulationStateUncheckedCreateInput>
  }

  /**
   * SimulationState createMany
   */
  export type SimulationStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationStates.
     */
    data: SimulationStateCreateManyInput | SimulationStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationState createManyAndReturn
   */
  export type SimulationStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * The data used to create many SimulationStates.
     */
    data: SimulationStateCreateManyInput | SimulationStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationState update
   */
  export type SimulationStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * The data needed to update a SimulationState.
     */
    data: XOR<SimulationStateUpdateInput, SimulationStateUncheckedUpdateInput>
    /**
     * Choose, which SimulationState to update.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState updateMany
   */
  export type SimulationStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationStates.
     */
    data: XOR<SimulationStateUpdateManyMutationInput, SimulationStateUncheckedUpdateManyInput>
    /**
     * Filter which SimulationStates to update
     */
    where?: SimulationStateWhereInput
    /**
     * Limit how many SimulationStates to update.
     */
    limit?: number
  }

  /**
   * SimulationState updateManyAndReturn
   */
  export type SimulationStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * The data used to update SimulationStates.
     */
    data: XOR<SimulationStateUpdateManyMutationInput, SimulationStateUncheckedUpdateManyInput>
    /**
     * Filter which SimulationStates to update
     */
    where?: SimulationStateWhereInput
    /**
     * Limit how many SimulationStates to update.
     */
    limit?: number
  }

  /**
   * SimulationState upsert
   */
  export type SimulationStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * The filter to search for the SimulationState to update in case it exists.
     */
    where: SimulationStateWhereUniqueInput
    /**
     * In case the SimulationState found by the `where` argument doesn't exist, create a new SimulationState with this data.
     */
    create: XOR<SimulationStateCreateInput, SimulationStateUncheckedCreateInput>
    /**
     * In case the SimulationState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationStateUpdateInput, SimulationStateUncheckedUpdateInput>
  }

  /**
   * SimulationState delete
   */
  export type SimulationStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
    /**
     * Filter which SimulationState to delete.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState deleteMany
   */
  export type SimulationStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationStates to delete
     */
    where?: SimulationStateWhereInput
    /**
     * Limit how many SimulationStates to delete.
     */
    limit?: number
  }

  /**
   * SimulationState without action
   */
  export type SimulationStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationState
     */
    omit?: SimulationStateOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PersonScalarFieldEnum: {
    id: 'id',
    birthDate: 'birthDate',
    gender: 'gender',
    citizenshipStatus: 'citizenshipStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const PersonNameScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    given: 'given',
    middle: 'middle',
    family: 'family',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonNameScalarFieldEnum = (typeof PersonNameScalarFieldEnum)[keyof typeof PersonNameScalarFieldEnum]


  export const EmailAddressScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    address: 'address',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailAddressScalarFieldEnum = (typeof EmailAddressScalarFieldEnum)[keyof typeof EmailAddressScalarFieldEnum]


  export const PhoneScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    number: 'number',
    extension: 'extension',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhoneScalarFieldEnum = (typeof PhoneScalarFieldEnum)[keyof typeof PhoneScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    type: 'type',
    line1: 'line1',
    line2: 'line2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    type: 'type',
    status: 'status',
    startOn: 'startOn',
    entryAcademicPeriodId: 'entryAcademicPeriodId',
    academicLevel: 'academicLevel',
    residency: 'residency',
    studentClassification: 'studentClassification',
    studentLoad: 'studentLoad',
    academicStandingCode: 'academicStandingCode',
    studentNumber: 'studentNumber',
    isFirstGen: 'isFirstGen',
    isPellEligible: 'isPellEligible',
    isInState: 'isInState',
    workHoursPerWeek: 'workHoursPerWeek',
    commuteMinutes: 'commuteMinutes',
    hasHousingInstability: 'hasHousingInstability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const AcademicPeriodScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    type: 'type',
    startOn: 'startOn',
    endOn: 'endOn',
    censusOn: 'censusOn',
    registrationStartOn: 'registrationStartOn',
    registrationEndOn: 'registrationEndOn',
    academicYear: 'academicYear',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicPeriodScalarFieldEnum = (typeof AcademicPeriodScalarFieldEnum)[keyof typeof AcademicPeriodScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    subjectCode: 'subjectCode',
    number: 'number',
    title: 'title',
    description: 'description',
    creditType: 'creditType',
    creditsMinimum: 'creditsMinimum',
    creditsMaximum: 'creditsMaximum',
    creditsIncrement: 'creditsIncrement',
    courseLevel: 'courseLevel',
    status: 'status',
    effectiveStartDate: 'effectiveStartDate',
    effectiveEndDate: 'effectiveEndDate',
    catalogYear: 'catalogYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    academicPeriodId: 'academicPeriodId',
    number: 'number',
    title: 'title',
    crn: 'crn',
    startOn: 'startOn',
    endOn: 'endOn',
    status: 'status',
    capacity: 'capacity',
    enrolled: 'enrolled',
    available: 'available',
    waitlistCapacity: 'waitlistCapacity',
    waitlistEnrolled: 'waitlistEnrolled',
    instructionalMethodCode: 'instructionalMethodCode',
    daysOfWeek: 'daysOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    building: 'building',
    roomNumber: 'roomNumber',
    creditType: 'creditType',
    creditsMinimum: 'creditsMinimum',
    creditsMaximum: 'creditsMaximum',
    instructorPersonId: 'instructorPersonId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const SectionRegistrationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sectionId: 'sectionId',
    academicPeriodId: 'academicPeriodId',
    statusCode: 'statusCode',
    registrationDate: 'registrationDate',
    registeredOn: 'registeredOn',
    creditType: 'creditType',
    credits: 'credits',
    gradingOptionCode: 'gradingOptionCode',
    academicLoad: 'academicLoad',
    residencyStatus: 'residencyStatus',
    attendanceRate: 'attendanceRate',
    midtermGrade: 'midtermGrade',
    finalGrade: 'finalGrade',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionRegistrationScalarFieldEnum = (typeof SectionRegistrationScalarFieldEnum)[keyof typeof SectionRegistrationScalarFieldEnum]


  export const StudentTranscriptGradeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sectionRegistrationId: 'sectionRegistrationId',
    sectionId: 'sectionId',
    academicPeriodId: 'academicPeriodId',
    courseId: 'courseId',
    gradeSchemeCode: 'gradeSchemeCode',
    gradeValue: 'gradeValue',
    gradePoints: 'gradePoints',
    qualityPoints: 'qualityPoints',
    creditsAttempted: 'creditsAttempted',
    creditsEarned: 'creditsEarned',
    finalGradeDate: 'finalGradeDate',
    status: 'status',
    incomplete: 'incomplete',
    repeat: 'repeat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentTranscriptGradeScalarFieldEnum = (typeof StudentTranscriptGradeScalarFieldEnum)[keyof typeof StudentTranscriptGradeScalarFieldEnum]


  export const AcademicProgramScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    type: 'type',
    level: 'level',
    degreeCode: 'degreeCode',
    status: 'status',
    startOn: 'startOn',
    endOn: 'endOn',
    accreditationCode: 'accreditationCode',
    creditsRequired: 'creditsRequired',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicProgramScalarFieldEnum = (typeof AcademicProgramScalarFieldEnum)[keyof typeof AcademicProgramScalarFieldEnum]


  export const StudentAcademicProgramScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicProgramId: 'academicProgramId',
    startOn: 'startOn',
    endOn: 'endOn',
    status: 'status',
    catalogYear: 'catalogYear',
    primary: 'primary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAcademicProgramScalarFieldEnum = (typeof StudentAcademicProgramScalarFieldEnum)[keyof typeof StudentAcademicProgramScalarFieldEnum]


  export const AcademicCredentialScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    credentialCode: 'credentialCode',
    academicProgramId: 'academicProgramId',
    awardedOn: 'awardedOn',
    status: 'status',
    academicPeriodId: 'academicPeriodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicCredentialScalarFieldEnum = (typeof AcademicCredentialScalarFieldEnum)[keyof typeof AcademicCredentialScalarFieldEnum]


  export const StudentRiskScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicPeriodId: 'academicPeriodId',
    attendanceRiskScore: 'attendanceRiskScore',
    academicSupportRiskScore: 'academicSupportRiskScore',
    overallRiskBucket: 'overallRiskBucket',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type StudentRiskScalarFieldEnum = (typeof StudentRiskScalarFieldEnum)[keyof typeof StudentRiskScalarFieldEnum]


  export const SimulationStateScalarFieldEnum: {
    id: 'id',
    currentSimDate: 'currentSimDate',
    lastTickDate: 'lastTickDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SimulationStateScalarFieldEnum = (typeof SimulationStateScalarFieldEnum)[keyof typeof SimulationStateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RiskBucket'
   */
  export type EnumRiskBucketFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskBucket'>
    


  /**
   * Reference to a field of type 'RiskBucket[]'
   */
  export type ListEnumRiskBucketFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskBucket[]'>
    
  /**
   * Deep Input Types
   */


  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    birthDate?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: StringNullableFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    names?: PersonNameListRelationFilter
    emails?: EmailAddressListRelationFilter
    phones?: PhoneListRelationFilter
    addresses?: AddressListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    sections?: SectionListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    citizenshipStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    names?: PersonNameOrderByRelationAggregateInput
    emails?: EmailAddressOrderByRelationAggregateInput
    phones?: PhoneOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    sections?: SectionOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    birthDate?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: StringNullableFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    names?: PersonNameListRelationFilter
    emails?: EmailAddressListRelationFilter
    phones?: PhoneListRelationFilter
    addresses?: AddressListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    sections?: SectionListRelationFilter
  }, "id">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    citizenshipStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableWithAggregatesFilter<"Person"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
  }

  export type PersonNameWhereInput = {
    AND?: PersonNameWhereInput | PersonNameWhereInput[]
    OR?: PersonNameWhereInput[]
    NOT?: PersonNameWhereInput | PersonNameWhereInput[]
    id?: StringFilter<"PersonName"> | string
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type PersonNameOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrderInput | SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type PersonNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonNameWhereInput | PersonNameWhereInput[]
    OR?: PersonNameWhereInput[]
    NOT?: PersonNameWhereInput | PersonNameWhereInput[]
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id">

  export type PersonNameOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrderInput | SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonNameCountOrderByAggregateInput
    _max?: PersonNameMaxOrderByAggregateInput
    _min?: PersonNameMinOrderByAggregateInput
  }

  export type PersonNameScalarWhereWithAggregatesInput = {
    AND?: PersonNameScalarWhereWithAggregatesInput | PersonNameScalarWhereWithAggregatesInput[]
    OR?: PersonNameScalarWhereWithAggregatesInput[]
    NOT?: PersonNameScalarWhereWithAggregatesInput | PersonNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonName"> | string
    personId?: StringWithAggregatesFilter<"PersonName"> | string
    given?: StringWithAggregatesFilter<"PersonName"> | string
    middle?: StringNullableWithAggregatesFilter<"PersonName"> | string | null
    family?: StringWithAggregatesFilter<"PersonName"> | string
    type?: StringWithAggregatesFilter<"PersonName"> | string
    preferred?: BoolWithAggregatesFilter<"PersonName"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonName"> | Date | string
  }

  export type EmailAddressWhereInput = {
    AND?: EmailAddressWhereInput | EmailAddressWhereInput[]
    OR?: EmailAddressWhereInput[]
    NOT?: EmailAddressWhereInput | EmailAddressWhereInput[]
    id?: StringFilter<"EmailAddress"> | string
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type EmailAddressOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type EmailAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId_address?: EmailAddressPersonIdAddressCompoundUniqueInput
    AND?: EmailAddressWhereInput | EmailAddressWhereInput[]
    OR?: EmailAddressWhereInput[]
    NOT?: EmailAddressWhereInput | EmailAddressWhereInput[]
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id" | "personId_address">

  export type EmailAddressOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailAddressCountOrderByAggregateInput
    _max?: EmailAddressMaxOrderByAggregateInput
    _min?: EmailAddressMinOrderByAggregateInput
  }

  export type EmailAddressScalarWhereWithAggregatesInput = {
    AND?: EmailAddressScalarWhereWithAggregatesInput | EmailAddressScalarWhereWithAggregatesInput[]
    OR?: EmailAddressScalarWhereWithAggregatesInput[]
    NOT?: EmailAddressScalarWhereWithAggregatesInput | EmailAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAddress"> | string
    personId?: StringWithAggregatesFilter<"EmailAddress"> | string
    address?: StringWithAggregatesFilter<"EmailAddress"> | string
    type?: StringWithAggregatesFilter<"EmailAddress"> | string
    preferred?: BoolWithAggregatesFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAddress"> | Date | string
  }

  export type PhoneWhereInput = {
    AND?: PhoneWhereInput | PhoneWhereInput[]
    OR?: PhoneWhereInput[]
    NOT?: PhoneWhereInput | PhoneWhereInput[]
    id?: StringFilter<"Phone"> | string
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type PhoneOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrderInput | SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type PhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhoneWhereInput | PhoneWhereInput[]
    OR?: PhoneWhereInput[]
    NOT?: PhoneWhereInput | PhoneWhereInput[]
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id">

  export type PhoneOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrderInput | SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhoneCountOrderByAggregateInput
    _max?: PhoneMaxOrderByAggregateInput
    _min?: PhoneMinOrderByAggregateInput
  }

  export type PhoneScalarWhereWithAggregatesInput = {
    AND?: PhoneScalarWhereWithAggregatesInput | PhoneScalarWhereWithAggregatesInput[]
    OR?: PhoneScalarWhereWithAggregatesInput[]
    NOT?: PhoneScalarWhereWithAggregatesInput | PhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Phone"> | string
    personId?: StringWithAggregatesFilter<"Phone"> | string
    number?: StringWithAggregatesFilter<"Phone"> | string
    extension?: StringNullableWithAggregatesFilter<"Phone"> | string | null
    type?: StringWithAggregatesFilter<"Phone"> | string
    preferred?: BoolWithAggregatesFilter<"Phone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Phone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phone"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    personId?: StringWithAggregatesFilter<"Address"> | string
    type?: StringWithAggregatesFilter<"Address"> | string
    line1?: StringWithAggregatesFilter<"Address"> | string
    line2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    personId?: StringFilter<"Student"> | string
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    studentNumber?: StringFilter<"Student"> | string
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    entryAcademicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    studentAcademicPrograms?: StudentAcademicProgramListRelationFilter
    academicCredentials?: AcademicCredentialListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrderInput | SortOrder
    academicLevel?: SortOrderInput | SortOrder
    residency?: SortOrderInput | SortOrder
    studentClassification?: SortOrderInput | SortOrder
    studentLoad?: SortOrderInput | SortOrder
    academicStandingCode?: SortOrderInput | SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    entryAcademicPeriod?: AcademicPeriodOrderByWithRelationInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    studentAcademicPrograms?: StudentAcademicProgramOrderByRelationAggregateInput
    academicCredentials?: AcademicCredentialOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
    studentRisks?: StudentRiskOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    studentNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    entryAcademicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    studentAcademicPrograms?: StudentAcademicProgramListRelationFilter
    academicCredentials?: AcademicCredentialListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }, "id" | "personId" | "studentNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrderInput | SortOrder
    academicLevel?: SortOrderInput | SortOrder
    residency?: SortOrderInput | SortOrder
    studentClassification?: SortOrderInput | SortOrder
    studentLoad?: SortOrderInput | SortOrder
    academicStandingCode?: SortOrderInput | SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    personId?: StringWithAggregatesFilter<"Student"> | string
    type?: StringWithAggregatesFilter<"Student"> | string
    status?: StringWithAggregatesFilter<"Student"> | string
    startOn?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicLevel?: StringNullableWithAggregatesFilter<"Student"> | string | null
    residency?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentClassification?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentLoad?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicStandingCode?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentNumber?: StringWithAggregatesFilter<"Student"> | string
    isFirstGen?: BoolWithAggregatesFilter<"Student"> | boolean
    isPellEligible?: BoolWithAggregatesFilter<"Student"> | boolean
    isInState?: BoolWithAggregatesFilter<"Student"> | boolean
    workHoursPerWeek?: IntWithAggregatesFilter<"Student"> | number
    commuteMinutes?: IntWithAggregatesFilter<"Student"> | number
    hasHousingInstability?: BoolWithAggregatesFilter<"Student"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type AcademicPeriodWhereInput = {
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    id?: StringFilter<"AcademicPeriod"> | string
    code?: StringFilter<"AcademicPeriod"> | string
    title?: StringFilter<"AcademicPeriod"> | string
    type?: StringFilter<"AcademicPeriod"> | string
    startOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringFilter<"AcademicPeriod"> | string
    status?: StringFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    sections?: SectionListRelationFilter
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    entryStudents?: StudentListRelationFilter
    credentialPeriods?: AcademicCredentialListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }

  export type AcademicPeriodOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrderInput | SortOrder
    registrationStartOn?: SortOrderInput | SortOrder
    registrationEndOn?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: SectionOrderByRelationAggregateInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
    entryStudents?: StudentOrderByRelationAggregateInput
    credentialPeriods?: AcademicCredentialOrderByRelationAggregateInput
    studentRisks?: StudentRiskOrderByRelationAggregateInput
  }

  export type AcademicPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    title?: StringFilter<"AcademicPeriod"> | string
    type?: StringFilter<"AcademicPeriod"> | string
    startOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringFilter<"AcademicPeriod"> | string
    status?: StringFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    sections?: SectionListRelationFilter
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    entryStudents?: StudentListRelationFilter
    credentialPeriods?: AcademicCredentialListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }, "id" | "code">

  export type AcademicPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrderInput | SortOrder
    registrationStartOn?: SortOrderInput | SortOrder
    registrationEndOn?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicPeriodCountOrderByAggregateInput
    _max?: AcademicPeriodMaxOrderByAggregateInput
    _min?: AcademicPeriodMinOrderByAggregateInput
  }

  export type AcademicPeriodScalarWhereWithAggregatesInput = {
    AND?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    OR?: AcademicPeriodScalarWhereWithAggregatesInput[]
    NOT?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    code?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    title?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    type?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    startOn?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    status?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    subjectCode?: StringFilter<"Course"> | string
    number?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    creditType?: StringFilter<"Course"> | string
    creditsMinimum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFilter<"Course"> | string
    status?: StringFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    sections?: SectionListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrderInput | SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrderInput | SortOrder
    effectiveEndDate?: SortOrderInput | SortOrder
    catalogYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: SectionOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subjectCode_number_catalogYear?: CourseSubjectCodeNumberCatalogYearCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    subjectCode?: StringFilter<"Course"> | string
    number?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    creditType?: StringFilter<"Course"> | string
    creditsMinimum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFilter<"Course"> | string
    status?: StringFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    sections?: SectionListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }, "id" | "subjectCode_number_catalogYear">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrderInput | SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrderInput | SortOrder
    effectiveEndDate?: SortOrderInput | SortOrder
    catalogYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    subjectCode?: StringWithAggregatesFilter<"Course"> | string
    number?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    creditType?: StringWithAggregatesFilter<"Course"> | string
    creditsMinimum?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringWithAggregatesFilter<"Course"> | string
    status?: StringWithAggregatesFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    instructor?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrderInput | SortOrder
    waitlistEnrolled?: SortOrderInput | SortOrder
    instructionalMethodCode?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    instructor?: PersonOrderByWithRelationInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    academicPeriodId_crn?: SectionAcademicPeriodIdCrnCompoundUniqueInput
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    instructor?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }, "id" | "academicPeriodId_crn">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrderInput | SortOrder
    waitlistEnrolled?: SortOrderInput | SortOrder
    instructionalMethodCode?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    courseId?: StringWithAggregatesFilter<"Section"> | string
    academicPeriodId?: StringWithAggregatesFilter<"Section"> | string
    number?: StringWithAggregatesFilter<"Section"> | string
    title?: StringNullableWithAggregatesFilter<"Section"> | string | null
    crn?: StringWithAggregatesFilter<"Section"> | string
    startOn?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    endOn?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    status?: StringWithAggregatesFilter<"Section"> | string
    capacity?: IntWithAggregatesFilter<"Section"> | number
    enrolled?: IntWithAggregatesFilter<"Section"> | number
    available?: IntWithAggregatesFilter<"Section"> | number
    waitlistCapacity?: IntNullableWithAggregatesFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableWithAggregatesFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableWithAggregatesFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableWithAggregatesFilter<"Section"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"Section"> | string | null
    building?: StringNullableWithAggregatesFilter<"Section"> | string | null
    roomNumber?: StringNullableWithAggregatesFilter<"Section"> | string | null
    creditType?: StringWithAggregatesFilter<"Section"> | string
    creditsMinimum?: DecimalWithAggregatesFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalWithAggregatesFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableWithAggregatesFilter<"Section"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type SectionRegistrationWhereInput = {
    AND?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    OR?: SectionRegistrationWhereInput[]
    NOT?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    id?: StringFilter<"SectionRegistration"> | string
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    transcriptGrade?: XOR<StudentTranscriptGradeNullableScalarRelationFilter, StudentTranscriptGradeWhereInput> | null
  }

  export type SectionRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrderInput | SortOrder
    academicLoad?: SortOrderInput | SortOrder
    residencyStatus?: SortOrderInput | SortOrder
    attendanceRate?: SortOrderInput | SortOrder
    midtermGrade?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    transcriptGrade?: StudentTranscriptGradeOrderByWithRelationInput
  }

  export type SectionRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_sectionId?: SectionRegistrationStudentIdSectionIdCompoundUniqueInput
    AND?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    OR?: SectionRegistrationWhereInput[]
    NOT?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    transcriptGrade?: XOR<StudentTranscriptGradeNullableScalarRelationFilter, StudentTranscriptGradeWhereInput> | null
  }, "id" | "studentId_sectionId">

  export type SectionRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrderInput | SortOrder
    academicLoad?: SortOrderInput | SortOrder
    residencyStatus?: SortOrderInput | SortOrder
    attendanceRate?: SortOrderInput | SortOrder
    midtermGrade?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionRegistrationCountOrderByAggregateInput
    _avg?: SectionRegistrationAvgOrderByAggregateInput
    _max?: SectionRegistrationMaxOrderByAggregateInput
    _min?: SectionRegistrationMinOrderByAggregateInput
    _sum?: SectionRegistrationSumOrderByAggregateInput
  }

  export type SectionRegistrationScalarWhereWithAggregatesInput = {
    AND?: SectionRegistrationScalarWhereWithAggregatesInput | SectionRegistrationScalarWhereWithAggregatesInput[]
    OR?: SectionRegistrationScalarWhereWithAggregatesInput[]
    NOT?: SectionRegistrationScalarWhereWithAggregatesInput | SectionRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectionRegistration"> | string
    studentId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    sectionId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    academicPeriodId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    statusCode?: StringWithAggregatesFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    creditType?: StringWithAggregatesFilter<"SectionRegistration"> | string
    credits?: DecimalWithAggregatesFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableWithAggregatesFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
  }

  export type StudentTranscriptGradeWhereInput = {
    AND?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    OR?: StudentTranscriptGradeWhereInput[]
    NOT?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    id?: StringFilter<"StudentTranscriptGrade"> | string
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    sectionRegistration?: XOR<SectionRegistrationScalarRelationFilter, SectionRegistrationWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type StudentTranscriptGradeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrderInput | SortOrder
    gradeValue?: SortOrderInput | SortOrder
    gradePoints?: SortOrderInput | SortOrder
    qualityPoints?: SortOrderInput | SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrderInput | SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    sectionRegistration?: SectionRegistrationOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type StudentTranscriptGradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionRegistrationId?: string
    AND?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    OR?: StudentTranscriptGradeWhereInput[]
    NOT?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    sectionRegistration?: XOR<SectionRegistrationScalarRelationFilter, SectionRegistrationWhereInput>
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "sectionRegistrationId">

  export type StudentTranscriptGradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrderInput | SortOrder
    gradeValue?: SortOrderInput | SortOrder
    gradePoints?: SortOrderInput | SortOrder
    qualityPoints?: SortOrderInput | SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrderInput | SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentTranscriptGradeCountOrderByAggregateInput
    _avg?: StudentTranscriptGradeAvgOrderByAggregateInput
    _max?: StudentTranscriptGradeMaxOrderByAggregateInput
    _min?: StudentTranscriptGradeMinOrderByAggregateInput
    _sum?: StudentTranscriptGradeSumOrderByAggregateInput
  }

  export type StudentTranscriptGradeScalarWhereWithAggregatesInput = {
    AND?: StudentTranscriptGradeScalarWhereWithAggregatesInput | StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    OR?: StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    NOT?: StudentTranscriptGradeScalarWhereWithAggregatesInput | StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    studentId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    courseId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableWithAggregatesFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableWithAggregatesFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolWithAggregatesFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolWithAggregatesFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string
  }

  export type AcademicProgramWhereInput = {
    AND?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    OR?: AcademicProgramWhereInput[]
    NOT?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    id?: StringFilter<"AcademicProgram"> | string
    code?: StringFilter<"AcademicProgram"> | string
    title?: StringFilter<"AcademicProgram"> | string
    type?: StringFilter<"AcademicProgram"> | string
    level?: StringFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableFilter<"AcademicProgram"> | string | null
    status?: StringFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntFilter<"AcademicProgram"> | number
    description?: StringNullableFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    studentPrograms?: StudentAcademicProgramListRelationFilter
    credentials?: AcademicCredentialListRelationFilter
  }

  export type AcademicProgramOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrderInput | SortOrder
    status?: SortOrder
    startOn?: SortOrderInput | SortOrder
    endOn?: SortOrderInput | SortOrder
    accreditationCode?: SortOrderInput | SortOrder
    creditsRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentPrograms?: StudentAcademicProgramOrderByRelationAggregateInput
    credentials?: AcademicCredentialOrderByRelationAggregateInput
  }

  export type AcademicProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    OR?: AcademicProgramWhereInput[]
    NOT?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    title?: StringFilter<"AcademicProgram"> | string
    type?: StringFilter<"AcademicProgram"> | string
    level?: StringFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableFilter<"AcademicProgram"> | string | null
    status?: StringFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntFilter<"AcademicProgram"> | number
    description?: StringNullableFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    studentPrograms?: StudentAcademicProgramListRelationFilter
    credentials?: AcademicCredentialListRelationFilter
  }, "id" | "code">

  export type AcademicProgramOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrderInput | SortOrder
    status?: SortOrder
    startOn?: SortOrderInput | SortOrder
    endOn?: SortOrderInput | SortOrder
    accreditationCode?: SortOrderInput | SortOrder
    creditsRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicProgramCountOrderByAggregateInput
    _avg?: AcademicProgramAvgOrderByAggregateInput
    _max?: AcademicProgramMaxOrderByAggregateInput
    _min?: AcademicProgramMinOrderByAggregateInput
    _sum?: AcademicProgramSumOrderByAggregateInput
  }

  export type AcademicProgramScalarWhereWithAggregatesInput = {
    AND?: AcademicProgramScalarWhereWithAggregatesInput | AcademicProgramScalarWhereWithAggregatesInput[]
    OR?: AcademicProgramScalarWhereWithAggregatesInput[]
    NOT?: AcademicProgramScalarWhereWithAggregatesInput | AcademicProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicProgram"> | string
    code?: StringWithAggregatesFilter<"AcademicProgram"> | string
    title?: StringWithAggregatesFilter<"AcademicProgram"> | string
    type?: StringWithAggregatesFilter<"AcademicProgram"> | string
    level?: StringWithAggregatesFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    status?: StringWithAggregatesFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableWithAggregatesFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableWithAggregatesFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntWithAggregatesFilter<"AcademicProgram"> | number
    description?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicProgram"> | Date | string
  }

  export type StudentAcademicProgramWhereInput = {
    AND?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    OR?: StudentAcademicProgramWhereInput[]
    NOT?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    id?: StringFilter<"StudentAcademicProgram"> | string
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramScalarRelationFilter, AcademicProgramWhereInput>
  }

  export type StudentAcademicProgramOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrderInput | SortOrder
    status?: SortOrder
    catalogYear?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicProgram?: AcademicProgramOrderByWithRelationInput
  }

  export type StudentAcademicProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    OR?: StudentAcademicProgramWhereInput[]
    NOT?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramScalarRelationFilter, AcademicProgramWhereInput>
  }, "id">

  export type StudentAcademicProgramOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrderInput | SortOrder
    status?: SortOrder
    catalogYear?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAcademicProgramCountOrderByAggregateInput
    _max?: StudentAcademicProgramMaxOrderByAggregateInput
    _min?: StudentAcademicProgramMinOrderByAggregateInput
  }

  export type StudentAcademicProgramScalarWhereWithAggregatesInput = {
    AND?: StudentAcademicProgramScalarWhereWithAggregatesInput | StudentAcademicProgramScalarWhereWithAggregatesInput[]
    OR?: StudentAcademicProgramScalarWhereWithAggregatesInput[]
    NOT?: StudentAcademicProgramScalarWhereWithAggregatesInput | StudentAcademicProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    studentId?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableWithAggregatesFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableWithAggregatesFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolWithAggregatesFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
  }

  export type AcademicCredentialWhereInput = {
    AND?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    OR?: AcademicCredentialWhereInput[]
    NOT?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    id?: StringFilter<"AcademicCredential"> | string
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramNullableScalarRelationFilter, AcademicProgramWhereInput> | null
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
  }

  export type AcademicCredentialOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrderInput | SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicProgram?: AcademicProgramOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
  }

  export type AcademicCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    OR?: AcademicCredentialWhereInput[]
    NOT?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramNullableScalarRelationFilter, AcademicProgramWhereInput> | null
    academicPeriod?: XOR<AcademicPeriodNullableScalarRelationFilter, AcademicPeriodWhereInput> | null
  }, "id">

  export type AcademicCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrderInput | SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicCredentialCountOrderByAggregateInput
    _max?: AcademicCredentialMaxOrderByAggregateInput
    _min?: AcademicCredentialMinOrderByAggregateInput
  }

  export type AcademicCredentialScalarWhereWithAggregatesInput = {
    AND?: AcademicCredentialScalarWhereWithAggregatesInput | AcademicCredentialScalarWhereWithAggregatesInput[]
    OR?: AcademicCredentialScalarWhereWithAggregatesInput[]
    NOT?: AcademicCredentialScalarWhereWithAggregatesInput | AcademicCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicCredential"> | string
    studentId?: StringWithAggregatesFilter<"AcademicCredential"> | string
    credentialCode?: StringWithAggregatesFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableWithAggregatesFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
    status?: StringWithAggregatesFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableWithAggregatesFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
  }

  export type StudentRiskWhereInput = {
    AND?: StudentRiskWhereInput | StudentRiskWhereInput[]
    OR?: StudentRiskWhereInput[]
    NOT?: StudentRiskWhereInput | StudentRiskWhereInput[]
    id?: StringFilter<"StudentRisk"> | string
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
  }

  export type StudentRiskOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
  }

  export type StudentRiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_academicPeriodId?: StudentRiskStudentIdAcademicPeriodIdCompoundUniqueInput
    AND?: StudentRiskWhereInput | StudentRiskWhereInput[]
    OR?: StudentRiskWhereInput[]
    NOT?: StudentRiskWhereInput | StudentRiskWhereInput[]
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicPeriod?: XOR<AcademicPeriodScalarRelationFilter, AcademicPeriodWhereInput>
  }, "id" | "studentId_academicPeriodId">

  export type StudentRiskOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: StudentRiskCountOrderByAggregateInput
    _avg?: StudentRiskAvgOrderByAggregateInput
    _max?: StudentRiskMaxOrderByAggregateInput
    _min?: StudentRiskMinOrderByAggregateInput
    _sum?: StudentRiskSumOrderByAggregateInput
  }

  export type StudentRiskScalarWhereWithAggregatesInput = {
    AND?: StudentRiskScalarWhereWithAggregatesInput | StudentRiskScalarWhereWithAggregatesInput[]
    OR?: StudentRiskScalarWhereWithAggregatesInput[]
    NOT?: StudentRiskScalarWhereWithAggregatesInput | StudentRiskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentRisk"> | string
    studentId?: StringWithAggregatesFilter<"StudentRisk"> | string
    academicPeriodId?: StringWithAggregatesFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatWithAggregatesFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatWithAggregatesFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketWithAggregatesFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeWithAggregatesFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentRisk"> | Date | string
  }

  export type SimulationStateWhereInput = {
    AND?: SimulationStateWhereInput | SimulationStateWhereInput[]
    OR?: SimulationStateWhereInput[]
    NOT?: SimulationStateWhereInput | SimulationStateWhereInput[]
    id?: StringFilter<"SimulationState"> | string
    currentSimDate?: DateTimeFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationState"> | Date | string
  }

  export type SimulationStateOrderByWithRelationInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationStateWhereInput | SimulationStateWhereInput[]
    OR?: SimulationStateWhereInput[]
    NOT?: SimulationStateWhereInput | SimulationStateWhereInput[]
    currentSimDate?: DateTimeFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationState"> | Date | string
  }, "id">

  export type SimulationStateOrderByWithAggregationInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SimulationStateCountOrderByAggregateInput
    _max?: SimulationStateMaxOrderByAggregateInput
    _min?: SimulationStateMinOrderByAggregateInput
  }

  export type SimulationStateScalarWhereWithAggregatesInput = {
    AND?: SimulationStateScalarWhereWithAggregatesInput | SimulationStateScalarWhereWithAggregatesInput[]
    OR?: SimulationStateScalarWhereWithAggregatesInput[]
    NOT?: SimulationStateScalarWhereWithAggregatesInput | SimulationStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationState"> | string
    currentSimDate?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableWithAggregatesFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
  }

  export type PersonCreateInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameCreateInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutNamesInput
  }

  export type PersonNameUncheckedCreateInput = {
    id?: string
    personId: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutNamesNestedInput
  }

  export type PersonNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameCreateManyInput = {
    id?: string
    personId: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressCreateInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutEmailsInput
  }

  export type EmailAddressUncheckedCreateInput = {
    id?: string
    personId: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressCreateManyInput = {
    id?: string
    personId: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCreateInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateInput = {
    id?: string
    personId: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type PhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCreateManyInput = {
    id?: string
    personId: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    personId: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    personId: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodCreateManyInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutCourseInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutCourseInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutCourseNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutCourseNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationCreateInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationCreateManyInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeCreateInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeCreateManyInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicProgramCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput
    credentials?: AcademicCredentialCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput
    credentials?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput
    credentials?: AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput
    credentials?: AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramCreateManyInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAcademicProgramsInput
    academicProgram: AcademicProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateInput = {
    id?: string
    studentId: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput
    academicProgram?: AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateManyInput = {
    id?: string
    studentId: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialCreateInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialCreateManyInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskCreateInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentRisksInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentRisksNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskCreateManyInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateCreateInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUncheckedCreateInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateCreateManyInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PersonNameListRelationFilter = {
    every?: PersonNameWhereInput
    some?: PersonNameWhereInput
    none?: PersonNameWhereInput
  }

  export type EmailAddressListRelationFilter = {
    every?: EmailAddressWhereInput
    some?: EmailAddressWhereInput
    none?: EmailAddressWhereInput
  }

  export type PhoneListRelationFilter = {
    every?: PhoneWhereInput
    some?: PhoneWhereInput
    none?: PhoneWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PersonScalarRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type PersonNameCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonNameMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonNameMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmailAddressPersonIdAddressCompoundUniqueInput = {
    personId: string
    address: string
  }

  export type EmailAddressCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAddressMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AcademicPeriodNullableScalarRelationFilter = {
    is?: AcademicPeriodWhereInput | null
    isNot?: AcademicPeriodWhereInput | null
  }

  export type SectionRegistrationListRelationFilter = {
    every?: SectionRegistrationWhereInput
    some?: SectionRegistrationWhereInput
    none?: SectionRegistrationWhereInput
  }

  export type StudentAcademicProgramListRelationFilter = {
    every?: StudentAcademicProgramWhereInput
    some?: StudentAcademicProgramWhereInput
    none?: StudentAcademicProgramWhereInput
  }

  export type AcademicCredentialListRelationFilter = {
    every?: AcademicCredentialWhereInput
    some?: AcademicCredentialWhereInput
    none?: AcademicCredentialWhereInput
  }

  export type StudentTranscriptGradeListRelationFilter = {
    every?: StudentTranscriptGradeWhereInput
    some?: StudentTranscriptGradeWhereInput
    none?: StudentTranscriptGradeWhereInput
  }

  export type StudentRiskListRelationFilter = {
    every?: StudentRiskWhereInput
    some?: StudentRiskWhereInput
    none?: StudentRiskWhereInput
  }

  export type SectionRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAcademicProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTranscriptGradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentRiskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CourseSubjectCodeNumberCatalogYearCompoundUniqueInput = {
    subjectCode: string
    number: string
    catalogYear: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type AcademicPeriodScalarRelationFilter = {
    is?: AcademicPeriodWhereInput
    isNot?: AcademicPeriodWhereInput
  }

  export type PersonNullableScalarRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type SectionAcademicPeriodIdCrnCompoundUniqueInput = {
    academicPeriodId: string
    crn: string
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type StudentTranscriptGradeNullableScalarRelationFilter = {
    is?: StudentTranscriptGradeWhereInput | null
    isNot?: StudentTranscriptGradeWhereInput | null
  }

  export type SectionRegistrationStudentIdSectionIdCompoundUniqueInput = {
    studentId: string
    sectionId: string
  }

  export type SectionRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationAvgOrderByAggregateInput = {
    credits?: SortOrder
    attendanceRate?: SortOrder
  }

  export type SectionRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationSumOrderByAggregateInput = {
    credits?: SortOrder
    attendanceRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SectionRegistrationScalarRelationFilter = {
    is?: SectionRegistrationWhereInput
    isNot?: SectionRegistrationWhereInput
  }

  export type StudentTranscriptGradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeAvgOrderByAggregateInput = {
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
  }

  export type StudentTranscriptGradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeSumOrderByAggregateInput = {
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
  }

  export type AcademicProgramCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramAvgOrderByAggregateInput = {
    creditsRequired?: SortOrder
  }

  export type AcademicProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramSumOrderByAggregateInput = {
    creditsRequired?: SortOrder
  }

  export type AcademicProgramScalarRelationFilter = {
    is?: AcademicProgramWhereInput
    isNot?: AcademicProgramWhereInput
  }

  export type StudentAcademicProgramCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAcademicProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAcademicProgramMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramNullableScalarRelationFilter = {
    is?: AcademicProgramWhereInput | null
    isNot?: AcademicProgramWhereInput | null
  }

  export type AcademicCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumRiskBucketFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketFilter<$PrismaModel> | $Enums.RiskBucket
  }

  export type StudentRiskStudentIdAcademicPeriodIdCompoundUniqueInput = {
    studentId: string
    academicPeriodId: string
  }

  export type StudentRiskCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskAvgOrderByAggregateInput = {
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
  }

  export type StudentRiskMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskSumOrderByAggregateInput = {
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumRiskBucketWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel> | $Enums.RiskBucket
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskBucketFilter<$PrismaModel>
    _max?: NestedEnumRiskBucketFilter<$PrismaModel>
  }

  export type SimulationStateCountOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateMaxOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateMinOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonNameCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
  }

  export type EmailAddressCreateNestedManyWithoutPersonInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
  }

  export type PhoneCreateNestedManyWithoutPersonInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutPersonInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionCreateNestedManyWithoutInstructorInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type PersonNameUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
  }

  export type EmailAddressUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
  }

  export type PhoneUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonNameUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    upsert?: PersonNameUpsertWithWhereUniqueWithoutPersonInput | PersonNameUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    set?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    disconnect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    delete?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    update?: PersonNameUpdateWithWhereUniqueWithoutPersonInput | PersonNameUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonNameUpdateManyWithWhereWithoutPersonInput | PersonNameUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
  }

  export type EmailAddressUpdateManyWithoutPersonNestedInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    upsert?: EmailAddressUpsertWithWhereUniqueWithoutPersonInput | EmailAddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    set?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    disconnect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    delete?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    update?: EmailAddressUpdateWithWhereUniqueWithoutPersonInput | EmailAddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: EmailAddressUpdateManyWithWhereWithoutPersonInput | EmailAddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
  }

  export type PhoneUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    upsert?: PhoneUpsertWithWhereUniqueWithoutPersonInput | PhoneUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    set?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    disconnect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    delete?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    update?: PhoneUpdateWithWhereUniqueWithoutPersonInput | PhoneUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PhoneUpdateManyWithWhereWithoutPersonInput | PhoneUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutPersonNestedInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonInput | AddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonInput | AddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonInput | AddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type SectionUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutInstructorInput | SectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutInstructorInput | SectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutInstructorInput | SectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type PersonNameUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    upsert?: PersonNameUpsertWithWhereUniqueWithoutPersonInput | PersonNameUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    set?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    disconnect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    delete?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    update?: PersonNameUpdateWithWhereUniqueWithoutPersonInput | PersonNameUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonNameUpdateManyWithWhereWithoutPersonInput | PersonNameUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
  }

  export type EmailAddressUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    upsert?: EmailAddressUpsertWithWhereUniqueWithoutPersonInput | EmailAddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    set?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    disconnect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    delete?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    update?: EmailAddressUpdateWithWhereUniqueWithoutPersonInput | EmailAddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: EmailAddressUpdateManyWithWhereWithoutPersonInput | EmailAddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
  }

  export type PhoneUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    upsert?: PhoneUpsertWithWhereUniqueWithoutPersonInput | PhoneUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    set?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    disconnect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    delete?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    update?: PhoneUpdateWithWhereUniqueWithoutPersonInput | PhoneUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PhoneUpdateManyWithWhereWithoutPersonInput | PhoneUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonInput | AddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonInput | AddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonInput | AddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type SectionUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutInstructorInput | SectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutInstructorInput | SectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutInstructorInput | SectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type PersonCreateNestedOneWithoutNamesInput = {
    create?: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutNamesInput
    connect?: PersonWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonUpdateOneRequiredWithoutNamesNestedInput = {
    create?: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutNamesInput
    upsert?: PersonUpsertWithoutNamesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutNamesInput, PersonUpdateWithoutNamesInput>, PersonUncheckedUpdateWithoutNamesInput>
  }

  export type PersonCreateNestedOneWithoutEmailsInput = {
    create?: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmailsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmailsInput
    upsert?: PersonUpsertWithoutEmailsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutEmailsInput, PersonUpdateWithoutEmailsInput>, PersonUncheckedUpdateWithoutEmailsInput>
  }

  export type PersonCreateNestedOneWithoutPhonesInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    upsert?: PersonUpsertWithoutPhonesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutPhonesInput, PersonUpdateWithoutPhonesInput>, PersonUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonCreateNestedOneWithoutAddressesInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    upsert?: PersonUpsertWithoutAddressesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutAddressesInput, PersonUpdateWithoutAddressesInput>, PersonUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonCreateNestedOneWithoutStudentInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    connect?: PersonWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutEntryStudentsInput = {
    create?: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEntryStudentsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedManyWithoutStudentInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentAcademicProgramCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentRiskCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentRiskUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    upsert?: PersonUpsertWithoutStudentInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutStudentInput, PersonUpdateWithoutStudentInput>, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEntryStudentsInput
    upsert?: AcademicPeriodUpsertWithoutEntryStudentsInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutEntryStudentsInput, AcademicPeriodUpdateWithoutEntryStudentsInput>, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
  }

  export type SectionRegistrationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput | SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput | SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutStudentInput | SectionRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentAcademicProgramUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput | StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput | AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput | AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutStudentInput | AcademicCredentialUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput | StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentRiskUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutStudentInput | StudentRiskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutStudentInput | StudentRiskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutStudentInput | StudentRiskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput | SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput | SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutStudentInput | SectionRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput | StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput | AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput | AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutStudentInput | AcademicCredentialUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput | StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentRiskUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutStudentInput | StudentRiskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutStudentInput | StudentRiskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutStudentInput | StudentRiskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutEntryAcademicPeriodInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentRiskCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutAcademicPeriodInput | SectionUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput | SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutEntryAcademicPeriodNestedInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput | StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentRiskUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput | StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutAcademicPeriodInput | SectionUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput | SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput | StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput | StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionCreateNestedManyWithoutCourseInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SectionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCourseInput | SectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCourseInput | SectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCourseInput | SectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput | StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCourseInput | SectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCourseInput | SectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCourseInput | SectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput | StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionCreatedaysOfWeekInput = {
    set: string[]
  }

  export type CourseCreateNestedOneWithoutSectionsInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutSectionsInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutSectionsInput = {
    create?: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSectionsInput
    connect?: PersonWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SectionUpdatedaysOfWeekInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    upsert?: CourseUpsertWithoutSectionsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSectionsInput, CourseUpdateWithoutSectionsInput>, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionsInput
    upsert?: AcademicPeriodUpsertWithoutSectionsInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutSectionsInput, AcademicPeriodUpdateWithoutSectionsInput>, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
  }

  export type PersonUpdateOneWithoutSectionsNestedInput = {
    create?: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSectionsInput
    upsert?: PersonUpsertWithoutSectionsInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutSectionsInput, PersonUpdateWithoutSectionsInput>, PersonUncheckedUpdateWithoutSectionsInput>
  }

  export type SectionRegistrationUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput | SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput | SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutSectionInput | SectionRegistrationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput | StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput | SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput | SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutSectionInput | SectionRegistrationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput | StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSectionRegistrationsInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSectionRegistrationsInput
    connect?: SectionWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    connect?: StudentTranscriptGradeWhereUniqueInput
  }

  export type StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    connect?: StudentTranscriptGradeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: StudentUpsertWithoutSectionRegistrationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSectionRegistrationsInput, StudentUpdateWithoutSectionRegistrationsInput>, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: SectionUpsertWithoutSectionRegistrationsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutSectionRegistrationsInput, SectionUpdateWithoutSectionRegistrationsInput>, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: AcademicPeriodUpsertWithoutSectionRegistrationsInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutSectionRegistrationsInput, AcademicPeriodUpdateWithoutSectionRegistrationsInput>, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    upsert?: StudentTranscriptGradeUpsertWithoutSectionRegistrationInput
    disconnect?: StudentTranscriptGradeWhereInput | boolean
    delete?: StudentTranscriptGradeWhereInput | boolean
    connect?: StudentTranscriptGradeWhereUniqueInput
    update?: XOR<XOR<StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput, StudentTranscriptGradeUpdateWithoutSectionRegistrationInput>, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    upsert?: StudentTranscriptGradeUpsertWithoutSectionRegistrationInput
    disconnect?: StudentTranscriptGradeWhereInput | boolean
    delete?: StudentTranscriptGradeWhereInput | boolean
    connect?: StudentTranscriptGradeWhereUniqueInput
    update?: XOR<XOR<StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput, StudentTranscriptGradeUpdateWithoutSectionRegistrationInput>, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput = {
    create?: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput
    connect?: SectionRegistrationWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTranscriptGradesInput
    connect?: SectionWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTranscriptGradesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptGradesInput
    upsert?: StudentUpsertWithoutTranscriptGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTranscriptGradesInput, StudentUpdateWithoutTranscriptGradesInput>, StudentUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput
    upsert?: SectionRegistrationUpsertWithoutTranscriptGradeInput
    connect?: SectionRegistrationWhereUniqueInput
    update?: XOR<XOR<SectionRegistrationUpdateToOneWithWhereWithoutTranscriptGradeInput, SectionRegistrationUpdateWithoutTranscriptGradeInput>, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
  }

  export type SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTranscriptGradesInput
    upsert?: SectionUpsertWithoutTranscriptGradesInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTranscriptGradesInput, SectionUpdateWithoutTranscriptGradesInput>, SectionUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput
    upsert?: AcademicPeriodUpsertWithoutTranscriptGradesInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutTranscriptGradesInput, AcademicPeriodUpdateWithoutTranscriptGradesInput>, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTranscriptGradesInput
    upsert?: CourseUpsertWithoutTranscriptGradesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTranscriptGradesInput, CourseUpdateWithoutTranscriptGradesInput>, CourseUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput | StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput | StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentAcademicProgramsInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicProgramsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicProgramCreateNestedOneWithoutStudentProgramsInput = {
    create?: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutStudentProgramsInput
    connect?: AcademicProgramWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicProgramsInput
    upsert?: StudentUpsertWithoutStudentAcademicProgramsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAcademicProgramsInput, StudentUpdateWithoutStudentAcademicProgramsInput>, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
  }

  export type AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput = {
    create?: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutStudentProgramsInput
    upsert?: AcademicProgramUpsertWithoutStudentProgramsInput
    connect?: AcademicProgramWhereUniqueInput
    update?: XOR<XOR<AcademicProgramUpdateToOneWithWhereWithoutStudentProgramsInput, AcademicProgramUpdateWithoutStudentProgramsInput>, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type StudentCreateNestedOneWithoutAcademicCredentialsInput = {
    create?: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicCredentialsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicProgramCreateNestedOneWithoutCredentialsInput = {
    create?: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutCredentialsInput
    connect?: AcademicProgramWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput = {
    create?: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicCredentialsInput
    upsert?: StudentUpsertWithoutAcademicCredentialsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicCredentialsInput, StudentUpdateWithoutAcademicCredentialsInput>, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
  }

  export type AcademicProgramUpdateOneWithoutCredentialsNestedInput = {
    create?: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutCredentialsInput
    upsert?: AcademicProgramUpsertWithoutCredentialsInput
    disconnect?: AcademicProgramWhereInput | boolean
    delete?: AcademicProgramWhereInput | boolean
    connect?: AcademicProgramWhereUniqueInput
    update?: XOR<XOR<AcademicProgramUpdateToOneWithWhereWithoutCredentialsInput, AcademicProgramUpdateWithoutCredentialsInput>, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
  }

  export type AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput
    upsert?: AcademicPeriodUpsertWithoutCredentialPeriodsInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutCredentialPeriodsInput, AcademicPeriodUpdateWithoutCredentialPeriodsInput>, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
  }

  export type StudentCreateNestedOneWithoutStudentRisksInput = {
    create?: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentRisksInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutStudentRisksInput = {
    create?: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutStudentRisksInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRiskBucketFieldUpdateOperationsInput = {
    set?: $Enums.RiskBucket
  }

  export type StudentUpdateOneRequiredWithoutStudentRisksNestedInput = {
    create?: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentRisksInput
    upsert?: StudentUpsertWithoutStudentRisksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentRisksInput, StudentUpdateWithoutStudentRisksInput>, StudentUncheckedUpdateWithoutStudentRisksInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutStudentRisksInput
    upsert?: AcademicPeriodUpsertWithoutStudentRisksInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutStudentRisksInput, AcademicPeriodUpdateWithoutStudentRisksInput>, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRiskBucketFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketFilter<$PrismaModel> | $Enums.RiskBucket
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel> | $Enums.RiskBucket
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskBucketFilter<$PrismaModel>
    _max?: NestedEnumRiskBucketFilter<$PrismaModel>
  }

  export type PersonNameCreateWithoutPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUncheckedCreateWithoutPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameCreateOrConnectWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    create: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput>
  }

  export type PersonNameCreateManyPersonInputEnvelope = {
    data: PersonNameCreateManyPersonInput | PersonNameCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type EmailAddressCreateWithoutPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUncheckedCreateWithoutPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressCreateOrConnectWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    create: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput>
  }

  export type EmailAddressCreateManyPersonInputEnvelope = {
    data: EmailAddressCreateManyPersonInput | EmailAddressCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type PhoneCreateWithoutPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUncheckedCreateWithoutPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneCreateOrConnectWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput>
  }

  export type PhoneCreateManyPersonInputEnvelope = {
    data: PhoneCreateManyPersonInput | PhoneCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutPersonInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput>
  }

  export type AddressCreateManyPersonInputEnvelope = {
    data: AddressCreateManyPersonInput | AddressCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutPersonInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPersonInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPersonInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
  }

  export type SectionCreateWithoutInstructorInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutInstructorInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput>
  }

  export type SectionCreateManyInstructorInputEnvelope = {
    data: SectionCreateManyInstructorInput | SectionCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type PersonNameUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    update: XOR<PersonNameUpdateWithoutPersonInput, PersonNameUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput>
  }

  export type PersonNameUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    data: XOR<PersonNameUpdateWithoutPersonInput, PersonNameUncheckedUpdateWithoutPersonInput>
  }

  export type PersonNameUpdateManyWithWhereWithoutPersonInput = {
    where: PersonNameScalarWhereInput
    data: XOR<PersonNameUpdateManyMutationInput, PersonNameUncheckedUpdateManyWithoutPersonInput>
  }

  export type PersonNameScalarWhereInput = {
    AND?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
    OR?: PersonNameScalarWhereInput[]
    NOT?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
    id?: StringFilter<"PersonName"> | string
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
  }

  export type EmailAddressUpsertWithWhereUniqueWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    update: XOR<EmailAddressUpdateWithoutPersonInput, EmailAddressUncheckedUpdateWithoutPersonInput>
    create: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput>
  }

  export type EmailAddressUpdateWithWhereUniqueWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    data: XOR<EmailAddressUpdateWithoutPersonInput, EmailAddressUncheckedUpdateWithoutPersonInput>
  }

  export type EmailAddressUpdateManyWithWhereWithoutPersonInput = {
    where: EmailAddressScalarWhereInput
    data: XOR<EmailAddressUpdateManyMutationInput, EmailAddressUncheckedUpdateManyWithoutPersonInput>
  }

  export type EmailAddressScalarWhereInput = {
    AND?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
    OR?: EmailAddressScalarWhereInput[]
    NOT?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
    id?: StringFilter<"EmailAddress"> | string
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
  }

  export type PhoneUpsertWithWhereUniqueWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    update: XOR<PhoneUpdateWithoutPersonInput, PhoneUncheckedUpdateWithoutPersonInput>
    create: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput>
  }

  export type PhoneUpdateWithWhereUniqueWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    data: XOR<PhoneUpdateWithoutPersonInput, PhoneUncheckedUpdateWithoutPersonInput>
  }

  export type PhoneUpdateManyWithWhereWithoutPersonInput = {
    where: PhoneScalarWhereInput
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyWithoutPersonInput>
  }

  export type PhoneScalarWhereInput = {
    AND?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
    OR?: PhoneScalarWhereInput[]
    NOT?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
    id?: StringFilter<"Phone"> | string
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutPersonInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutPersonInput, AddressUncheckedUpdateWithoutPersonInput>
    create: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutPersonInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutPersonInput, AddressUncheckedUpdateWithoutPersonInput>
  }

  export type AddressUpdateManyWithWhereWithoutPersonInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutPersonInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type StudentUpsertWithoutPersonInput = {
    update: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPersonInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type StudentUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionUpsertWithWhereUniqueWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutInstructorInput, SectionUncheckedUpdateWithoutInstructorInput>
    create: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutInstructorInput, SectionUncheckedUpdateWithoutInstructorInput>
  }

  export type SectionUpdateManyWithWhereWithoutInstructorInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutInstructorInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: StringFilter<"Section"> | string
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
  }

  export type PersonCreateWithoutNamesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateWithoutNamesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonCreateOrConnectWithoutNamesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
  }

  export type PersonUpsertWithoutNamesInput = {
    update: XOR<PersonUpdateWithoutNamesInput, PersonUncheckedUpdateWithoutNamesInput>
    create: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutNamesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutNamesInput, PersonUncheckedUpdateWithoutNamesInput>
  }

  export type PersonUpdateWithoutNamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateWithoutNamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type PersonCreateWithoutEmailsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateWithoutEmailsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonCreateOrConnectWithoutEmailsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
  }

  export type PersonUpsertWithoutEmailsInput = {
    update: XOR<PersonUpdateWithoutEmailsInput, PersonUncheckedUpdateWithoutEmailsInput>
    create: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutEmailsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutEmailsInput, PersonUncheckedUpdateWithoutEmailsInput>
  }

  export type PersonUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type PersonCreateWithoutPhonesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateWithoutPhonesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonCreateOrConnectWithoutPhonesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
  }

  export type PersonUpsertWithoutPhonesInput = {
    update: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutPhonesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type PersonCreateWithoutAddressesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateWithoutAddressesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonCreateOrConnectWithoutAddressesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
  }

  export type PersonUpsertWithoutAddressesInput = {
    update: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutAddressesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type PersonCreateWithoutStudentInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
  }

  export type PersonUncheckedCreateWithoutStudentInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type PersonCreateOrConnectWithoutStudentInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
  }

  export type AcademicPeriodCreateWithoutEntryStudentsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutEntryStudentsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutEntryStudentsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
  }

  export type SectionRegistrationCreateWithoutStudentInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type SectionRegistrationCreateManyStudentInputEnvelope = {
    data: SectionRegistrationCreateManyStudentInput | SectionRegistrationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicProgramCreateWithoutStudentInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    academicProgram: AcademicProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateWithoutStudentInput = {
    id?: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateOrConnectWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    create: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicProgramCreateManyStudentInputEnvelope = {
    data: StudentAcademicProgramCreateManyStudentInput | StudentAcademicProgramCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutStudentInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutStudentInput = {
    id?: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput>
  }

  export type AcademicCredentialCreateManyStudentInputEnvelope = {
    data: AcademicCredentialCreateManyStudentInput | AcademicCredentialCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutStudentInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutStudentInput = {
    id?: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentTranscriptGradeCreateManyStudentInputEnvelope = {
    data: StudentTranscriptGradeCreateManyStudentInput | StudentTranscriptGradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentRiskCreateWithoutStudentInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    academicPeriod: AcademicPeriodCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateWithoutStudentInput = {
    id?: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskCreateOrConnectWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    create: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput>
  }

  export type StudentRiskCreateManyStudentInputEnvelope = {
    data: StudentRiskCreateManyStudentInput | StudentRiskCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutStudentInput = {
    update: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutStudentInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type PersonUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
  }

  export type PersonUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type AcademicPeriodUpsertWithoutEntryStudentsInput = {
    update: XOR<AcademicPeriodUpdateWithoutEntryStudentsInput, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
    create: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutEntryStudentsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutEntryStudentsInput, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
  }

  export type AcademicPeriodUpdateWithoutEntryStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutStudentInput, SectionRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutStudentInput, SectionRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutStudentInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutStudentInput>
  }

  export type SectionRegistrationScalarWhereInput = {
    AND?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
    OR?: SectionRegistrationScalarWhereInput[]
    NOT?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
    id?: StringFilter<"SectionRegistration"> | string
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
  }

  export type StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    update: XOR<StudentAcademicProgramUpdateWithoutStudentInput, StudentAcademicProgramUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    data: XOR<StudentAcademicProgramUpdateWithoutStudentInput, StudentAcademicProgramUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAcademicProgramScalarWhereInput
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicProgramScalarWhereInput = {
    AND?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
    OR?: StudentAcademicProgramScalarWhereInput[]
    NOT?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
    id?: StringFilter<"StudentAcademicProgram"> | string
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutStudentInput, AcademicCredentialUncheckedUpdateWithoutStudentInput>
    create: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutStudentInput, AcademicCredentialUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutStudentInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutStudentInput>
  }

  export type AcademicCredentialScalarWhereInput = {
    AND?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
    OR?: AcademicCredentialScalarWhereInput[]
    NOT?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
    id?: StringFilter<"AcademicCredential"> | string
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutStudentInput, StudentTranscriptGradeUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutStudentInput, StudentTranscriptGradeUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentTranscriptGradeScalarWhereInput = {
    AND?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
    OR?: StudentTranscriptGradeScalarWhereInput[]
    NOT?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
    id?: StringFilter<"StudentTranscriptGrade"> | string
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
  }

  export type StudentRiskUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    update: XOR<StudentRiskUpdateWithoutStudentInput, StudentRiskUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput>
  }

  export type StudentRiskUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    data: XOR<StudentRiskUpdateWithoutStudentInput, StudentRiskUncheckedUpdateWithoutStudentInput>
  }

  export type StudentRiskUpdateManyWithWhereWithoutStudentInput = {
    where: StudentRiskScalarWhereInput
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentRiskScalarWhereInput = {
    AND?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
    OR?: StudentRiskScalarWhereInput[]
    NOT?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
    id?: StringFilter<"StudentRisk"> | string
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
  }

  export type SectionCreateWithoutAcademicPeriodInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    courseId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionCreateManyAcademicPeriodInputEnvelope = {
    data: SectionCreateManyAcademicPeriodInput | SectionCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type SectionRegistrationCreateWithoutAcademicPeriodInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationCreateManyAcademicPeriodInputEnvelope = {
    data: SectionRegistrationCreateManyAcademicPeriodInput | SectionRegistrationCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutAcademicPeriodInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope = {
    data: StudentTranscriptGradeCreateManyAcademicPeriodInput | StudentTranscriptGradeCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutEntryAcademicPeriodInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEntryAcademicPeriodInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput>
  }

  export type StudentCreateManyEntryAcademicPeriodInputEnvelope = {
    data: StudentCreateManyEntryAcademicPeriodInput | StudentCreateManyEntryAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutAcademicPeriodInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialCreateManyAcademicPeriodInputEnvelope = {
    data: AcademicCredentialCreateManyAcademicPeriodInput | AcademicCredentialCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentRiskCreateWithoutAcademicPeriodInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskCreateOrConnectWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    create: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentRiskCreateManyAcademicPeriodInputEnvelope = {
    data: StudentRiskCreateManyAcademicPeriodInput | StudentRiskCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutAcademicPeriodInput, SectionUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutAcademicPeriodInput, SectionUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type SectionUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutAcademicPeriodInput, SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutAcademicPeriodInput, SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutEntryAcademicPeriodInput, StudentUncheckedUpdateWithoutEntryAcademicPeriodInput>
    create: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutEntryAcademicPeriodInput, StudentUncheckedUpdateWithoutEntryAcademicPeriodInput>
  }

  export type StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutEntryAcademicPeriodInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    personId?: StringFilter<"Student"> | string
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    studentNumber?: StringFilter<"Student"> | string
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutAcademicPeriodInput, AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutAcademicPeriodInput, AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    update: XOR<StudentRiskUpdateWithoutAcademicPeriodInput, StudentRiskUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    data: XOR<StudentRiskUpdateWithoutAcademicPeriodInput, StudentRiskUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: StudentRiskScalarWhereInput
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type SectionCreateWithoutCourseInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCourseInput = {
    id?: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCourseInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput>
  }

  export type SectionCreateManyCourseInputEnvelope = {
    data: SectionCreateManyCourseInput | SectionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutCourseInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutCourseInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput>
  }

  export type StudentTranscriptGradeCreateManyCourseInputEnvelope = {
    data: StudentTranscriptGradeCreateManyCourseInput | StudentTranscriptGradeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutCourseInput, SectionUncheckedUpdateWithoutCourseInput>
    create: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutCourseInput, SectionUncheckedUpdateWithoutCourseInput>
  }

  export type SectionUpdateManyWithWhereWithoutCourseInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutCourseInput, StudentTranscriptGradeUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutCourseInput, StudentTranscriptGradeUncheckedUpdateWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutSectionsInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSectionsInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSectionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
  }

  export type AcademicPeriodCreateWithoutSectionsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutSectionsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutSectionsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
  }

  export type PersonCreateWithoutSectionsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutSectionsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutSectionsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
  }

  export type SectionRegistrationCreateWithoutSectionInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutSectionInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput>
  }

  export type SectionRegistrationCreateManySectionInputEnvelope = {
    data: SectionRegistrationCreateManySectionInput | SectionRegistrationCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutSectionInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutSectionInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput>
  }

  export type StudentTranscriptGradeCreateManySectionInputEnvelope = {
    data: StudentTranscriptGradeCreateManySectionInput | StudentTranscriptGradeCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutSectionsInput = {
    update: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSectionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type CourseUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicPeriodUpsertWithoutSectionsInput = {
    update: XOR<AcademicPeriodUpdateWithoutSectionsInput, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
    create: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutSectionsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutSectionsInput, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicPeriodUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type PersonUpsertWithoutSectionsInput = {
    update: XOR<PersonUpdateWithoutSectionsInput, PersonUncheckedUpdateWithoutSectionsInput>
    create: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutSectionsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutSectionsInput, PersonUncheckedUpdateWithoutSectionsInput>
  }

  export type PersonUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutSectionInput, SectionRegistrationUncheckedUpdateWithoutSectionInput>
    create: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutSectionInput, SectionRegistrationUncheckedUpdateWithoutSectionInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutSectionInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutSectionInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionInput>
    create: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutSectionInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentCreateWithoutSectionRegistrationsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSectionRegistrationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type SectionCreateWithoutSectionRegistrationsInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutSectionRegistrationsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodCreateWithoutSectionRegistrationsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type StudentTranscriptGradeCreateWithoutSectionRegistrationInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
  }

  export type StudentUpsertWithoutSectionRegistrationsInput = {
    update: XOR<StudentUpdateWithoutSectionRegistrationsInput, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSectionRegistrationsInput, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type StudentUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionUpsertWithoutSectionRegistrationsInput = {
    update: XOR<SectionUpdateWithoutSectionRegistrationsInput, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutSectionRegistrationsInput, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type SectionUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type AcademicPeriodUpsertWithoutSectionRegistrationsInput = {
    update: XOR<AcademicPeriodUpdateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type StudentTranscriptGradeUpsertWithoutSectionRegistrationInput = {
    update: XOR<StudentTranscriptGradeUpdateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
    create: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    where?: StudentTranscriptGradeWhereInput
  }

  export type StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput = {
    where?: StudentTranscriptGradeWhereInput
    data: XOR<StudentTranscriptGradeUpdateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentTranscriptGradeUpdateWithoutSectionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutTranscriptGradesInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTranscriptGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type SectionRegistrationCreateWithoutTranscriptGradeInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
  }

  export type SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
  }

  export type SectionCreateWithoutTranscriptGradesInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTranscriptGradesInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodCreateWithoutTranscriptGradesInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type CourseCreateWithoutTranscriptGradesInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTranscriptGradesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type StudentUpsertWithoutTranscriptGradesInput = {
    update: XOR<StudentUpdateWithoutTranscriptGradesInput, StudentUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTranscriptGradesInput, StudentUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type StudentUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionRegistrationUpsertWithoutTranscriptGradeInput = {
    update: XOR<SectionRegistrationUpdateWithoutTranscriptGradeInput, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
    create: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    where?: SectionRegistrationWhereInput
  }

  export type SectionRegistrationUpdateToOneWithWhereWithoutTranscriptGradeInput = {
    where?: SectionRegistrationWhereInput
    data: XOR<SectionRegistrationUpdateWithoutTranscriptGradeInput, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
  }

  export type SectionRegistrationUpdateWithoutTranscriptGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpsertWithoutTranscriptGradesInput = {
    update: XOR<SectionUpdateWithoutTranscriptGradesInput, SectionUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTranscriptGradesInput, SectionUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type SectionUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type AcademicPeriodUpsertWithoutTranscriptGradesInput = {
    update: XOR<AcademicPeriodUpdateWithoutTranscriptGradesInput, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutTranscriptGradesInput, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type CourseUpsertWithoutTranscriptGradesInput = {
    update: XOR<CourseUpdateWithoutTranscriptGradesInput, CourseUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTranscriptGradesInput, CourseUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type CourseUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentAcademicProgramCreateWithoutAcademicProgramInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAcademicProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput = {
    id?: string
    studentId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    create: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramCreateManyAcademicProgramInputEnvelope = {
    data: StudentAcademicProgramCreateManyAcademicProgramInput | StudentAcademicProgramCreateManyAcademicProgramInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutAcademicProgramInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutAcademicProgramInput = {
    id?: string
    studentId: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialCreateManyAcademicProgramInputEnvelope = {
    data: AcademicCredentialCreateManyAcademicProgramInput | AcademicCredentialCreateManyAcademicProgramInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    update: XOR<StudentAcademicProgramUpdateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput>
    create: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    data: XOR<StudentAcademicProgramUpdateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput = {
    where: StudentAcademicProgramScalarWhereInput
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutAcademicProgramInput, AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput>
    create: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutAcademicProgramInput, AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramInput>
  }

  export type StudentCreateWithoutStudentAcademicProgramsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAcademicProgramsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAcademicProgramsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
  }

  export type AcademicProgramCreateWithoutStudentProgramsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credentials?: AcademicCredentialCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateWithoutStudentProgramsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credentials?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramCreateOrConnectWithoutStudentProgramsInput = {
    where: AcademicProgramWhereUniqueInput
    create: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
  }

  export type StudentUpsertWithoutStudentAcademicProgramsInput = {
    update: XOR<StudentUpdateWithoutStudentAcademicProgramsInput, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
    create: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAcademicProgramsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAcademicProgramsInput, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
  }

  export type StudentUpdateWithoutStudentAcademicProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAcademicProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicProgramUpsertWithoutStudentProgramsInput = {
    update: XOR<AcademicProgramUpdateWithoutStudentProgramsInput, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
    create: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    where?: AcademicProgramWhereInput
  }

  export type AcademicProgramUpdateToOneWithWhereWithoutStudentProgramsInput = {
    where?: AcademicProgramWhereInput
    data: XOR<AcademicProgramUpdateWithoutStudentProgramsInput, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type AcademicProgramUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentials?: AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentials?: AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type StudentCreateWithoutAcademicCredentialsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicCredentialsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicCredentialsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
  }

  export type AcademicProgramCreateWithoutCredentialsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateWithoutCredentialsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramCreateOrConnectWithoutCredentialsInput = {
    where: AcademicProgramWhereUniqueInput
    create: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
  }

  export type AcademicPeriodCreateWithoutCredentialPeriodsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
  }

  export type StudentUpsertWithoutAcademicCredentialsInput = {
    update: XOR<StudentUpdateWithoutAcademicCredentialsInput, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
    create: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicCredentialsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicCredentialsInput, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
  }

  export type StudentUpdateWithoutAcademicCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicProgramUpsertWithoutCredentialsInput = {
    update: XOR<AcademicProgramUpdateWithoutCredentialsInput, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
    create: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    where?: AcademicProgramWhereInput
  }

  export type AcademicProgramUpdateToOneWithWhereWithoutCredentialsInput = {
    where?: AcademicProgramWhereInput
    data: XOR<AcademicProgramUpdateWithoutCredentialsInput, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
  }

  export type AcademicProgramUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicPeriodUpsertWithoutCredentialPeriodsInput = {
    update: XOR<AcademicPeriodUpdateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
    create: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutCredentialPeriodsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
  }

  export type AcademicPeriodUpdateWithoutCredentialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type StudentCreateWithoutStudentRisksInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentRisksInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentRisksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
  }

  export type AcademicPeriodCreateWithoutStudentRisksInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutStudentRisksInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutStudentRisksInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
  }

  export type StudentUpsertWithoutStudentRisksInput = {
    update: XOR<StudentUpdateWithoutStudentRisksInput, StudentUncheckedUpdateWithoutStudentRisksInput>
    create: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentRisksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentRisksInput, StudentUncheckedUpdateWithoutStudentRisksInput>
  }

  export type StudentUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicPeriodUpsertWithoutStudentRisksInput = {
    update: XOR<AcademicPeriodUpdateWithoutStudentRisksInput, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
    create: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutStudentRisksInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutStudentRisksInput, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
  }

  export type AcademicPeriodUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type PersonNameCreateManyPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressCreateManyPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneCreateManyPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionCreateManyInstructorInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationCreateManyStudentInput = {
    id?: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateManyStudentInput = {
    id?: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyStudentInput = {
    id?: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyStudentInput = {
    id?: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentRiskCreateManyStudentInput = {
    id?: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicProgram?: AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyAcademicPeriodInput = {
    id?: string
    courseId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyEntryAcademicPeriodInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentRiskCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyCourseInput = {
    id?: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyCourseInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationCreateManySectionInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManySectionInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateManyAcademicProgramInput = {
    id?: string
    studentId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyAcademicProgramInput = {
    id?: string
    studentId: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
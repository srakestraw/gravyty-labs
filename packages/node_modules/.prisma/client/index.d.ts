
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model PersonName
 * 
 */
export type PersonName = $Result.DefaultSelection<Prisma.$PersonNamePayload>
/**
 * Model EmailAddress
 * 
 */
export type EmailAddress = $Result.DefaultSelection<Prisma.$EmailAddressPayload>
/**
 * Model Phone
 * 
 */
export type Phone = $Result.DefaultSelection<Prisma.$PhonePayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model DoNotEngageGlobal
 * 
 */
export type DoNotEngageGlobal = $Result.DefaultSelection<Prisma.$DoNotEngageGlobalPayload>
/**
 * Model DoNotEngageAgent
 * 
 */
export type DoNotEngageAgent = $Result.DefaultSelection<Prisma.$DoNotEngageAgentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model AcademicPeriod
 * 
 */
export type AcademicPeriod = $Result.DefaultSelection<Prisma.$AcademicPeriodPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model SectionRegistration
 * 
 */
export type SectionRegistration = $Result.DefaultSelection<Prisma.$SectionRegistrationPayload>
/**
 * Model StudentTranscriptGrade
 * 
 */
export type StudentTranscriptGrade = $Result.DefaultSelection<Prisma.$StudentTranscriptGradePayload>
/**
 * Model AcademicProgram
 * 
 */
export type AcademicProgram = $Result.DefaultSelection<Prisma.$AcademicProgramPayload>
/**
 * Model StudentAcademicProgram
 * 
 */
export type StudentAcademicProgram = $Result.DefaultSelection<Prisma.$StudentAcademicProgramPayload>
/**
 * Model AcademicCredential
 * 
 */
export type AcademicCredential = $Result.DefaultSelection<Prisma.$AcademicCredentialPayload>
/**
 * Model StudentRisk
 * 
 */
export type StudentRisk = $Result.DefaultSelection<Prisma.$StudentRiskPayload>
/**
 * Model SimulationState
 * 
 */
export type SimulationState = $Result.DefaultSelection<Prisma.$SimulationStatePayload>
/**
 * Model CrmContact
 * 
 */
export type CrmContact = $Result.DefaultSelection<Prisma.$CrmContactPayload>
/**
 * Model CrmAccount
 * 
 */
export type CrmAccount = $Result.DefaultSelection<Prisma.$CrmAccountPayload>
/**
 * Model CrmOpportunity
 * 
 */
export type CrmOpportunity = $Result.DefaultSelection<Prisma.$CrmOpportunityPayload>
/**
 * Model CrmActivity
 * 
 */
export type CrmActivity = $Result.DefaultSelection<Prisma.$CrmActivityPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RiskBucket: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type RiskBucket = (typeof RiskBucket)[keyof typeof RiskBucket]

}

export type RiskBucket = $Enums.RiskBucket

export const RiskBucket: typeof $Enums.RiskBucket

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more People
 * const people = await prisma.person.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more People
   * const people = await prisma.person.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs>;

  /**
   * `prisma.personName`: Exposes CRUD operations for the **PersonName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonNames
    * const personNames = await prisma.personName.findMany()
    * ```
    */
  get personName(): Prisma.PersonNameDelegate<ExtArgs>;

  /**
   * `prisma.emailAddress`: Exposes CRUD operations for the **EmailAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAddresses
    * const emailAddresses = await prisma.emailAddress.findMany()
    * ```
    */
  get emailAddress(): Prisma.EmailAddressDelegate<ExtArgs>;

  /**
   * `prisma.phone`: Exposes CRUD operations for the **Phone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phones
    * const phones = await prisma.phone.findMany()
    * ```
    */
  get phone(): Prisma.PhoneDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.doNotEngageGlobal`: Exposes CRUD operations for the **DoNotEngageGlobal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoNotEngageGlobals
    * const doNotEngageGlobals = await prisma.doNotEngageGlobal.findMany()
    * ```
    */
  get doNotEngageGlobal(): Prisma.DoNotEngageGlobalDelegate<ExtArgs>;

  /**
   * `prisma.doNotEngageAgent`: Exposes CRUD operations for the **DoNotEngageAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoNotEngageAgents
    * const doNotEngageAgents = await prisma.doNotEngageAgent.findMany()
    * ```
    */
  get doNotEngageAgent(): Prisma.DoNotEngageAgentDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.academicPeriod`: Exposes CRUD operations for the **AcademicPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPeriods
    * const academicPeriods = await prisma.academicPeriod.findMany()
    * ```
    */
  get academicPeriod(): Prisma.AcademicPeriodDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs>;

  /**
   * `prisma.sectionRegistration`: Exposes CRUD operations for the **SectionRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectionRegistrations
    * const sectionRegistrations = await prisma.sectionRegistration.findMany()
    * ```
    */
  get sectionRegistration(): Prisma.SectionRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.studentTranscriptGrade`: Exposes CRUD operations for the **StudentTranscriptGrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTranscriptGrades
    * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany()
    * ```
    */
  get studentTranscriptGrade(): Prisma.StudentTranscriptGradeDelegate<ExtArgs>;

  /**
   * `prisma.academicProgram`: Exposes CRUD operations for the **AcademicProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPrograms
    * const academicPrograms = await prisma.academicProgram.findMany()
    * ```
    */
  get academicProgram(): Prisma.AcademicProgramDelegate<ExtArgs>;

  /**
   * `prisma.studentAcademicProgram`: Exposes CRUD operations for the **StudentAcademicProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAcademicPrograms
    * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany()
    * ```
    */
  get studentAcademicProgram(): Prisma.StudentAcademicProgramDelegate<ExtArgs>;

  /**
   * `prisma.academicCredential`: Exposes CRUD operations for the **AcademicCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicCredentials
    * const academicCredentials = await prisma.academicCredential.findMany()
    * ```
    */
  get academicCredential(): Prisma.AcademicCredentialDelegate<ExtArgs>;

  /**
   * `prisma.studentRisk`: Exposes CRUD operations for the **StudentRisk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentRisks
    * const studentRisks = await prisma.studentRisk.findMany()
    * ```
    */
  get studentRisk(): Prisma.StudentRiskDelegate<ExtArgs>;

  /**
   * `prisma.simulationState`: Exposes CRUD operations for the **SimulationState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationStates
    * const simulationStates = await prisma.simulationState.findMany()
    * ```
    */
  get simulationState(): Prisma.SimulationStateDelegate<ExtArgs>;

  /**
   * `prisma.crmContact`: Exposes CRUD operations for the **CrmContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmContacts
    * const crmContacts = await prisma.crmContact.findMany()
    * ```
    */
  get crmContact(): Prisma.CrmContactDelegate<ExtArgs>;

  /**
   * `prisma.crmAccount`: Exposes CRUD operations for the **CrmAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmAccounts
    * const crmAccounts = await prisma.crmAccount.findMany()
    * ```
    */
  get crmAccount(): Prisma.CrmAccountDelegate<ExtArgs>;

  /**
   * `prisma.crmOpportunity`: Exposes CRUD operations for the **CrmOpportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmOpportunities
    * const crmOpportunities = await prisma.crmOpportunity.findMany()
    * ```
    */
  get crmOpportunity(): Prisma.CrmOpportunityDelegate<ExtArgs>;

  /**
   * `prisma.crmActivity`: Exposes CRUD operations for the **CrmActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrmActivities
    * const crmActivities = await prisma.crmActivity.findMany()
    * ```
    */
  get crmActivity(): Prisma.CrmActivityDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Person: 'Person',
    PersonName: 'PersonName',
    EmailAddress: 'EmailAddress',
    Phone: 'Phone',
    Address: 'Address',
    DoNotEngageGlobal: 'DoNotEngageGlobal',
    DoNotEngageAgent: 'DoNotEngageAgent',
    Student: 'Student',
    AcademicPeriod: 'AcademicPeriod',
    Course: 'Course',
    Section: 'Section',
    SectionRegistration: 'SectionRegistration',
    StudentTranscriptGrade: 'StudentTranscriptGrade',
    AcademicProgram: 'AcademicProgram',
    StudentAcademicProgram: 'StudentAcademicProgram',
    AcademicCredential: 'AcademicCredential',
    StudentRisk: 'StudentRisk',
    SimulationState: 'SimulationState',
    CrmContact: 'CrmContact',
    CrmAccount: 'CrmAccount',
    CrmOpportunity: 'CrmOpportunity',
    CrmActivity: 'CrmActivity'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "person" | "personName" | "emailAddress" | "phone" | "address" | "doNotEngageGlobal" | "doNotEngageAgent" | "student" | "academicPeriod" | "course" | "section" | "sectionRegistration" | "studentTranscriptGrade" | "academicProgram" | "studentAcademicProgram" | "academicCredential" | "studentRisk" | "simulationState" | "crmContact" | "crmAccount" | "crmOpportunity" | "crmActivity"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      PersonName: {
        payload: Prisma.$PersonNamePayload<ExtArgs>
        fields: Prisma.PersonNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          findFirst: {
            args: Prisma.PersonNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          findMany: {
            args: Prisma.PersonNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>[]
          }
          create: {
            args: Prisma.PersonNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          createMany: {
            args: Prisma.PersonNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>[]
          }
          delete: {
            args: Prisma.PersonNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          update: {
            args: Prisma.PersonNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          deleteMany: {
            args: Prisma.PersonNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonNamePayload>
          }
          aggregate: {
            args: Prisma.PersonNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonName>
          }
          groupBy: {
            args: Prisma.PersonNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonNameCountArgs<ExtArgs>
            result: $Utils.Optional<PersonNameCountAggregateOutputType> | number
          }
        }
      }
      EmailAddress: {
        payload: Prisma.$EmailAddressPayload<ExtArgs>
        fields: Prisma.EmailAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          findFirst: {
            args: Prisma.EmailAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          findMany: {
            args: Prisma.EmailAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>[]
          }
          create: {
            args: Prisma.EmailAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          createMany: {
            args: Prisma.EmailAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>[]
          }
          delete: {
            args: Prisma.EmailAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          update: {
            args: Prisma.EmailAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          deleteMany: {
            args: Prisma.EmailAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAddressPayload>
          }
          aggregate: {
            args: Prisma.EmailAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAddress>
          }
          groupBy: {
            args: Prisma.EmailAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAddressCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAddressCountAggregateOutputType> | number
          }
        }
      }
      Phone: {
        payload: Prisma.$PhonePayload<ExtArgs>
        fields: Prisma.PhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          findFirst: {
            args: Prisma.PhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          findMany: {
            args: Prisma.PhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>[]
          }
          create: {
            args: Prisma.PhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          createMany: {
            args: Prisma.PhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>[]
          }
          delete: {
            args: Prisma.PhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          update: {
            args: Prisma.PhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          deleteMany: {
            args: Prisma.PhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhonePayload>
          }
          aggregate: {
            args: Prisma.PhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhone>
          }
          groupBy: {
            args: Prisma.PhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      DoNotEngageGlobal: {
        payload: Prisma.$DoNotEngageGlobalPayload<ExtArgs>
        fields: Prisma.DoNotEngageGlobalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoNotEngageGlobalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoNotEngageGlobalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          findFirst: {
            args: Prisma.DoNotEngageGlobalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoNotEngageGlobalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          findMany: {
            args: Prisma.DoNotEngageGlobalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>[]
          }
          create: {
            args: Prisma.DoNotEngageGlobalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          createMany: {
            args: Prisma.DoNotEngageGlobalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoNotEngageGlobalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>[]
          }
          delete: {
            args: Prisma.DoNotEngageGlobalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          update: {
            args: Prisma.DoNotEngageGlobalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          deleteMany: {
            args: Prisma.DoNotEngageGlobalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoNotEngageGlobalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoNotEngageGlobalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageGlobalPayload>
          }
          aggregate: {
            args: Prisma.DoNotEngageGlobalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoNotEngageGlobal>
          }
          groupBy: {
            args: Prisma.DoNotEngageGlobalGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoNotEngageGlobalGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoNotEngageGlobalCountArgs<ExtArgs>
            result: $Utils.Optional<DoNotEngageGlobalCountAggregateOutputType> | number
          }
        }
      }
      DoNotEngageAgent: {
        payload: Prisma.$DoNotEngageAgentPayload<ExtArgs>
        fields: Prisma.DoNotEngageAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoNotEngageAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoNotEngageAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          findFirst: {
            args: Prisma.DoNotEngageAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoNotEngageAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          findMany: {
            args: Prisma.DoNotEngageAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>[]
          }
          create: {
            args: Prisma.DoNotEngageAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          createMany: {
            args: Prisma.DoNotEngageAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoNotEngageAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>[]
          }
          delete: {
            args: Prisma.DoNotEngageAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          update: {
            args: Prisma.DoNotEngageAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          deleteMany: {
            args: Prisma.DoNotEngageAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoNotEngageAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoNotEngageAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoNotEngageAgentPayload>
          }
          aggregate: {
            args: Prisma.DoNotEngageAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoNotEngageAgent>
          }
          groupBy: {
            args: Prisma.DoNotEngageAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoNotEngageAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoNotEngageAgentCountArgs<ExtArgs>
            result: $Utils.Optional<DoNotEngageAgentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      AcademicPeriod: {
        payload: Prisma.$AcademicPeriodPayload<ExtArgs>
        fields: Prisma.AcademicPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findFirst: {
            args: Prisma.AcademicPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          findMany: {
            args: Prisma.AcademicPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          create: {
            args: Prisma.AcademicPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          createMany: {
            args: Prisma.AcademicPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>[]
          }
          delete: {
            args: Prisma.AcademicPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          update: {
            args: Prisma.AcademicPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          deleteMany: {
            args: Prisma.AcademicPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPeriodPayload>
          }
          aggregate: {
            args: Prisma.AcademicPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicPeriod>
          }
          groupBy: {
            args: Prisma.AcademicPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicPeriodCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      SectionRegistration: {
        payload: Prisma.$SectionRegistrationPayload<ExtArgs>
        fields: Prisma.SectionRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          findFirst: {
            args: Prisma.SectionRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          findMany: {
            args: Prisma.SectionRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>[]
          }
          create: {
            args: Prisma.SectionRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          createMany: {
            args: Prisma.SectionRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>[]
          }
          delete: {
            args: Prisma.SectionRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          update: {
            args: Prisma.SectionRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.SectionRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionRegistrationPayload>
          }
          aggregate: {
            args: Prisma.SectionRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectionRegistration>
          }
          groupBy: {
            args: Prisma.SectionRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<SectionRegistrationCountAggregateOutputType> | number
          }
        }
      }
      StudentTranscriptGrade: {
        payload: Prisma.$StudentTranscriptGradePayload<ExtArgs>
        fields: Prisma.StudentTranscriptGradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTranscriptGradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          findFirst: {
            args: Prisma.StudentTranscriptGradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          findMany: {
            args: Prisma.StudentTranscriptGradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>[]
          }
          create: {
            args: Prisma.StudentTranscriptGradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          createMany: {
            args: Prisma.StudentTranscriptGradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>[]
          }
          delete: {
            args: Prisma.StudentTranscriptGradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          update: {
            args: Prisma.StudentTranscriptGradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          deleteMany: {
            args: Prisma.StudentTranscriptGradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTranscriptGradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentTranscriptGradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTranscriptGradePayload>
          }
          aggregate: {
            args: Prisma.StudentTranscriptGradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTranscriptGrade>
          }
          groupBy: {
            args: Prisma.StudentTranscriptGradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTranscriptGradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTranscriptGradeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTranscriptGradeCountAggregateOutputType> | number
          }
        }
      }
      AcademicProgram: {
        payload: Prisma.$AcademicProgramPayload<ExtArgs>
        fields: Prisma.AcademicProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          findFirst: {
            args: Prisma.AcademicProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          findMany: {
            args: Prisma.AcademicProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>[]
          }
          create: {
            args: Prisma.AcademicProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          createMany: {
            args: Prisma.AcademicProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>[]
          }
          delete: {
            args: Prisma.AcademicProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          update: {
            args: Prisma.AcademicProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          deleteMany: {
            args: Prisma.AcademicProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicProgramPayload>
          }
          aggregate: {
            args: Prisma.AcademicProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicProgram>
          }
          groupBy: {
            args: Prisma.AcademicProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicProgramCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicProgramCountAggregateOutputType> | number
          }
        }
      }
      StudentAcademicProgram: {
        payload: Prisma.$StudentAcademicProgramPayload<ExtArgs>
        fields: Prisma.StudentAcademicProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAcademicProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          findFirst: {
            args: Prisma.StudentAcademicProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          findMany: {
            args: Prisma.StudentAcademicProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>[]
          }
          create: {
            args: Prisma.StudentAcademicProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          createMany: {
            args: Prisma.StudentAcademicProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>[]
          }
          delete: {
            args: Prisma.StudentAcademicProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          update: {
            args: Prisma.StudentAcademicProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          deleteMany: {
            args: Prisma.StudentAcademicProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAcademicProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAcademicProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicProgramPayload>
          }
          aggregate: {
            args: Prisma.StudentAcademicProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAcademicProgram>
          }
          groupBy: {
            args: Prisma.StudentAcademicProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAcademicProgramCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicProgramCountAggregateOutputType> | number
          }
        }
      }
      AcademicCredential: {
        payload: Prisma.$AcademicCredentialPayload<ExtArgs>
        fields: Prisma.AcademicCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          findFirst: {
            args: Prisma.AcademicCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          findMany: {
            args: Prisma.AcademicCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>[]
          }
          create: {
            args: Prisma.AcademicCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          createMany: {
            args: Prisma.AcademicCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>[]
          }
          delete: {
            args: Prisma.AcademicCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          update: {
            args: Prisma.AcademicCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          deleteMany: {
            args: Prisma.AcademicCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicCredentialPayload>
          }
          aggregate: {
            args: Prisma.AcademicCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicCredential>
          }
          groupBy: {
            args: Prisma.AcademicCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicCredentialCountAggregateOutputType> | number
          }
        }
      }
      StudentRisk: {
        payload: Prisma.$StudentRiskPayload<ExtArgs>
        fields: Prisma.StudentRiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentRiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentRiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          findFirst: {
            args: Prisma.StudentRiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentRiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          findMany: {
            args: Prisma.StudentRiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>[]
          }
          create: {
            args: Prisma.StudentRiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          createMany: {
            args: Prisma.StudentRiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentRiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>[]
          }
          delete: {
            args: Prisma.StudentRiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          update: {
            args: Prisma.StudentRiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          deleteMany: {
            args: Prisma.StudentRiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentRiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentRiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRiskPayload>
          }
          aggregate: {
            args: Prisma.StudentRiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentRisk>
          }
          groupBy: {
            args: Prisma.StudentRiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentRiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentRiskCountArgs<ExtArgs>
            result: $Utils.Optional<StudentRiskCountAggregateOutputType> | number
          }
        }
      }
      SimulationState: {
        payload: Prisma.$SimulationStatePayload<ExtArgs>
        fields: Prisma.SimulationStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          findFirst: {
            args: Prisma.SimulationStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          findMany: {
            args: Prisma.SimulationStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
          }
          create: {
            args: Prisma.SimulationStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          createMany: {
            args: Prisma.SimulationStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
          }
          delete: {
            args: Prisma.SimulationStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          update: {
            args: Prisma.SimulationStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          deleteMany: {
            args: Prisma.SimulationStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimulationStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStatePayload>
          }
          aggregate: {
            args: Prisma.SimulationStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationState>
          }
          groupBy: {
            args: Prisma.SimulationStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationStateCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationStateCountAggregateOutputType> | number
          }
        }
      }
      CrmContact: {
        payload: Prisma.$CrmContactPayload<ExtArgs>
        fields: Prisma.CrmContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findFirst: {
            args: Prisma.CrmContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          findMany: {
            args: Prisma.CrmContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          create: {
            args: Prisma.CrmContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          createMany: {
            args: Prisma.CrmContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>[]
          }
          delete: {
            args: Prisma.CrmContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          update: {
            args: Prisma.CrmContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          deleteMany: {
            args: Prisma.CrmContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrmContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmContactPayload>
          }
          aggregate: {
            args: Prisma.CrmContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmContact>
          }
          groupBy: {
            args: Prisma.CrmContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmContactCountArgs<ExtArgs>
            result: $Utils.Optional<CrmContactCountAggregateOutputType> | number
          }
        }
      }
      CrmAccount: {
        payload: Prisma.$CrmAccountPayload<ExtArgs>
        fields: Prisma.CrmAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          findFirst: {
            args: Prisma.CrmAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          findMany: {
            args: Prisma.CrmAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>[]
          }
          create: {
            args: Prisma.CrmAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          createMany: {
            args: Prisma.CrmAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>[]
          }
          delete: {
            args: Prisma.CrmAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          update: {
            args: Prisma.CrmAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          deleteMany: {
            args: Prisma.CrmAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrmAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmAccountPayload>
          }
          aggregate: {
            args: Prisma.CrmAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmAccount>
          }
          groupBy: {
            args: Prisma.CrmAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmAccountCountArgs<ExtArgs>
            result: $Utils.Optional<CrmAccountCountAggregateOutputType> | number
          }
        }
      }
      CrmOpportunity: {
        payload: Prisma.$CrmOpportunityPayload<ExtArgs>
        fields: Prisma.CrmOpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmOpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmOpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          findFirst: {
            args: Prisma.CrmOpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmOpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          findMany: {
            args: Prisma.CrmOpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>[]
          }
          create: {
            args: Prisma.CrmOpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          createMany: {
            args: Prisma.CrmOpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmOpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>[]
          }
          delete: {
            args: Prisma.CrmOpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          update: {
            args: Prisma.CrmOpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          deleteMany: {
            args: Prisma.CrmOpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmOpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrmOpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmOpportunityPayload>
          }
          aggregate: {
            args: Prisma.CrmOpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmOpportunity>
          }
          groupBy: {
            args: Prisma.CrmOpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmOpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmOpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<CrmOpportunityCountAggregateOutputType> | number
          }
        }
      }
      CrmActivity: {
        payload: Prisma.$CrmActivityPayload<ExtArgs>
        fields: Prisma.CrmActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrmActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrmActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          findFirst: {
            args: Prisma.CrmActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrmActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          findMany: {
            args: Prisma.CrmActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>[]
          }
          create: {
            args: Prisma.CrmActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          createMany: {
            args: Prisma.CrmActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrmActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>[]
          }
          delete: {
            args: Prisma.CrmActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          update: {
            args: Prisma.CrmActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          deleteMany: {
            args: Prisma.CrmActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrmActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrmActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrmActivityPayload>
          }
          aggregate: {
            args: Prisma.CrmActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrmActivity>
          }
          groupBy: {
            args: Prisma.CrmActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrmActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrmActivityCountArgs<ExtArgs>
            result: $Utils.Optional<CrmActivityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    names: number
    emails: number
    phones: number
    addresses: number
    sections: number
    doNotEngageAgents: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    names?: boolean | PersonCountOutputTypeCountNamesArgs
    emails?: boolean | PersonCountOutputTypeCountEmailsArgs
    phones?: boolean | PersonCountOutputTypeCountPhonesArgs
    addresses?: boolean | PersonCountOutputTypeCountAddressesArgs
    sections?: boolean | PersonCountOutputTypeCountSectionsArgs
    doNotEngageAgents?: boolean | PersonCountOutputTypeCountDoNotEngageAgentsArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonNameWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAddressWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountDoNotEngageAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoNotEngageAgentWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    sectionRegistrations: number
    studentAcademicPrograms: number
    academicCredentials: number
    transcriptGrades: number
    studentRisks: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sectionRegistrations?: boolean | StudentCountOutputTypeCountSectionRegistrationsArgs
    studentAcademicPrograms?: boolean | StudentCountOutputTypeCountStudentAcademicProgramsArgs
    academicCredentials?: boolean | StudentCountOutputTypeCountAcademicCredentialsArgs
    transcriptGrades?: boolean | StudentCountOutputTypeCountTranscriptGradesArgs
    studentRisks?: boolean | StudentCountOutputTypeCountStudentRisksArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAcademicProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAcademicCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
  }


  /**
   * Count Type AcademicPeriodCountOutputType
   */

  export type AcademicPeriodCountOutputType = {
    sections: number
    sectionRegistrations: number
    transcriptGrades: number
    entryStudents: number
    credentialPeriods: number
    studentRisks: number
  }

  export type AcademicPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicPeriodCountOutputTypeCountSectionsArgs
    sectionRegistrations?: boolean | AcademicPeriodCountOutputTypeCountSectionRegistrationsArgs
    transcriptGrades?: boolean | AcademicPeriodCountOutputTypeCountTranscriptGradesArgs
    entryStudents?: boolean | AcademicPeriodCountOutputTypeCountEntryStudentsArgs
    credentialPeriods?: boolean | AcademicPeriodCountOutputTypeCountCredentialPeriodsArgs
    studentRisks?: boolean | AcademicPeriodCountOutputTypeCountStudentRisksArgs
  }

  // Custom InputTypes
  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriodCountOutputType
     */
    select?: AcademicPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountEntryStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountCredentialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }

  /**
   * AcademicPeriodCountOutputType without action
   */
  export type AcademicPeriodCountOutputTypeCountStudentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    sections: number
    transcriptGrades: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | CourseCountOutputTypeCountSectionsArgs
    transcriptGrades?: boolean | CourseCountOutputTypeCountTranscriptGradesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    sectionRegistrations: number
    transcriptGrades: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sectionRegistrations?: boolean | SectionCountOutputTypeCountSectionRegistrationsArgs
    transcriptGrades?: boolean | SectionCountOutputTypeCountTranscriptGradesArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountSectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTranscriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
  }


  /**
   * Count Type AcademicProgramCountOutputType
   */

  export type AcademicProgramCountOutputType = {
    studentPrograms: number
    credentials: number
  }

  export type AcademicProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPrograms?: boolean | AcademicProgramCountOutputTypeCountStudentProgramsArgs
    credentials?: boolean | AcademicProgramCountOutputTypeCountCredentialsArgs
  }

  // Custom InputTypes
  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgramCountOutputType
     */
    select?: AcademicProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeCountStudentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * AcademicProgramCountOutputType without action
   */
  export type AcademicProgramCountOutputTypeCountCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
  }


  /**
   * Count Type CrmContactCountOutputType
   */

  export type CrmContactCountOutputType = {
    opportunities: number
    activities: number
  }

  export type CrmContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | CrmContactCountOutputTypeCountOpportunitiesArgs
    activities?: boolean | CrmContactCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * CrmContactCountOutputType without action
   */
  export type CrmContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContactCountOutputType
     */
    select?: CrmContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrmContactCountOutputType without action
   */
  export type CrmContactCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmOpportunityWhereInput
  }

  /**
   * CrmContactCountOutputType without action
   */
  export type CrmContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmActivityWhereInput
  }


  /**
   * Count Type CrmAccountCountOutputType
   */

  export type CrmAccountCountOutputType = {
    opportunities: number
    activities: number
  }

  export type CrmAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | CrmAccountCountOutputTypeCountOpportunitiesArgs
    activities?: boolean | CrmAccountCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * CrmAccountCountOutputType without action
   */
  export type CrmAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccountCountOutputType
     */
    select?: CrmAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrmAccountCountOutputType without action
   */
  export type CrmAccountCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmOpportunityWhereInput
  }

  /**
   * CrmAccountCountOutputType without action
   */
  export type CrmAccountCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmActivityWhereInput
  }


  /**
   * Count Type CrmOpportunityCountOutputType
   */

  export type CrmOpportunityCountOutputType = {
    activities: number
  }

  export type CrmOpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | CrmOpportunityCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * CrmOpportunityCountOutputType without action
   */
  export type CrmOpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunityCountOutputType
     */
    select?: CrmOpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrmOpportunityCountOutputType without action
   */
  export type CrmOpportunityCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmActivityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    birthDate: number
    gender: number
    citizenshipStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    birthDate?: true
    gender?: true
    citizenshipStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    birthDate: Date | null
    gender: string | null
    citizenshipStatus: string | null
    createdAt: Date
    updatedAt: Date
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    names?: boolean | Person$namesArgs<ExtArgs>
    emails?: boolean | Person$emailsArgs<ExtArgs>
    phones?: boolean | Person$phonesArgs<ExtArgs>
    addresses?: boolean | Person$addressesArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    sections?: boolean | Person$sectionsArgs<ExtArgs>
    doNotEngageGlobal?: boolean | Person$doNotEngageGlobalArgs<ExtArgs>
    doNotEngageAgents?: boolean | Person$doNotEngageAgentsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    birthDate?: boolean
    gender?: boolean
    citizenshipStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    names?: boolean | Person$namesArgs<ExtArgs>
    emails?: boolean | Person$emailsArgs<ExtArgs>
    phones?: boolean | Person$phonesArgs<ExtArgs>
    addresses?: boolean | Person$addressesArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    sections?: boolean | Person$sectionsArgs<ExtArgs>
    doNotEngageGlobal?: boolean | Person$doNotEngageGlobalArgs<ExtArgs>
    doNotEngageAgents?: boolean | Person$doNotEngageAgentsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      names: Prisma.$PersonNamePayload<ExtArgs>[]
      emails: Prisma.$EmailAddressPayload<ExtArgs>[]
      phones: Prisma.$PhonePayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
      sections: Prisma.$SectionPayload<ExtArgs>[]
      doNotEngageGlobal: Prisma.$DoNotEngageGlobalPayload<ExtArgs> | null
      doNotEngageAgents: Prisma.$DoNotEngageAgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      birthDate: Date | null
      gender: string | null
      citizenshipStatus: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    names<T extends Person$namesArgs<ExtArgs> = {}>(args?: Subset<T, Person$namesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findMany"> | Null>
    emails<T extends Person$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Person$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findMany"> | Null>
    phones<T extends Person$phonesArgs<ExtArgs> = {}>(args?: Subset<T, Person$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findMany"> | Null>
    addresses<T extends Person$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Person$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany"> | Null>
    student<T extends Person$studentArgs<ExtArgs> = {}>(args?: Subset<T, Person$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sections<T extends Person$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Person$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany"> | Null>
    doNotEngageGlobal<T extends Person$doNotEngageGlobalArgs<ExtArgs> = {}>(args?: Subset<T, Person$doNotEngageGlobalArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    doNotEngageAgents<T extends Person$doNotEngageAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Person$doNotEngageAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */ 
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly birthDate: FieldRef<"Person", 'DateTime'>
    readonly gender: FieldRef<"Person", 'String'>
    readonly citizenshipStatus: FieldRef<"Person", 'String'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
    readonly updatedAt: FieldRef<"Person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
  }

  /**
   * Person.names
   */
  export type Person$namesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    where?: PersonNameWhereInput
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    cursor?: PersonNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * Person.emails
   */
  export type Person$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    where?: EmailAddressWhereInput
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    cursor?: EmailAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * Person.phones
   */
  export type Person$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    where?: PhoneWhereInput
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    cursor?: PhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Person.addresses
   */
  export type Person$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Person.student
   */
  export type Person$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Person.sections
   */
  export type Person$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Person.doNotEngageGlobal
   */
  export type Person$doNotEngageGlobalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    where?: DoNotEngageGlobalWhereInput
  }

  /**
   * Person.doNotEngageAgents
   */
  export type Person$doNotEngageAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    where?: DoNotEngageAgentWhereInput
    orderBy?: DoNotEngageAgentOrderByWithRelationInput | DoNotEngageAgentOrderByWithRelationInput[]
    cursor?: DoNotEngageAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoNotEngageAgentScalarFieldEnum | DoNotEngageAgentScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model PersonName
   */

  export type AggregatePersonName = {
    _count: PersonNameCountAggregateOutputType | null
    _min: PersonNameMinAggregateOutputType | null
    _max: PersonNameMaxAggregateOutputType | null
  }

  export type PersonNameMinAggregateOutputType = {
    id: string | null
    personId: string | null
    given: string | null
    middle: string | null
    family: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonNameMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    given: string | null
    middle: string | null
    family: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonNameCountAggregateOutputType = {
    id: number
    personId: number
    given: number
    middle: number
    family: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonNameMinAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonNameMaxAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonNameCountAggregateInputType = {
    id?: true
    personId?: true
    given?: true
    middle?: true
    family?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonName to aggregate.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonNames
    **/
    _count?: true | PersonNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonNameMaxAggregateInputType
  }

  export type GetPersonNameAggregateType<T extends PersonNameAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonName[P]>
      : GetScalarType<T[P], AggregatePersonName[P]>
  }




  export type PersonNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonNameWhereInput
    orderBy?: PersonNameOrderByWithAggregationInput | PersonNameOrderByWithAggregationInput[]
    by: PersonNameScalarFieldEnum[] | PersonNameScalarFieldEnum
    having?: PersonNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonNameCountAggregateInputType | true
    _min?: PersonNameMinAggregateInputType
    _max?: PersonNameMaxAggregateInputType
  }

  export type PersonNameGroupByOutputType = {
    id: string
    personId: string
    given: string
    middle: string | null
    family: string
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: PersonNameCountAggregateOutputType | null
    _min: PersonNameMinAggregateOutputType | null
    _max: PersonNameMaxAggregateOutputType | null
  }

  type GetPersonNameGroupByPayload<T extends PersonNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonNameGroupByOutputType[P]>
            : GetScalarType<T[P], PersonNameGroupByOutputType[P]>
        }
      >
    >


  export type PersonNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personName"]>

  export type PersonNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personName"]>

  export type PersonNameSelectScalar = {
    id?: boolean
    personId?: boolean
    given?: boolean
    middle?: boolean
    family?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PersonNameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $PersonNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonName"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      given: string
      middle: string | null
      family: string
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personName"]>
    composites: {}
  }

  type PersonNameGetPayload<S extends boolean | null | undefined | PersonNameDefaultArgs> = $Result.GetResult<Prisma.$PersonNamePayload, S>

  type PersonNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonNameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonNameCountAggregateInputType | true
    }

  export interface PersonNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonName'], meta: { name: 'PersonName' } }
    /**
     * Find zero or one PersonName that matches the filter.
     * @param {PersonNameFindUniqueArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonNameFindUniqueArgs>(args: SelectSubset<T, PersonNameFindUniqueArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonName that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonNameFindUniqueOrThrowArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonNameFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindFirstArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonNameFindFirstArgs>(args?: SelectSubset<T, PersonNameFindFirstArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindFirstOrThrowArgs} args - Arguments to find a PersonName
     * @example
     * // Get one PersonName
     * const personName = await prisma.personName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonNameFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonNames
     * const personNames = await prisma.personName.findMany()
     * 
     * // Get first 10 PersonNames
     * const personNames = await prisma.personName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personNameWithIdOnly = await prisma.personName.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonNameFindManyArgs>(args?: SelectSubset<T, PersonNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonName.
     * @param {PersonNameCreateArgs} args - Arguments to create a PersonName.
     * @example
     * // Create one PersonName
     * const PersonName = await prisma.personName.create({
     *   data: {
     *     // ... data to create a PersonName
     *   }
     * })
     * 
     */
    create<T extends PersonNameCreateArgs>(args: SelectSubset<T, PersonNameCreateArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonNames.
     * @param {PersonNameCreateManyArgs} args - Arguments to create many PersonNames.
     * @example
     * // Create many PersonNames
     * const personName = await prisma.personName.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonNameCreateManyArgs>(args?: SelectSubset<T, PersonNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonNames and returns the data saved in the database.
     * @param {PersonNameCreateManyAndReturnArgs} args - Arguments to create many PersonNames.
     * @example
     * // Create many PersonNames
     * const personName = await prisma.personName.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonNames and only return the `id`
     * const personNameWithIdOnly = await prisma.personName.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonNameCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonName.
     * @param {PersonNameDeleteArgs} args - Arguments to delete one PersonName.
     * @example
     * // Delete one PersonName
     * const PersonName = await prisma.personName.delete({
     *   where: {
     *     // ... filter to delete one PersonName
     *   }
     * })
     * 
     */
    delete<T extends PersonNameDeleteArgs>(args: SelectSubset<T, PersonNameDeleteArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonName.
     * @param {PersonNameUpdateArgs} args - Arguments to update one PersonName.
     * @example
     * // Update one PersonName
     * const personName = await prisma.personName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonNameUpdateArgs>(args: SelectSubset<T, PersonNameUpdateArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonNames.
     * @param {PersonNameDeleteManyArgs} args - Arguments to filter PersonNames to delete.
     * @example
     * // Delete a few PersonNames
     * const { count } = await prisma.personName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonNameDeleteManyArgs>(args?: SelectSubset<T, PersonNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonNames
     * const personName = await prisma.personName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonNameUpdateManyArgs>(args: SelectSubset<T, PersonNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonName.
     * @param {PersonNameUpsertArgs} args - Arguments to update or create a PersonName.
     * @example
     * // Update or create a PersonName
     * const personName = await prisma.personName.upsert({
     *   create: {
     *     // ... data to create a PersonName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonName we want to update
     *   }
     * })
     */
    upsert<T extends PersonNameUpsertArgs>(args: SelectSubset<T, PersonNameUpsertArgs<ExtArgs>>): Prisma__PersonNameClient<$Result.GetResult<Prisma.$PersonNamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameCountArgs} args - Arguments to filter PersonNames to count.
     * @example
     * // Count the number of PersonNames
     * const count = await prisma.personName.count({
     *   where: {
     *     // ... the filter for the PersonNames we want to count
     *   }
     * })
    **/
    count<T extends PersonNameCountArgs>(
      args?: Subset<T, PersonNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonNameAggregateArgs>(args: Subset<T, PersonNameAggregateArgs>): Prisma.PrismaPromise<GetPersonNameAggregateType<T>>

    /**
     * Group by PersonName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonNameGroupByArgs['orderBy'] }
        : { orderBy?: PersonNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonName model
   */
  readonly fields: PersonNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonName model
   */ 
  interface PersonNameFieldRefs {
    readonly id: FieldRef<"PersonName", 'String'>
    readonly personId: FieldRef<"PersonName", 'String'>
    readonly given: FieldRef<"PersonName", 'String'>
    readonly middle: FieldRef<"PersonName", 'String'>
    readonly family: FieldRef<"PersonName", 'String'>
    readonly type: FieldRef<"PersonName", 'String'>
    readonly preferred: FieldRef<"PersonName", 'Boolean'>
    readonly createdAt: FieldRef<"PersonName", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonName", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonName findUnique
   */
  export type PersonNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName findUniqueOrThrow
   */
  export type PersonNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName findFirst
   */
  export type PersonNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonNames.
     */
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName findFirstOrThrow
   */
  export type PersonNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonName to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonNames.
     */
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName findMany
   */
  export type PersonNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter, which PersonNames to fetch.
     */
    where?: PersonNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonNames to fetch.
     */
    orderBy?: PersonNameOrderByWithRelationInput | PersonNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonNames.
     */
    cursor?: PersonNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonNames.
     */
    skip?: number
    distinct?: PersonNameScalarFieldEnum | PersonNameScalarFieldEnum[]
  }

  /**
   * PersonName create
   */
  export type PersonNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonName.
     */
    data: XOR<PersonNameCreateInput, PersonNameUncheckedCreateInput>
  }

  /**
   * PersonName createMany
   */
  export type PersonNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonNames.
     */
    data: PersonNameCreateManyInput | PersonNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonName createManyAndReturn
   */
  export type PersonNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonNames.
     */
    data: PersonNameCreateManyInput | PersonNameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonName update
   */
  export type PersonNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonName.
     */
    data: XOR<PersonNameUpdateInput, PersonNameUncheckedUpdateInput>
    /**
     * Choose, which PersonName to update.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName updateMany
   */
  export type PersonNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonNames.
     */
    data: XOR<PersonNameUpdateManyMutationInput, PersonNameUncheckedUpdateManyInput>
    /**
     * Filter which PersonNames to update
     */
    where?: PersonNameWhereInput
  }

  /**
   * PersonName upsert
   */
  export type PersonNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonName to update in case it exists.
     */
    where: PersonNameWhereUniqueInput
    /**
     * In case the PersonName found by the `where` argument doesn't exist, create a new PersonName with this data.
     */
    create: XOR<PersonNameCreateInput, PersonNameUncheckedCreateInput>
    /**
     * In case the PersonName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonNameUpdateInput, PersonNameUncheckedUpdateInput>
  }

  /**
   * PersonName delete
   */
  export type PersonNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
    /**
     * Filter which PersonName to delete.
     */
    where: PersonNameWhereUniqueInput
  }

  /**
   * PersonName deleteMany
   */
  export type PersonNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonNames to delete
     */
    where?: PersonNameWhereInput
  }

  /**
   * PersonName without action
   */
  export type PersonNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonName
     */
    select?: PersonNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonNameInclude<ExtArgs> | null
  }


  /**
   * Model EmailAddress
   */

  export type AggregateEmailAddress = {
    _count: EmailAddressCountAggregateOutputType | null
    _min: EmailAddressMinAggregateOutputType | null
    _max: EmailAddressMaxAggregateOutputType | null
  }

  export type EmailAddressMinAggregateOutputType = {
    id: string | null
    personId: string | null
    address: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAddressMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    address: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAddressCountAggregateOutputType = {
    id: number
    personId: number
    address: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailAddressMinAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAddressMaxAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAddressCountAggregateInputType = {
    id?: true
    personId?: true
    address?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAddress to aggregate.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAddresses
    **/
    _count?: true | EmailAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAddressMaxAggregateInputType
  }

  export type GetEmailAddressAggregateType<T extends EmailAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAddress[P]>
      : GetScalarType<T[P], AggregateEmailAddress[P]>
  }




  export type EmailAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAddressWhereInput
    orderBy?: EmailAddressOrderByWithAggregationInput | EmailAddressOrderByWithAggregationInput[]
    by: EmailAddressScalarFieldEnum[] | EmailAddressScalarFieldEnum
    having?: EmailAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAddressCountAggregateInputType | true
    _min?: EmailAddressMinAggregateInputType
    _max?: EmailAddressMaxAggregateInputType
  }

  export type EmailAddressGroupByOutputType = {
    id: string
    personId: string
    address: string
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailAddressCountAggregateOutputType | null
    _min: EmailAddressMinAggregateOutputType | null
    _max: EmailAddressMaxAggregateOutputType | null
  }

  type GetEmailAddressGroupByPayload<T extends EmailAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAddressGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAddressGroupByOutputType[P]>
        }
      >
    >


  export type EmailAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAddress"]>

  export type EmailAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAddress"]>

  export type EmailAddressSelectScalar = {
    id?: boolean
    personId?: boolean
    address?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type EmailAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $EmailAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAddress"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      address: string
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailAddress"]>
    composites: {}
  }

  type EmailAddressGetPayload<S extends boolean | null | undefined | EmailAddressDefaultArgs> = $Result.GetResult<Prisma.$EmailAddressPayload, S>

  type EmailAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailAddressCountAggregateInputType | true
    }

  export interface EmailAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAddress'], meta: { name: 'EmailAddress' } }
    /**
     * Find zero or one EmailAddress that matches the filter.
     * @param {EmailAddressFindUniqueArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAddressFindUniqueArgs>(args: SelectSubset<T, EmailAddressFindUniqueArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailAddress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailAddressFindUniqueOrThrowArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindFirstArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAddressFindFirstArgs>(args?: SelectSubset<T, EmailAddressFindFirstArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindFirstOrThrowArgs} args - Arguments to find a EmailAddress
     * @example
     * // Get one EmailAddress
     * const emailAddress = await prisma.emailAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAddresses
     * const emailAddresses = await prisma.emailAddress.findMany()
     * 
     * // Get first 10 EmailAddresses
     * const emailAddresses = await prisma.emailAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAddressWithIdOnly = await prisma.emailAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAddressFindManyArgs>(args?: SelectSubset<T, EmailAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailAddress.
     * @param {EmailAddressCreateArgs} args - Arguments to create a EmailAddress.
     * @example
     * // Create one EmailAddress
     * const EmailAddress = await prisma.emailAddress.create({
     *   data: {
     *     // ... data to create a EmailAddress
     *   }
     * })
     * 
     */
    create<T extends EmailAddressCreateArgs>(args: SelectSubset<T, EmailAddressCreateArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailAddresses.
     * @param {EmailAddressCreateManyArgs} args - Arguments to create many EmailAddresses.
     * @example
     * // Create many EmailAddresses
     * const emailAddress = await prisma.emailAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAddressCreateManyArgs>(args?: SelectSubset<T, EmailAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAddresses and returns the data saved in the database.
     * @param {EmailAddressCreateManyAndReturnArgs} args - Arguments to create many EmailAddresses.
     * @example
     * // Create many EmailAddresses
     * const emailAddress = await prisma.emailAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAddresses and only return the `id`
     * const emailAddressWithIdOnly = await prisma.emailAddress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailAddress.
     * @param {EmailAddressDeleteArgs} args - Arguments to delete one EmailAddress.
     * @example
     * // Delete one EmailAddress
     * const EmailAddress = await prisma.emailAddress.delete({
     *   where: {
     *     // ... filter to delete one EmailAddress
     *   }
     * })
     * 
     */
    delete<T extends EmailAddressDeleteArgs>(args: SelectSubset<T, EmailAddressDeleteArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailAddress.
     * @param {EmailAddressUpdateArgs} args - Arguments to update one EmailAddress.
     * @example
     * // Update one EmailAddress
     * const emailAddress = await prisma.emailAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAddressUpdateArgs>(args: SelectSubset<T, EmailAddressUpdateArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailAddresses.
     * @param {EmailAddressDeleteManyArgs} args - Arguments to filter EmailAddresses to delete.
     * @example
     * // Delete a few EmailAddresses
     * const { count } = await prisma.emailAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAddressDeleteManyArgs>(args?: SelectSubset<T, EmailAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAddresses
     * const emailAddress = await prisma.emailAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAddressUpdateManyArgs>(args: SelectSubset<T, EmailAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailAddress.
     * @param {EmailAddressUpsertArgs} args - Arguments to update or create a EmailAddress.
     * @example
     * // Update or create a EmailAddress
     * const emailAddress = await prisma.emailAddress.upsert({
     *   create: {
     *     // ... data to create a EmailAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAddress we want to update
     *   }
     * })
     */
    upsert<T extends EmailAddressUpsertArgs>(args: SelectSubset<T, EmailAddressUpsertArgs<ExtArgs>>): Prisma__EmailAddressClient<$Result.GetResult<Prisma.$EmailAddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressCountArgs} args - Arguments to filter EmailAddresses to count.
     * @example
     * // Count the number of EmailAddresses
     * const count = await prisma.emailAddress.count({
     *   where: {
     *     // ... the filter for the EmailAddresses we want to count
     *   }
     * })
    **/
    count<T extends EmailAddressCountArgs>(
      args?: Subset<T, EmailAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAddressAggregateArgs>(args: Subset<T, EmailAddressAggregateArgs>): Prisma.PrismaPromise<GetEmailAddressAggregateType<T>>

    /**
     * Group by EmailAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAddressGroupByArgs['orderBy'] }
        : { orderBy?: EmailAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAddress model
   */
  readonly fields: EmailAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAddress model
   */ 
  interface EmailAddressFieldRefs {
    readonly id: FieldRef<"EmailAddress", 'String'>
    readonly personId: FieldRef<"EmailAddress", 'String'>
    readonly address: FieldRef<"EmailAddress", 'String'>
    readonly type: FieldRef<"EmailAddress", 'String'>
    readonly preferred: FieldRef<"EmailAddress", 'Boolean'>
    readonly createdAt: FieldRef<"EmailAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAddress findUnique
   */
  export type EmailAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress findUniqueOrThrow
   */
  export type EmailAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress findFirst
   */
  export type EmailAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAddresses.
     */
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress findFirstOrThrow
   */
  export type EmailAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddress to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAddresses.
     */
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress findMany
   */
  export type EmailAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter, which EmailAddresses to fetch.
     */
    where?: EmailAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAddresses to fetch.
     */
    orderBy?: EmailAddressOrderByWithRelationInput | EmailAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAddresses.
     */
    cursor?: EmailAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAddresses.
     */
    skip?: number
    distinct?: EmailAddressScalarFieldEnum | EmailAddressScalarFieldEnum[]
  }

  /**
   * EmailAddress create
   */
  export type EmailAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAddress.
     */
    data: XOR<EmailAddressCreateInput, EmailAddressUncheckedCreateInput>
  }

  /**
   * EmailAddress createMany
   */
  export type EmailAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAddresses.
     */
    data: EmailAddressCreateManyInput | EmailAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAddress createManyAndReturn
   */
  export type EmailAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailAddresses.
     */
    data: EmailAddressCreateManyInput | EmailAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAddress update
   */
  export type EmailAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAddress.
     */
    data: XOR<EmailAddressUpdateInput, EmailAddressUncheckedUpdateInput>
    /**
     * Choose, which EmailAddress to update.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress updateMany
   */
  export type EmailAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAddresses.
     */
    data: XOR<EmailAddressUpdateManyMutationInput, EmailAddressUncheckedUpdateManyInput>
    /**
     * Filter which EmailAddresses to update
     */
    where?: EmailAddressWhereInput
  }

  /**
   * EmailAddress upsert
   */
  export type EmailAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAddress to update in case it exists.
     */
    where: EmailAddressWhereUniqueInput
    /**
     * In case the EmailAddress found by the `where` argument doesn't exist, create a new EmailAddress with this data.
     */
    create: XOR<EmailAddressCreateInput, EmailAddressUncheckedCreateInput>
    /**
     * In case the EmailAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAddressUpdateInput, EmailAddressUncheckedUpdateInput>
  }

  /**
   * EmailAddress delete
   */
  export type EmailAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
    /**
     * Filter which EmailAddress to delete.
     */
    where: EmailAddressWhereUniqueInput
  }

  /**
   * EmailAddress deleteMany
   */
  export type EmailAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAddresses to delete
     */
    where?: EmailAddressWhereInput
  }

  /**
   * EmailAddress without action
   */
  export type EmailAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAddress
     */
    select?: EmailAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAddressInclude<ExtArgs> | null
  }


  /**
   * Model Phone
   */

  export type AggregatePhone = {
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  export type PhoneMinAggregateOutputType = {
    id: string | null
    personId: string | null
    number: string | null
    extension: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    number: string | null
    extension: string | null
    type: string | null
    preferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneCountAggregateOutputType = {
    id: number
    personId: number
    number: number
    extension: number
    type: number
    preferred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhoneMinAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneMaxAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneCountAggregateInputType = {
    id?: true
    personId?: true
    number?: true
    extension?: true
    type?: true
    preferred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phone to aggregate.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phones
    **/
    _count?: true | PhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneMaxAggregateInputType
  }

  export type GetPhoneAggregateType<T extends PhoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhone[P]>
      : GetScalarType<T[P], AggregatePhone[P]>
  }




  export type PhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneWhereInput
    orderBy?: PhoneOrderByWithAggregationInput | PhoneOrderByWithAggregationInput[]
    by: PhoneScalarFieldEnum[] | PhoneScalarFieldEnum
    having?: PhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneCountAggregateInputType | true
    _min?: PhoneMinAggregateInputType
    _max?: PhoneMaxAggregateInputType
  }

  export type PhoneGroupByOutputType = {
    id: string
    personId: string
    number: string
    extension: string | null
    type: string
    preferred: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  type GetPhoneGroupByPayload<T extends PhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneGroupByOutputType[P]>
        }
      >
    >


  export type PhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phone"]>

  export type PhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phone"]>

  export type PhoneSelectScalar = {
    id?: boolean
    personId?: boolean
    number?: boolean
    extension?: boolean
    type?: boolean
    preferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $PhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phone"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      number: string
      extension: string | null
      type: string
      preferred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phone"]>
    composites: {}
  }

  type PhoneGetPayload<S extends boolean | null | undefined | PhoneDefaultArgs> = $Result.GetResult<Prisma.$PhonePayload, S>

  type PhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhoneCountAggregateInputType | true
    }

  export interface PhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phone'], meta: { name: 'Phone' } }
    /**
     * Find zero or one Phone that matches the filter.
     * @param {PhoneFindUniqueArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneFindUniqueArgs>(args: SelectSubset<T, PhoneFindUniqueArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Phone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhoneFindUniqueOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Phone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneFindFirstArgs>(args?: SelectSubset<T, PhoneFindFirstArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Phone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Phones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phones
     * const phones = await prisma.phone.findMany()
     * 
     * // Get first 10 Phones
     * const phones = await prisma.phone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneWithIdOnly = await prisma.phone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhoneFindManyArgs>(args?: SelectSubset<T, PhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Phone.
     * @param {PhoneCreateArgs} args - Arguments to create a Phone.
     * @example
     * // Create one Phone
     * const Phone = await prisma.phone.create({
     *   data: {
     *     // ... data to create a Phone
     *   }
     * })
     * 
     */
    create<T extends PhoneCreateArgs>(args: SelectSubset<T, PhoneCreateArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Phones.
     * @param {PhoneCreateManyArgs} args - Arguments to create many Phones.
     * @example
     * // Create many Phones
     * const phone = await prisma.phone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneCreateManyArgs>(args?: SelectSubset<T, PhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phones and returns the data saved in the database.
     * @param {PhoneCreateManyAndReturnArgs} args - Arguments to create many Phones.
     * @example
     * // Create many Phones
     * const phone = await prisma.phone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phones and only return the `id`
     * const phoneWithIdOnly = await prisma.phone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, PhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Phone.
     * @param {PhoneDeleteArgs} args - Arguments to delete one Phone.
     * @example
     * // Delete one Phone
     * const Phone = await prisma.phone.delete({
     *   where: {
     *     // ... filter to delete one Phone
     *   }
     * })
     * 
     */
    delete<T extends PhoneDeleteArgs>(args: SelectSubset<T, PhoneDeleteArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Phone.
     * @param {PhoneUpdateArgs} args - Arguments to update one Phone.
     * @example
     * // Update one Phone
     * const phone = await prisma.phone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneUpdateArgs>(args: SelectSubset<T, PhoneUpdateArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Phones.
     * @param {PhoneDeleteManyArgs} args - Arguments to filter Phones to delete.
     * @example
     * // Delete a few Phones
     * const { count } = await prisma.phone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneDeleteManyArgs>(args?: SelectSubset<T, PhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phones
     * const phone = await prisma.phone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneUpdateManyArgs>(args: SelectSubset<T, PhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Phone.
     * @param {PhoneUpsertArgs} args - Arguments to update or create a Phone.
     * @example
     * // Update or create a Phone
     * const phone = await prisma.phone.upsert({
     *   create: {
     *     // ... data to create a Phone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phone we want to update
     *   }
     * })
     */
    upsert<T extends PhoneUpsertArgs>(args: SelectSubset<T, PhoneUpsertArgs<ExtArgs>>): Prisma__PhoneClient<$Result.GetResult<Prisma.$PhonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCountArgs} args - Arguments to filter Phones to count.
     * @example
     * // Count the number of Phones
     * const count = await prisma.phone.count({
     *   where: {
     *     // ... the filter for the Phones we want to count
     *   }
     * })
    **/
    count<T extends PhoneCountArgs>(
      args?: Subset<T, PhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneAggregateArgs>(args: Subset<T, PhoneAggregateArgs>): Prisma.PrismaPromise<GetPhoneAggregateType<T>>

    /**
     * Group by Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneGroupByArgs['orderBy'] }
        : { orderBy?: PhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phone model
   */
  readonly fields: PhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phone model
   */ 
  interface PhoneFieldRefs {
    readonly id: FieldRef<"Phone", 'String'>
    readonly personId: FieldRef<"Phone", 'String'>
    readonly number: FieldRef<"Phone", 'String'>
    readonly extension: FieldRef<"Phone", 'String'>
    readonly type: FieldRef<"Phone", 'String'>
    readonly preferred: FieldRef<"Phone", 'Boolean'>
    readonly createdAt: FieldRef<"Phone", 'DateTime'>
    readonly updatedAt: FieldRef<"Phone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Phone findUnique
   */
  export type PhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone findUniqueOrThrow
   */
  export type PhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone findFirst
   */
  export type PhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone findFirstOrThrow
   */
  export type PhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone findMany
   */
  export type PhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter, which Phones to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: PhoneOrderByWithRelationInput | PhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    distinct?: PhoneScalarFieldEnum | PhoneScalarFieldEnum[]
  }

  /**
   * Phone create
   */
  export type PhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Phone.
     */
    data: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
  }

  /**
   * Phone createMany
   */
  export type PhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phones.
     */
    data: PhoneCreateManyInput | PhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phone createManyAndReturn
   */
  export type PhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Phones.
     */
    data: PhoneCreateManyInput | PhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phone update
   */
  export type PhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Phone.
     */
    data: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
    /**
     * Choose, which Phone to update.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone updateMany
   */
  export type PhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phones.
     */
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyInput>
    /**
     * Filter which Phones to update
     */
    where?: PhoneWhereInput
  }

  /**
   * Phone upsert
   */
  export type PhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Phone to update in case it exists.
     */
    where: PhoneWhereUniqueInput
    /**
     * In case the Phone found by the `where` argument doesn't exist, create a new Phone with this data.
     */
    create: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
    /**
     * In case the Phone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
  }

  /**
   * Phone delete
   */
  export type PhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
    /**
     * Filter which Phone to delete.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone deleteMany
   */
  export type PhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phones to delete
     */
    where?: PhoneWhereInput
  }

  /**
   * Phone without action
   */
  export type PhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    personId: number
    type: number
    line1: number
    line2: number
    city: number
    state: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    personId: string
    type: string
    line1: string
    line2: string | null
    city: string
    state: string
    postalCode: string
    country: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    personId?: boolean
    type?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      type: string
      line1: string
      line2: string | null
      city: string
      state: string
      postalCode: string
      country: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly personId: FieldRef<"Address", 'String'>
    readonly type: FieldRef<"Address", 'String'>
    readonly line1: FieldRef<"Address", 'String'>
    readonly line2: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model DoNotEngageGlobal
   */

  export type AggregateDoNotEngageGlobal = {
    _count: DoNotEngageGlobalCountAggregateOutputType | null
    _min: DoNotEngageGlobalMinAggregateOutputType | null
    _max: DoNotEngageGlobalMaxAggregateOutputType | null
  }

  export type DoNotEngageGlobalMinAggregateOutputType = {
    id: string | null
    personId: string | null
    emailBlocked: boolean | null
    smsBlocked: boolean | null
    phoneBlocked: boolean | null
    source: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedById: string | null
  }

  export type DoNotEngageGlobalMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    emailBlocked: boolean | null
    smsBlocked: boolean | null
    phoneBlocked: boolean | null
    source: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedById: string | null
  }

  export type DoNotEngageGlobalCountAggregateOutputType = {
    id: number
    personId: number
    emailBlocked: number
    smsBlocked: number
    phoneBlocked: number
    source: number
    reason: number
    createdAt: number
    updatedAt: number
    updatedById: number
    _all: number
  }


  export type DoNotEngageGlobalMinAggregateInputType = {
    id?: true
    personId?: true
    emailBlocked?: true
    smsBlocked?: true
    phoneBlocked?: true
    source?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    updatedById?: true
  }

  export type DoNotEngageGlobalMaxAggregateInputType = {
    id?: true
    personId?: true
    emailBlocked?: true
    smsBlocked?: true
    phoneBlocked?: true
    source?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    updatedById?: true
  }

  export type DoNotEngageGlobalCountAggregateInputType = {
    id?: true
    personId?: true
    emailBlocked?: true
    smsBlocked?: true
    phoneBlocked?: true
    source?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    updatedById?: true
    _all?: true
  }

  export type DoNotEngageGlobalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoNotEngageGlobal to aggregate.
     */
    where?: DoNotEngageGlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageGlobals to fetch.
     */
    orderBy?: DoNotEngageGlobalOrderByWithRelationInput | DoNotEngageGlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoNotEngageGlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageGlobals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageGlobals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoNotEngageGlobals
    **/
    _count?: true | DoNotEngageGlobalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoNotEngageGlobalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoNotEngageGlobalMaxAggregateInputType
  }

  export type GetDoNotEngageGlobalAggregateType<T extends DoNotEngageGlobalAggregateArgs> = {
        [P in keyof T & keyof AggregateDoNotEngageGlobal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoNotEngageGlobal[P]>
      : GetScalarType<T[P], AggregateDoNotEngageGlobal[P]>
  }




  export type DoNotEngageGlobalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoNotEngageGlobalWhereInput
    orderBy?: DoNotEngageGlobalOrderByWithAggregationInput | DoNotEngageGlobalOrderByWithAggregationInput[]
    by: DoNotEngageGlobalScalarFieldEnum[] | DoNotEngageGlobalScalarFieldEnum
    having?: DoNotEngageGlobalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoNotEngageGlobalCountAggregateInputType | true
    _min?: DoNotEngageGlobalMinAggregateInputType
    _max?: DoNotEngageGlobalMaxAggregateInputType
  }

  export type DoNotEngageGlobalGroupByOutputType = {
    id: string
    personId: string
    emailBlocked: boolean
    smsBlocked: boolean
    phoneBlocked: boolean
    source: string
    reason: string | null
    createdAt: Date
    updatedAt: Date
    updatedById: string | null
    _count: DoNotEngageGlobalCountAggregateOutputType | null
    _min: DoNotEngageGlobalMinAggregateOutputType | null
    _max: DoNotEngageGlobalMaxAggregateOutputType | null
  }

  type GetDoNotEngageGlobalGroupByPayload<T extends DoNotEngageGlobalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoNotEngageGlobalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoNotEngageGlobalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoNotEngageGlobalGroupByOutputType[P]>
            : GetScalarType<T[P], DoNotEngageGlobalGroupByOutputType[P]>
        }
      >
    >


  export type DoNotEngageGlobalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedById?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doNotEngageGlobal"]>

  export type DoNotEngageGlobalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedById?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doNotEngageGlobal"]>

  export type DoNotEngageGlobalSelectScalar = {
    id?: boolean
    personId?: boolean
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedById?: boolean
  }

  export type DoNotEngageGlobalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type DoNotEngageGlobalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $DoNotEngageGlobalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoNotEngageGlobal"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      emailBlocked: boolean
      smsBlocked: boolean
      phoneBlocked: boolean
      source: string
      reason: string | null
      createdAt: Date
      updatedAt: Date
      updatedById: string | null
    }, ExtArgs["result"]["doNotEngageGlobal"]>
    composites: {}
  }

  type DoNotEngageGlobalGetPayload<S extends boolean | null | undefined | DoNotEngageGlobalDefaultArgs> = $Result.GetResult<Prisma.$DoNotEngageGlobalPayload, S>

  type DoNotEngageGlobalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoNotEngageGlobalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoNotEngageGlobalCountAggregateInputType | true
    }

  export interface DoNotEngageGlobalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoNotEngageGlobal'], meta: { name: 'DoNotEngageGlobal' } }
    /**
     * Find zero or one DoNotEngageGlobal that matches the filter.
     * @param {DoNotEngageGlobalFindUniqueArgs} args - Arguments to find a DoNotEngageGlobal
     * @example
     * // Get one DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoNotEngageGlobalFindUniqueArgs>(args: SelectSubset<T, DoNotEngageGlobalFindUniqueArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoNotEngageGlobal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoNotEngageGlobalFindUniqueOrThrowArgs} args - Arguments to find a DoNotEngageGlobal
     * @example
     * // Get one DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoNotEngageGlobalFindUniqueOrThrowArgs>(args: SelectSubset<T, DoNotEngageGlobalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoNotEngageGlobal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalFindFirstArgs} args - Arguments to find a DoNotEngageGlobal
     * @example
     * // Get one DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoNotEngageGlobalFindFirstArgs>(args?: SelectSubset<T, DoNotEngageGlobalFindFirstArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoNotEngageGlobal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalFindFirstOrThrowArgs} args - Arguments to find a DoNotEngageGlobal
     * @example
     * // Get one DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoNotEngageGlobalFindFirstOrThrowArgs>(args?: SelectSubset<T, DoNotEngageGlobalFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoNotEngageGlobals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoNotEngageGlobals
     * const doNotEngageGlobals = await prisma.doNotEngageGlobal.findMany()
     * 
     * // Get first 10 DoNotEngageGlobals
     * const doNotEngageGlobals = await prisma.doNotEngageGlobal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doNotEngageGlobalWithIdOnly = await prisma.doNotEngageGlobal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoNotEngageGlobalFindManyArgs>(args?: SelectSubset<T, DoNotEngageGlobalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoNotEngageGlobal.
     * @param {DoNotEngageGlobalCreateArgs} args - Arguments to create a DoNotEngageGlobal.
     * @example
     * // Create one DoNotEngageGlobal
     * const DoNotEngageGlobal = await prisma.doNotEngageGlobal.create({
     *   data: {
     *     // ... data to create a DoNotEngageGlobal
     *   }
     * })
     * 
     */
    create<T extends DoNotEngageGlobalCreateArgs>(args: SelectSubset<T, DoNotEngageGlobalCreateArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoNotEngageGlobals.
     * @param {DoNotEngageGlobalCreateManyArgs} args - Arguments to create many DoNotEngageGlobals.
     * @example
     * // Create many DoNotEngageGlobals
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoNotEngageGlobalCreateManyArgs>(args?: SelectSubset<T, DoNotEngageGlobalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoNotEngageGlobals and returns the data saved in the database.
     * @param {DoNotEngageGlobalCreateManyAndReturnArgs} args - Arguments to create many DoNotEngageGlobals.
     * @example
     * // Create many DoNotEngageGlobals
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoNotEngageGlobals and only return the `id`
     * const doNotEngageGlobalWithIdOnly = await prisma.doNotEngageGlobal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoNotEngageGlobalCreateManyAndReturnArgs>(args?: SelectSubset<T, DoNotEngageGlobalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoNotEngageGlobal.
     * @param {DoNotEngageGlobalDeleteArgs} args - Arguments to delete one DoNotEngageGlobal.
     * @example
     * // Delete one DoNotEngageGlobal
     * const DoNotEngageGlobal = await prisma.doNotEngageGlobal.delete({
     *   where: {
     *     // ... filter to delete one DoNotEngageGlobal
     *   }
     * })
     * 
     */
    delete<T extends DoNotEngageGlobalDeleteArgs>(args: SelectSubset<T, DoNotEngageGlobalDeleteArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoNotEngageGlobal.
     * @param {DoNotEngageGlobalUpdateArgs} args - Arguments to update one DoNotEngageGlobal.
     * @example
     * // Update one DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoNotEngageGlobalUpdateArgs>(args: SelectSubset<T, DoNotEngageGlobalUpdateArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoNotEngageGlobals.
     * @param {DoNotEngageGlobalDeleteManyArgs} args - Arguments to filter DoNotEngageGlobals to delete.
     * @example
     * // Delete a few DoNotEngageGlobals
     * const { count } = await prisma.doNotEngageGlobal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoNotEngageGlobalDeleteManyArgs>(args?: SelectSubset<T, DoNotEngageGlobalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoNotEngageGlobals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoNotEngageGlobals
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoNotEngageGlobalUpdateManyArgs>(args: SelectSubset<T, DoNotEngageGlobalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoNotEngageGlobal.
     * @param {DoNotEngageGlobalUpsertArgs} args - Arguments to update or create a DoNotEngageGlobal.
     * @example
     * // Update or create a DoNotEngageGlobal
     * const doNotEngageGlobal = await prisma.doNotEngageGlobal.upsert({
     *   create: {
     *     // ... data to create a DoNotEngageGlobal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoNotEngageGlobal we want to update
     *   }
     * })
     */
    upsert<T extends DoNotEngageGlobalUpsertArgs>(args: SelectSubset<T, DoNotEngageGlobalUpsertArgs<ExtArgs>>): Prisma__DoNotEngageGlobalClient<$Result.GetResult<Prisma.$DoNotEngageGlobalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoNotEngageGlobals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalCountArgs} args - Arguments to filter DoNotEngageGlobals to count.
     * @example
     * // Count the number of DoNotEngageGlobals
     * const count = await prisma.doNotEngageGlobal.count({
     *   where: {
     *     // ... the filter for the DoNotEngageGlobals we want to count
     *   }
     * })
    **/
    count<T extends DoNotEngageGlobalCountArgs>(
      args?: Subset<T, DoNotEngageGlobalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoNotEngageGlobalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoNotEngageGlobal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoNotEngageGlobalAggregateArgs>(args: Subset<T, DoNotEngageGlobalAggregateArgs>): Prisma.PrismaPromise<GetDoNotEngageGlobalAggregateType<T>>

    /**
     * Group by DoNotEngageGlobal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageGlobalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoNotEngageGlobalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoNotEngageGlobalGroupByArgs['orderBy'] }
        : { orderBy?: DoNotEngageGlobalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoNotEngageGlobalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoNotEngageGlobalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoNotEngageGlobal model
   */
  readonly fields: DoNotEngageGlobalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoNotEngageGlobal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoNotEngageGlobalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoNotEngageGlobal model
   */ 
  interface DoNotEngageGlobalFieldRefs {
    readonly id: FieldRef<"DoNotEngageGlobal", 'String'>
    readonly personId: FieldRef<"DoNotEngageGlobal", 'String'>
    readonly emailBlocked: FieldRef<"DoNotEngageGlobal", 'Boolean'>
    readonly smsBlocked: FieldRef<"DoNotEngageGlobal", 'Boolean'>
    readonly phoneBlocked: FieldRef<"DoNotEngageGlobal", 'Boolean'>
    readonly source: FieldRef<"DoNotEngageGlobal", 'String'>
    readonly reason: FieldRef<"DoNotEngageGlobal", 'String'>
    readonly createdAt: FieldRef<"DoNotEngageGlobal", 'DateTime'>
    readonly updatedAt: FieldRef<"DoNotEngageGlobal", 'DateTime'>
    readonly updatedById: FieldRef<"DoNotEngageGlobal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoNotEngageGlobal findUnique
   */
  export type DoNotEngageGlobalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageGlobal to fetch.
     */
    where: DoNotEngageGlobalWhereUniqueInput
  }

  /**
   * DoNotEngageGlobal findUniqueOrThrow
   */
  export type DoNotEngageGlobalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageGlobal to fetch.
     */
    where: DoNotEngageGlobalWhereUniqueInput
  }

  /**
   * DoNotEngageGlobal findFirst
   */
  export type DoNotEngageGlobalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageGlobal to fetch.
     */
    where?: DoNotEngageGlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageGlobals to fetch.
     */
    orderBy?: DoNotEngageGlobalOrderByWithRelationInput | DoNotEngageGlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoNotEngageGlobals.
     */
    cursor?: DoNotEngageGlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageGlobals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageGlobals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoNotEngageGlobals.
     */
    distinct?: DoNotEngageGlobalScalarFieldEnum | DoNotEngageGlobalScalarFieldEnum[]
  }

  /**
   * DoNotEngageGlobal findFirstOrThrow
   */
  export type DoNotEngageGlobalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageGlobal to fetch.
     */
    where?: DoNotEngageGlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageGlobals to fetch.
     */
    orderBy?: DoNotEngageGlobalOrderByWithRelationInput | DoNotEngageGlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoNotEngageGlobals.
     */
    cursor?: DoNotEngageGlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageGlobals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageGlobals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoNotEngageGlobals.
     */
    distinct?: DoNotEngageGlobalScalarFieldEnum | DoNotEngageGlobalScalarFieldEnum[]
  }

  /**
   * DoNotEngageGlobal findMany
   */
  export type DoNotEngageGlobalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageGlobals to fetch.
     */
    where?: DoNotEngageGlobalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageGlobals to fetch.
     */
    orderBy?: DoNotEngageGlobalOrderByWithRelationInput | DoNotEngageGlobalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoNotEngageGlobals.
     */
    cursor?: DoNotEngageGlobalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageGlobals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageGlobals.
     */
    skip?: number
    distinct?: DoNotEngageGlobalScalarFieldEnum | DoNotEngageGlobalScalarFieldEnum[]
  }

  /**
   * DoNotEngageGlobal create
   */
  export type DoNotEngageGlobalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * The data needed to create a DoNotEngageGlobal.
     */
    data: XOR<DoNotEngageGlobalCreateInput, DoNotEngageGlobalUncheckedCreateInput>
  }

  /**
   * DoNotEngageGlobal createMany
   */
  export type DoNotEngageGlobalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoNotEngageGlobals.
     */
    data: DoNotEngageGlobalCreateManyInput | DoNotEngageGlobalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoNotEngageGlobal createManyAndReturn
   */
  export type DoNotEngageGlobalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoNotEngageGlobals.
     */
    data: DoNotEngageGlobalCreateManyInput | DoNotEngageGlobalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoNotEngageGlobal update
   */
  export type DoNotEngageGlobalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * The data needed to update a DoNotEngageGlobal.
     */
    data: XOR<DoNotEngageGlobalUpdateInput, DoNotEngageGlobalUncheckedUpdateInput>
    /**
     * Choose, which DoNotEngageGlobal to update.
     */
    where: DoNotEngageGlobalWhereUniqueInput
  }

  /**
   * DoNotEngageGlobal updateMany
   */
  export type DoNotEngageGlobalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoNotEngageGlobals.
     */
    data: XOR<DoNotEngageGlobalUpdateManyMutationInput, DoNotEngageGlobalUncheckedUpdateManyInput>
    /**
     * Filter which DoNotEngageGlobals to update
     */
    where?: DoNotEngageGlobalWhereInput
  }

  /**
   * DoNotEngageGlobal upsert
   */
  export type DoNotEngageGlobalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * The filter to search for the DoNotEngageGlobal to update in case it exists.
     */
    where: DoNotEngageGlobalWhereUniqueInput
    /**
     * In case the DoNotEngageGlobal found by the `where` argument doesn't exist, create a new DoNotEngageGlobal with this data.
     */
    create: XOR<DoNotEngageGlobalCreateInput, DoNotEngageGlobalUncheckedCreateInput>
    /**
     * In case the DoNotEngageGlobal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoNotEngageGlobalUpdateInput, DoNotEngageGlobalUncheckedUpdateInput>
  }

  /**
   * DoNotEngageGlobal delete
   */
  export type DoNotEngageGlobalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
    /**
     * Filter which DoNotEngageGlobal to delete.
     */
    where: DoNotEngageGlobalWhereUniqueInput
  }

  /**
   * DoNotEngageGlobal deleteMany
   */
  export type DoNotEngageGlobalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoNotEngageGlobals to delete
     */
    where?: DoNotEngageGlobalWhereInput
  }

  /**
   * DoNotEngageGlobal without action
   */
  export type DoNotEngageGlobalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageGlobal
     */
    select?: DoNotEngageGlobalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageGlobalInclude<ExtArgs> | null
  }


  /**
   * Model DoNotEngageAgent
   */

  export type AggregateDoNotEngageAgent = {
    _count: DoNotEngageAgentCountAggregateOutputType | null
    _min: DoNotEngageAgentMinAggregateOutputType | null
    _max: DoNotEngageAgentMaxAggregateOutputType | null
  }

  export type DoNotEngageAgentMinAggregateOutputType = {
    id: string | null
    personId: string | null
    agentId: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type DoNotEngageAgentMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    agentId: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type DoNotEngageAgentCountAggregateOutputType = {
    id: number
    personId: number
    agentId: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type DoNotEngageAgentMinAggregateInputType = {
    id?: true
    personId?: true
    agentId?: true
    createdAt?: true
    createdById?: true
  }

  export type DoNotEngageAgentMaxAggregateInputType = {
    id?: true
    personId?: true
    agentId?: true
    createdAt?: true
    createdById?: true
  }

  export type DoNotEngageAgentCountAggregateInputType = {
    id?: true
    personId?: true
    agentId?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type DoNotEngageAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoNotEngageAgent to aggregate.
     */
    where?: DoNotEngageAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageAgents to fetch.
     */
    orderBy?: DoNotEngageAgentOrderByWithRelationInput | DoNotEngageAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoNotEngageAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoNotEngageAgents
    **/
    _count?: true | DoNotEngageAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoNotEngageAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoNotEngageAgentMaxAggregateInputType
  }

  export type GetDoNotEngageAgentAggregateType<T extends DoNotEngageAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateDoNotEngageAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoNotEngageAgent[P]>
      : GetScalarType<T[P], AggregateDoNotEngageAgent[P]>
  }




  export type DoNotEngageAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoNotEngageAgentWhereInput
    orderBy?: DoNotEngageAgentOrderByWithAggregationInput | DoNotEngageAgentOrderByWithAggregationInput[]
    by: DoNotEngageAgentScalarFieldEnum[] | DoNotEngageAgentScalarFieldEnum
    having?: DoNotEngageAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoNotEngageAgentCountAggregateInputType | true
    _min?: DoNotEngageAgentMinAggregateInputType
    _max?: DoNotEngageAgentMaxAggregateInputType
  }

  export type DoNotEngageAgentGroupByOutputType = {
    id: string
    personId: string
    agentId: string
    createdAt: Date
    createdById: string | null
    _count: DoNotEngageAgentCountAggregateOutputType | null
    _min: DoNotEngageAgentMinAggregateOutputType | null
    _max: DoNotEngageAgentMaxAggregateOutputType | null
  }

  type GetDoNotEngageAgentGroupByPayload<T extends DoNotEngageAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoNotEngageAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoNotEngageAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoNotEngageAgentGroupByOutputType[P]>
            : GetScalarType<T[P], DoNotEngageAgentGroupByOutputType[P]>
        }
      >
    >


  export type DoNotEngageAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    agentId?: boolean
    createdAt?: boolean
    createdById?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doNotEngageAgent"]>

  export type DoNotEngageAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    agentId?: boolean
    createdAt?: boolean
    createdById?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doNotEngageAgent"]>

  export type DoNotEngageAgentSelectScalar = {
    id?: boolean
    personId?: boolean
    agentId?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type DoNotEngageAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type DoNotEngageAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $DoNotEngageAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoNotEngageAgent"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      agentId: string
      createdAt: Date
      createdById: string | null
    }, ExtArgs["result"]["doNotEngageAgent"]>
    composites: {}
  }

  type DoNotEngageAgentGetPayload<S extends boolean | null | undefined | DoNotEngageAgentDefaultArgs> = $Result.GetResult<Prisma.$DoNotEngageAgentPayload, S>

  type DoNotEngageAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoNotEngageAgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoNotEngageAgentCountAggregateInputType | true
    }

  export interface DoNotEngageAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoNotEngageAgent'], meta: { name: 'DoNotEngageAgent' } }
    /**
     * Find zero or one DoNotEngageAgent that matches the filter.
     * @param {DoNotEngageAgentFindUniqueArgs} args - Arguments to find a DoNotEngageAgent
     * @example
     * // Get one DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoNotEngageAgentFindUniqueArgs>(args: SelectSubset<T, DoNotEngageAgentFindUniqueArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoNotEngageAgent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoNotEngageAgentFindUniqueOrThrowArgs} args - Arguments to find a DoNotEngageAgent
     * @example
     * // Get one DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoNotEngageAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, DoNotEngageAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoNotEngageAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentFindFirstArgs} args - Arguments to find a DoNotEngageAgent
     * @example
     * // Get one DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoNotEngageAgentFindFirstArgs>(args?: SelectSubset<T, DoNotEngageAgentFindFirstArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoNotEngageAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentFindFirstOrThrowArgs} args - Arguments to find a DoNotEngageAgent
     * @example
     * // Get one DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoNotEngageAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, DoNotEngageAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoNotEngageAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoNotEngageAgents
     * const doNotEngageAgents = await prisma.doNotEngageAgent.findMany()
     * 
     * // Get first 10 DoNotEngageAgents
     * const doNotEngageAgents = await prisma.doNotEngageAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doNotEngageAgentWithIdOnly = await prisma.doNotEngageAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoNotEngageAgentFindManyArgs>(args?: SelectSubset<T, DoNotEngageAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoNotEngageAgent.
     * @param {DoNotEngageAgentCreateArgs} args - Arguments to create a DoNotEngageAgent.
     * @example
     * // Create one DoNotEngageAgent
     * const DoNotEngageAgent = await prisma.doNotEngageAgent.create({
     *   data: {
     *     // ... data to create a DoNotEngageAgent
     *   }
     * })
     * 
     */
    create<T extends DoNotEngageAgentCreateArgs>(args: SelectSubset<T, DoNotEngageAgentCreateArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoNotEngageAgents.
     * @param {DoNotEngageAgentCreateManyArgs} args - Arguments to create many DoNotEngageAgents.
     * @example
     * // Create many DoNotEngageAgents
     * const doNotEngageAgent = await prisma.doNotEngageAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoNotEngageAgentCreateManyArgs>(args?: SelectSubset<T, DoNotEngageAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoNotEngageAgents and returns the data saved in the database.
     * @param {DoNotEngageAgentCreateManyAndReturnArgs} args - Arguments to create many DoNotEngageAgents.
     * @example
     * // Create many DoNotEngageAgents
     * const doNotEngageAgent = await prisma.doNotEngageAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoNotEngageAgents and only return the `id`
     * const doNotEngageAgentWithIdOnly = await prisma.doNotEngageAgent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoNotEngageAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, DoNotEngageAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoNotEngageAgent.
     * @param {DoNotEngageAgentDeleteArgs} args - Arguments to delete one DoNotEngageAgent.
     * @example
     * // Delete one DoNotEngageAgent
     * const DoNotEngageAgent = await prisma.doNotEngageAgent.delete({
     *   where: {
     *     // ... filter to delete one DoNotEngageAgent
     *   }
     * })
     * 
     */
    delete<T extends DoNotEngageAgentDeleteArgs>(args: SelectSubset<T, DoNotEngageAgentDeleteArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoNotEngageAgent.
     * @param {DoNotEngageAgentUpdateArgs} args - Arguments to update one DoNotEngageAgent.
     * @example
     * // Update one DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoNotEngageAgentUpdateArgs>(args: SelectSubset<T, DoNotEngageAgentUpdateArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoNotEngageAgents.
     * @param {DoNotEngageAgentDeleteManyArgs} args - Arguments to filter DoNotEngageAgents to delete.
     * @example
     * // Delete a few DoNotEngageAgents
     * const { count } = await prisma.doNotEngageAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoNotEngageAgentDeleteManyArgs>(args?: SelectSubset<T, DoNotEngageAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoNotEngageAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoNotEngageAgents
     * const doNotEngageAgent = await prisma.doNotEngageAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoNotEngageAgentUpdateManyArgs>(args: SelectSubset<T, DoNotEngageAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoNotEngageAgent.
     * @param {DoNotEngageAgentUpsertArgs} args - Arguments to update or create a DoNotEngageAgent.
     * @example
     * // Update or create a DoNotEngageAgent
     * const doNotEngageAgent = await prisma.doNotEngageAgent.upsert({
     *   create: {
     *     // ... data to create a DoNotEngageAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoNotEngageAgent we want to update
     *   }
     * })
     */
    upsert<T extends DoNotEngageAgentUpsertArgs>(args: SelectSubset<T, DoNotEngageAgentUpsertArgs<ExtArgs>>): Prisma__DoNotEngageAgentClient<$Result.GetResult<Prisma.$DoNotEngageAgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoNotEngageAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentCountArgs} args - Arguments to filter DoNotEngageAgents to count.
     * @example
     * // Count the number of DoNotEngageAgents
     * const count = await prisma.doNotEngageAgent.count({
     *   where: {
     *     // ... the filter for the DoNotEngageAgents we want to count
     *   }
     * })
    **/
    count<T extends DoNotEngageAgentCountArgs>(
      args?: Subset<T, DoNotEngageAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoNotEngageAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoNotEngageAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoNotEngageAgentAggregateArgs>(args: Subset<T, DoNotEngageAgentAggregateArgs>): Prisma.PrismaPromise<GetDoNotEngageAgentAggregateType<T>>

    /**
     * Group by DoNotEngageAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoNotEngageAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoNotEngageAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoNotEngageAgentGroupByArgs['orderBy'] }
        : { orderBy?: DoNotEngageAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoNotEngageAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoNotEngageAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoNotEngageAgent model
   */
  readonly fields: DoNotEngageAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoNotEngageAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoNotEngageAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoNotEngageAgent model
   */ 
  interface DoNotEngageAgentFieldRefs {
    readonly id: FieldRef<"DoNotEngageAgent", 'String'>
    readonly personId: FieldRef<"DoNotEngageAgent", 'String'>
    readonly agentId: FieldRef<"DoNotEngageAgent", 'String'>
    readonly createdAt: FieldRef<"DoNotEngageAgent", 'DateTime'>
    readonly createdById: FieldRef<"DoNotEngageAgent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoNotEngageAgent findUnique
   */
  export type DoNotEngageAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageAgent to fetch.
     */
    where: DoNotEngageAgentWhereUniqueInput
  }

  /**
   * DoNotEngageAgent findUniqueOrThrow
   */
  export type DoNotEngageAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageAgent to fetch.
     */
    where: DoNotEngageAgentWhereUniqueInput
  }

  /**
   * DoNotEngageAgent findFirst
   */
  export type DoNotEngageAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageAgent to fetch.
     */
    where?: DoNotEngageAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageAgents to fetch.
     */
    orderBy?: DoNotEngageAgentOrderByWithRelationInput | DoNotEngageAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoNotEngageAgents.
     */
    cursor?: DoNotEngageAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoNotEngageAgents.
     */
    distinct?: DoNotEngageAgentScalarFieldEnum | DoNotEngageAgentScalarFieldEnum[]
  }

  /**
   * DoNotEngageAgent findFirstOrThrow
   */
  export type DoNotEngageAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageAgent to fetch.
     */
    where?: DoNotEngageAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageAgents to fetch.
     */
    orderBy?: DoNotEngageAgentOrderByWithRelationInput | DoNotEngageAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoNotEngageAgents.
     */
    cursor?: DoNotEngageAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoNotEngageAgents.
     */
    distinct?: DoNotEngageAgentScalarFieldEnum | DoNotEngageAgentScalarFieldEnum[]
  }

  /**
   * DoNotEngageAgent findMany
   */
  export type DoNotEngageAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter, which DoNotEngageAgents to fetch.
     */
    where?: DoNotEngageAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoNotEngageAgents to fetch.
     */
    orderBy?: DoNotEngageAgentOrderByWithRelationInput | DoNotEngageAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoNotEngageAgents.
     */
    cursor?: DoNotEngageAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoNotEngageAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoNotEngageAgents.
     */
    skip?: number
    distinct?: DoNotEngageAgentScalarFieldEnum | DoNotEngageAgentScalarFieldEnum[]
  }

  /**
   * DoNotEngageAgent create
   */
  export type DoNotEngageAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a DoNotEngageAgent.
     */
    data: XOR<DoNotEngageAgentCreateInput, DoNotEngageAgentUncheckedCreateInput>
  }

  /**
   * DoNotEngageAgent createMany
   */
  export type DoNotEngageAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoNotEngageAgents.
     */
    data: DoNotEngageAgentCreateManyInput | DoNotEngageAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoNotEngageAgent createManyAndReturn
   */
  export type DoNotEngageAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoNotEngageAgents.
     */
    data: DoNotEngageAgentCreateManyInput | DoNotEngageAgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoNotEngageAgent update
   */
  export type DoNotEngageAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a DoNotEngageAgent.
     */
    data: XOR<DoNotEngageAgentUpdateInput, DoNotEngageAgentUncheckedUpdateInput>
    /**
     * Choose, which DoNotEngageAgent to update.
     */
    where: DoNotEngageAgentWhereUniqueInput
  }

  /**
   * DoNotEngageAgent updateMany
   */
  export type DoNotEngageAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoNotEngageAgents.
     */
    data: XOR<DoNotEngageAgentUpdateManyMutationInput, DoNotEngageAgentUncheckedUpdateManyInput>
    /**
     * Filter which DoNotEngageAgents to update
     */
    where?: DoNotEngageAgentWhereInput
  }

  /**
   * DoNotEngageAgent upsert
   */
  export type DoNotEngageAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the DoNotEngageAgent to update in case it exists.
     */
    where: DoNotEngageAgentWhereUniqueInput
    /**
     * In case the DoNotEngageAgent found by the `where` argument doesn't exist, create a new DoNotEngageAgent with this data.
     */
    create: XOR<DoNotEngageAgentCreateInput, DoNotEngageAgentUncheckedCreateInput>
    /**
     * In case the DoNotEngageAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoNotEngageAgentUpdateInput, DoNotEngageAgentUncheckedUpdateInput>
  }

  /**
   * DoNotEngageAgent delete
   */
  export type DoNotEngageAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
    /**
     * Filter which DoNotEngageAgent to delete.
     */
    where: DoNotEngageAgentWhereUniqueInput
  }

  /**
   * DoNotEngageAgent deleteMany
   */
  export type DoNotEngageAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoNotEngageAgents to delete
     */
    where?: DoNotEngageAgentWhereInput
  }

  /**
   * DoNotEngageAgent without action
   */
  export type DoNotEngageAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoNotEngageAgent
     */
    select?: DoNotEngageAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoNotEngageAgentInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    workHoursPerWeek: number | null
    commuteMinutes: number | null
  }

  export type StudentSumAggregateOutputType = {
    workHoursPerWeek: number | null
    commuteMinutes: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    status: string | null
    startOn: Date | null
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string | null
    isFirstGen: boolean | null
    isPellEligible: boolean | null
    isInState: boolean | null
    workHoursPerWeek: number | null
    commuteMinutes: number | null
    hasHousingInstability: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    type: string | null
    status: string | null
    startOn: Date | null
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string | null
    isFirstGen: boolean | null
    isPellEligible: boolean | null
    isInState: boolean | null
    workHoursPerWeek: number | null
    commuteMinutes: number | null
    hasHousingInstability: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    personId: number
    type: number
    status: number
    startOn: number
    entryAcademicPeriodId: number
    academicLevel: number
    residency: number
    studentClassification: number
    studentLoad: number
    academicStandingCode: number
    studentNumber: number
    isFirstGen: number
    isPellEligible: number
    isInState: number
    workHoursPerWeek: number
    commuteMinutes: number
    hasHousingInstability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    workHoursPerWeek?: true
    commuteMinutes?: true
  }

  export type StudentSumAggregateInputType = {
    workHoursPerWeek?: true
    commuteMinutes?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    personId?: true
    type?: true
    status?: true
    startOn?: true
    entryAcademicPeriodId?: true
    academicLevel?: true
    residency?: true
    studentClassification?: true
    studentLoad?: true
    academicStandingCode?: true
    studentNumber?: true
    isFirstGen?: true
    isPellEligible?: true
    isInState?: true
    workHoursPerWeek?: true
    commuteMinutes?: true
    hasHousingInstability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    personId: string
    type: string
    status: string
    startOn: Date
    entryAcademicPeriodId: string | null
    academicLevel: string | null
    residency: string | null
    studentClassification: string | null
    studentLoad: string | null
    academicStandingCode: string | null
    studentNumber: string
    isFirstGen: boolean
    isPellEligible: boolean
    isInState: boolean
    workHoursPerWeek: number
    commuteMinutes: number
    hasHousingInstability: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
    sectionRegistrations?: boolean | Student$sectionRegistrationsArgs<ExtArgs>
    studentAcademicPrograms?: boolean | Student$studentAcademicProgramsArgs<ExtArgs>
    academicCredentials?: boolean | Student$academicCredentialsArgs<ExtArgs>
    transcriptGrades?: boolean | Student$transcriptGradesArgs<ExtArgs>
    studentRisks?: boolean | Student$studentRisksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    personId?: boolean
    type?: boolean
    status?: boolean
    startOn?: boolean
    entryAcademicPeriodId?: boolean
    academicLevel?: boolean
    residency?: boolean
    studentClassification?: boolean
    studentLoad?: boolean
    academicStandingCode?: boolean
    studentNumber?: boolean
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: boolean
    commuteMinutes?: boolean
    hasHousingInstability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
    sectionRegistrations?: boolean | Student$sectionRegistrationsArgs<ExtArgs>
    studentAcademicPrograms?: boolean | Student$studentAcademicProgramsArgs<ExtArgs>
    academicCredentials?: boolean | Student$academicCredentialsArgs<ExtArgs>
    transcriptGrades?: boolean | Student$transcriptGradesArgs<ExtArgs>
    studentRisks?: boolean | Student$studentRisksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    entryAcademicPeriod?: boolean | Student$entryAcademicPeriodArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      entryAcademicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      studentAcademicPrograms: Prisma.$StudentAcademicProgramPayload<ExtArgs>[]
      academicCredentials: Prisma.$AcademicCredentialPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
      studentRisks: Prisma.$StudentRiskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personId: string
      type: string
      status: string
      startOn: Date
      entryAcademicPeriodId: string | null
      academicLevel: string | null
      residency: string | null
      studentClassification: string | null
      studentLoad: string | null
      academicStandingCode: string | null
      studentNumber: string
      isFirstGen: boolean
      isPellEligible: boolean
      isInState: boolean
      workHoursPerWeek: number
      commuteMinutes: number
      hasHousingInstability: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    entryAcademicPeriod<T extends Student$entryAcademicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, Student$entryAcademicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sectionRegistrations<T extends Student$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    studentAcademicPrograms<T extends Student$studentAcademicProgramsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentAcademicProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany"> | Null>
    academicCredentials<T extends Student$academicCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, Student$academicCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany"> | Null>
    transcriptGrades<T extends Student$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Student$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany"> | Null>
    studentRisks<T extends Student$studentRisksArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentRisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly personId: FieldRef<"Student", 'String'>
    readonly type: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'String'>
    readonly startOn: FieldRef<"Student", 'DateTime'>
    readonly entryAcademicPeriodId: FieldRef<"Student", 'String'>
    readonly academicLevel: FieldRef<"Student", 'String'>
    readonly residency: FieldRef<"Student", 'String'>
    readonly studentClassification: FieldRef<"Student", 'String'>
    readonly studentLoad: FieldRef<"Student", 'String'>
    readonly academicStandingCode: FieldRef<"Student", 'String'>
    readonly studentNumber: FieldRef<"Student", 'String'>
    readonly isFirstGen: FieldRef<"Student", 'Boolean'>
    readonly isPellEligible: FieldRef<"Student", 'Boolean'>
    readonly isInState: FieldRef<"Student", 'Boolean'>
    readonly workHoursPerWeek: FieldRef<"Student", 'Int'>
    readonly commuteMinutes: FieldRef<"Student", 'Int'>
    readonly hasHousingInstability: FieldRef<"Student", 'Boolean'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.entryAcademicPeriod
   */
  export type Student$entryAcademicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * Student.sectionRegistrations
   */
  export type Student$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * Student.studentAcademicPrograms
   */
  export type Student$studentAcademicProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    cursor?: StudentAcademicProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * Student.academicCredentials
   */
  export type Student$academicCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * Student.transcriptGrades
   */
  export type Student$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Student.studentRisks
   */
  export type Student$studentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    cursor?: StudentRiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model AcademicPeriod
   */

  export type AggregateAcademicPeriod = {
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  export type AcademicPeriodMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    startOn: Date | null
    endOn: Date | null
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicPeriodMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    startOn: Date | null
    endOn: Date | null
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicPeriodCountAggregateOutputType = {
    id: number
    code: number
    title: number
    type: number
    startOn: number
    endOn: number
    censusOn: number
    registrationStartOn: number
    registrationEndOn: number
    academicYear: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicPeriodMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicPeriodMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicPeriodCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    startOn?: true
    endOn?: true
    censusOn?: true
    registrationStartOn?: true
    registrationEndOn?: true
    academicYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriod to aggregate.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPeriods
    **/
    _count?: true | AcademicPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type GetAcademicPeriodAggregateType<T extends AcademicPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicPeriod[P]>
      : GetScalarType<T[P], AggregateAcademicPeriod[P]>
  }




  export type AcademicPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPeriodWhereInput
    orderBy?: AcademicPeriodOrderByWithAggregationInput | AcademicPeriodOrderByWithAggregationInput[]
    by: AcademicPeriodScalarFieldEnum[] | AcademicPeriodScalarFieldEnum
    having?: AcademicPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicPeriodCountAggregateInputType | true
    _min?: AcademicPeriodMinAggregateInputType
    _max?: AcademicPeriodMaxAggregateInputType
  }

  export type AcademicPeriodGroupByOutputType = {
    id: string
    code: string
    title: string
    type: string
    startOn: Date
    endOn: Date
    censusOn: Date | null
    registrationStartOn: Date | null
    registrationEndOn: Date | null
    academicYear: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicPeriodCountAggregateOutputType | null
    _min: AcademicPeriodMinAggregateOutputType | null
    _max: AcademicPeriodMaxAggregateOutputType | null
  }

  type GetAcademicPeriodGroupByPayload<T extends AcademicPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicPeriodGroupByOutputType[P]>
        }
      >
    >


  export type AcademicPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | AcademicPeriod$sectionsArgs<ExtArgs>
    sectionRegistrations?: boolean | AcademicPeriod$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | AcademicPeriod$transcriptGradesArgs<ExtArgs>
    entryStudents?: boolean | AcademicPeriod$entryStudentsArgs<ExtArgs>
    credentialPeriods?: boolean | AcademicPeriod$credentialPeriodsArgs<ExtArgs>
    studentRisks?: boolean | AcademicPeriod$studentRisksArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicPeriod"]>

  export type AcademicPeriodSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    startOn?: boolean
    endOn?: boolean
    censusOn?: boolean
    registrationStartOn?: boolean
    registrationEndOn?: boolean
    academicYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AcademicPeriod$sectionsArgs<ExtArgs>
    sectionRegistrations?: boolean | AcademicPeriod$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | AcademicPeriod$transcriptGradesArgs<ExtArgs>
    entryStudents?: boolean | AcademicPeriod$entryStudentsArgs<ExtArgs>
    credentialPeriods?: boolean | AcademicPeriod$credentialPeriodsArgs<ExtArgs>
    studentRisks?: boolean | AcademicPeriod$studentRisksArgs<ExtArgs>
    _count?: boolean | AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicPeriod"
    objects: {
      sections: Prisma.$SectionPayload<ExtArgs>[]
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
      entryStudents: Prisma.$StudentPayload<ExtArgs>[]
      credentialPeriods: Prisma.$AcademicCredentialPayload<ExtArgs>[]
      studentRisks: Prisma.$StudentRiskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      type: string
      startOn: Date
      endOn: Date
      censusOn: Date | null
      registrationStartOn: Date | null
      registrationEndOn: Date | null
      academicYear: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicPeriod"]>
    composites: {}
  }

  type AcademicPeriodGetPayload<S extends boolean | null | undefined | AcademicPeriodDefaultArgs> = $Result.GetResult<Prisma.$AcademicPeriodPayload, S>

  type AcademicPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicPeriodCountAggregateInputType | true
    }

  export interface AcademicPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicPeriod'], meta: { name: 'AcademicPeriod' } }
    /**
     * Find zero or one AcademicPeriod that matches the filter.
     * @param {AcademicPeriodFindUniqueArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicPeriodFindUniqueArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicPeriodFindUniqueOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicPeriodFindFirstArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindFirstOrThrowArgs} args - Arguments to find a AcademicPeriod
     * @example
     * // Get one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany()
     * 
     * // Get first 10 AcademicPeriods
     * const academicPeriods = await prisma.academicPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicPeriodFindManyArgs>(args?: SelectSubset<T, AcademicPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicPeriod.
     * @param {AcademicPeriodCreateArgs} args - Arguments to create a AcademicPeriod.
     * @example
     * // Create one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.create({
     *   data: {
     *     // ... data to create a AcademicPeriod
     *   }
     * })
     * 
     */
    create<T extends AcademicPeriodCreateArgs>(args: SelectSubset<T, AcademicPeriodCreateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicPeriods.
     * @param {AcademicPeriodCreateManyArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicPeriodCreateManyArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPeriods and returns the data saved in the database.
     * @param {AcademicPeriodCreateManyAndReturnArgs} args - Arguments to create many AcademicPeriods.
     * @example
     * // Create many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPeriods and only return the `id`
     * const academicPeriodWithIdOnly = await prisma.academicPeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicPeriod.
     * @param {AcademicPeriodDeleteArgs} args - Arguments to delete one AcademicPeriod.
     * @example
     * // Delete one AcademicPeriod
     * const AcademicPeriod = await prisma.academicPeriod.delete({
     *   where: {
     *     // ... filter to delete one AcademicPeriod
     *   }
     * })
     * 
     */
    delete<T extends AcademicPeriodDeleteArgs>(args: SelectSubset<T, AcademicPeriodDeleteArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicPeriod.
     * @param {AcademicPeriodUpdateArgs} args - Arguments to update one AcademicPeriod.
     * @example
     * // Update one AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicPeriodUpdateArgs>(args: SelectSubset<T, AcademicPeriodUpdateArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicPeriods.
     * @param {AcademicPeriodDeleteManyArgs} args - Arguments to filter AcademicPeriods to delete.
     * @example
     * // Delete a few AcademicPeriods
     * const { count } = await prisma.academicPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicPeriodDeleteManyArgs>(args?: SelectSubset<T, AcademicPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPeriods
     * const academicPeriod = await prisma.academicPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicPeriodUpdateManyArgs>(args: SelectSubset<T, AcademicPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicPeriod.
     * @param {AcademicPeriodUpsertArgs} args - Arguments to update or create a AcademicPeriod.
     * @example
     * // Update or create a AcademicPeriod
     * const academicPeriod = await prisma.academicPeriod.upsert({
     *   create: {
     *     // ... data to create a AcademicPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicPeriod we want to update
     *   }
     * })
     */
    upsert<T extends AcademicPeriodUpsertArgs>(args: SelectSubset<T, AcademicPeriodUpsertArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodCountArgs} args - Arguments to filter AcademicPeriods to count.
     * @example
     * // Count the number of AcademicPeriods
     * const count = await prisma.academicPeriod.count({
     *   where: {
     *     // ... the filter for the AcademicPeriods we want to count
     *   }
     * })
    **/
    count<T extends AcademicPeriodCountArgs>(
      args?: Subset<T, AcademicPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicPeriodAggregateArgs>(args: Subset<T, AcademicPeriodAggregateArgs>): Prisma.PrismaPromise<GetAcademicPeriodAggregateType<T>>

    /**
     * Group by AcademicPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicPeriodGroupByArgs['orderBy'] }
        : { orderBy?: AcademicPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicPeriod model
   */
  readonly fields: AcademicPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends AcademicPeriod$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany"> | Null>
    sectionRegistrations<T extends AcademicPeriod$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    transcriptGrades<T extends AcademicPeriod$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany"> | Null>
    entryStudents<T extends AcademicPeriod$entryStudentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$entryStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    credentialPeriods<T extends AcademicPeriod$credentialPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$credentialPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany"> | Null>
    studentRisks<T extends AcademicPeriod$studentRisksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriod$studentRisksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicPeriod model
   */ 
  interface AcademicPeriodFieldRefs {
    readonly id: FieldRef<"AcademicPeriod", 'String'>
    readonly code: FieldRef<"AcademicPeriod", 'String'>
    readonly title: FieldRef<"AcademicPeriod", 'String'>
    readonly type: FieldRef<"AcademicPeriod", 'String'>
    readonly startOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly endOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly censusOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly registrationStartOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly registrationEndOn: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly academicYear: FieldRef<"AcademicPeriod", 'String'>
    readonly status: FieldRef<"AcademicPeriod", 'String'>
    readonly createdAt: FieldRef<"AcademicPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicPeriod findUnique
   */
  export type AcademicPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findUniqueOrThrow
   */
  export type AcademicPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod findFirst
   */
  export type AcademicPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findFirstOrThrow
   */
  export type AcademicPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriod to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPeriods.
     */
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod findMany
   */
  export type AcademicPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPeriods to fetch.
     */
    where?: AcademicPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPeriods to fetch.
     */
    orderBy?: AcademicPeriodOrderByWithRelationInput | AcademicPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPeriods.
     */
    cursor?: AcademicPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPeriods.
     */
    skip?: number
    distinct?: AcademicPeriodScalarFieldEnum | AcademicPeriodScalarFieldEnum[]
  }

  /**
   * AcademicPeriod create
   */
  export type AcademicPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicPeriod.
     */
    data: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
  }

  /**
   * AcademicPeriod createMany
   */
  export type AcademicPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPeriod createManyAndReturn
   */
  export type AcademicPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicPeriods.
     */
    data: AcademicPeriodCreateManyInput | AcademicPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPeriod update
   */
  export type AcademicPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicPeriod.
     */
    data: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
    /**
     * Choose, which AcademicPeriod to update.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod updateMany
   */
  export type AcademicPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPeriods.
     */
    data: XOR<AcademicPeriodUpdateManyMutationInput, AcademicPeriodUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPeriods to update
     */
    where?: AcademicPeriodWhereInput
  }

  /**
   * AcademicPeriod upsert
   */
  export type AcademicPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicPeriod to update in case it exists.
     */
    where: AcademicPeriodWhereUniqueInput
    /**
     * In case the AcademicPeriod found by the `where` argument doesn't exist, create a new AcademicPeriod with this data.
     */
    create: XOR<AcademicPeriodCreateInput, AcademicPeriodUncheckedCreateInput>
    /**
     * In case the AcademicPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicPeriodUpdateInput, AcademicPeriodUncheckedUpdateInput>
  }

  /**
   * AcademicPeriod delete
   */
  export type AcademicPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    /**
     * Filter which AcademicPeriod to delete.
     */
    where: AcademicPeriodWhereUniqueInput
  }

  /**
   * AcademicPeriod deleteMany
   */
  export type AcademicPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPeriods to delete
     */
    where?: AcademicPeriodWhereInput
  }

  /**
   * AcademicPeriod.sections
   */
  export type AcademicPeriod$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.sectionRegistrations
   */
  export type AcademicPeriod$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.transcriptGrades
   */
  export type AcademicPeriod$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.entryStudents
   */
  export type AcademicPeriod$entryStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.credentialPeriods
   */
  export type AcademicPeriod$credentialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicPeriod.studentRisks
   */
  export type AcademicPeriod$studentRisksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    cursor?: StudentRiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * AcademicPeriod without action
   */
  export type AcademicPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
  }

  export type CourseSumAggregateOutputType = {
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    subjectCode: string | null
    number: string | null
    title: string | null
    description: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
    courseLevel: string | null
    status: string | null
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    subjectCode: string | null
    number: string | null
    title: string | null
    description: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    creditsIncrement: Decimal | null
    courseLevel: string | null
    status: string | null
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    subjectCode: number
    number: number
    title: number
    description: number
    creditType: number
    creditsMinimum: number
    creditsMaximum: number
    creditsIncrement: number
    courseLevel: number
    status: number
    effectiveStartDate: number
    effectiveEndDate: number
    catalogYear: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
  }

  export type CourseSumAggregateInputType = {
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    subjectCode?: true
    number?: true
    title?: true
    description?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    creditsIncrement?: true
    courseLevel?: true
    status?: true
    effectiveStartDate?: true
    effectiveEndDate?: true
    catalogYear?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    subjectCode: string
    number: string
    title: string
    description: string | null
    creditType: string
    creditsMinimum: Decimal
    creditsMaximum: Decimal
    creditsIncrement: Decimal | null
    courseLevel: string
    status: string
    effectiveStartDate: Date | null
    effectiveEndDate: Date | null
    catalogYear: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    transcriptGrades?: boolean | Course$transcriptGradesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    subjectCode?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    creditsIncrement?: boolean
    courseLevel?: boolean
    status?: boolean
    effectiveStartDate?: boolean
    effectiveEndDate?: boolean
    catalogYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | Course$sectionsArgs<ExtArgs>
    transcriptGrades?: boolean | Course$transcriptGradesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      sections: Prisma.$SectionPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectCode: string
      number: string
      title: string
      description: string | null
      creditType: string
      creditsMinimum: Prisma.Decimal
      creditsMaximum: Prisma.Decimal
      creditsIncrement: Prisma.Decimal | null
      courseLevel: string
      status: string
      effectiveStartDate: Date | null
      effectiveEndDate: Date | null
      catalogYear: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends Course$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany"> | Null>
    transcriptGrades<T extends Course$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Course$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly subjectCode: FieldRef<"Course", 'String'>
    readonly number: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly creditType: FieldRef<"Course", 'String'>
    readonly creditsMinimum: FieldRef<"Course", 'Decimal'>
    readonly creditsMaximum: FieldRef<"Course", 'Decimal'>
    readonly creditsIncrement: FieldRef<"Course", 'Decimal'>
    readonly courseLevel: FieldRef<"Course", 'String'>
    readonly status: FieldRef<"Course", 'String'>
    readonly effectiveStartDate: FieldRef<"Course", 'DateTime'>
    readonly effectiveEndDate: FieldRef<"Course", 'DateTime'>
    readonly catalogYear: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.sections
   */
  export type Course$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Course.transcriptGrades
   */
  export type Course$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
  }

  export type SectionSumAggregateOutputType = {
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicPeriodId: string | null
    number: string | null
    title: string | null
    crn: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    instructorPersonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicPeriodId: string | null
    number: string | null
    title: string | null
    crn: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    capacity: number | null
    enrolled: number | null
    available: number | null
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string | null
    creditsMinimum: Decimal | null
    creditsMaximum: Decimal | null
    instructorPersonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    courseId: number
    academicPeriodId: number
    number: number
    title: number
    crn: number
    startOn: number
    endOn: number
    status: number
    capacity: number
    enrolled: number
    available: number
    waitlistCapacity: number
    waitlistEnrolled: number
    instructionalMethodCode: number
    daysOfWeek: number
    startTime: number
    endTime: number
    building: number
    roomNumber: number
    creditType: number
    creditsMinimum: number
    creditsMaximum: number
    instructorPersonId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    creditsMinimum?: true
    creditsMaximum?: true
  }

  export type SectionSumAggregateInputType = {
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    creditsMinimum?: true
    creditsMaximum?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    courseId?: true
    academicPeriodId?: true
    number?: true
    title?: true
    crn?: true
    startOn?: true
    endOn?: true
    status?: true
    capacity?: true
    enrolled?: true
    available?: true
    waitlistCapacity?: true
    waitlistEnrolled?: true
    instructionalMethodCode?: true
    daysOfWeek?: true
    startTime?: true
    endTime?: true
    building?: true
    roomNumber?: true
    creditType?: true
    creditsMinimum?: true
    creditsMaximum?: true
    instructorPersonId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    courseId: string
    academicPeriodId: string
    number: string
    title: string | null
    crn: string
    startOn: Date
    endOn: Date
    status: string
    capacity: number
    enrolled: number
    available: number
    waitlistCapacity: number | null
    waitlistEnrolled: number | null
    instructionalMethodCode: string | null
    daysOfWeek: string[]
    startTime: string | null
    endTime: string | null
    building: string | null
    roomNumber: string | null
    creditType: string
    creditsMinimum: Decimal
    creditsMaximum: Decimal
    instructorPersonId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
    sectionRegistrations?: boolean | Section$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | Section$transcriptGradesArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    courseId?: boolean
    academicPeriodId?: boolean
    number?: boolean
    title?: boolean
    crn?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    capacity?: boolean
    enrolled?: boolean
    available?: boolean
    waitlistCapacity?: boolean
    waitlistEnrolled?: boolean
    instructionalMethodCode?: boolean
    daysOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    building?: boolean
    roomNumber?: boolean
    creditType?: boolean
    creditsMinimum?: boolean
    creditsMaximum?: boolean
    instructorPersonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
    sectionRegistrations?: boolean | Section$sectionRegistrationsArgs<ExtArgs>
    transcriptGrades?: boolean | Section$transcriptGradesArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    instructor?: boolean | Section$instructorArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      instructor: Prisma.$PersonPayload<ExtArgs> | null
      sectionRegistrations: Prisma.$SectionRegistrationPayload<ExtArgs>[]
      transcriptGrades: Prisma.$StudentTranscriptGradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      academicPeriodId: string
      number: string
      title: string | null
      crn: string
      startOn: Date
      endOn: Date
      status: string
      capacity: number
      enrolled: number
      available: number
      waitlistCapacity: number | null
      waitlistEnrolled: number | null
      instructionalMethodCode: string | null
      daysOfWeek: string[]
      startTime: string | null
      endTime: string | null
      building: string | null
      roomNumber: string | null
      creditType: string
      creditsMinimum: Prisma.Decimal
      creditsMaximum: Prisma.Decimal
      instructorPersonId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    instructor<T extends Section$instructorArgs<ExtArgs> = {}>(args?: Subset<T, Section$instructorArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sectionRegistrations<T extends Section$sectionRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Section$sectionRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    transcriptGrades<T extends Section$transcriptGradesArgs<ExtArgs> = {}>(args?: Subset<T, Section$transcriptGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */ 
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly courseId: FieldRef<"Section", 'String'>
    readonly academicPeriodId: FieldRef<"Section", 'String'>
    readonly number: FieldRef<"Section", 'String'>
    readonly title: FieldRef<"Section", 'String'>
    readonly crn: FieldRef<"Section", 'String'>
    readonly startOn: FieldRef<"Section", 'DateTime'>
    readonly endOn: FieldRef<"Section", 'DateTime'>
    readonly status: FieldRef<"Section", 'String'>
    readonly capacity: FieldRef<"Section", 'Int'>
    readonly enrolled: FieldRef<"Section", 'Int'>
    readonly available: FieldRef<"Section", 'Int'>
    readonly waitlistCapacity: FieldRef<"Section", 'Int'>
    readonly waitlistEnrolled: FieldRef<"Section", 'Int'>
    readonly instructionalMethodCode: FieldRef<"Section", 'String'>
    readonly daysOfWeek: FieldRef<"Section", 'String[]'>
    readonly startTime: FieldRef<"Section", 'String'>
    readonly endTime: FieldRef<"Section", 'String'>
    readonly building: FieldRef<"Section", 'String'>
    readonly roomNumber: FieldRef<"Section", 'String'>
    readonly creditType: FieldRef<"Section", 'String'>
    readonly creditsMinimum: FieldRef<"Section", 'Decimal'>
    readonly creditsMaximum: FieldRef<"Section", 'Decimal'>
    readonly instructorPersonId: FieldRef<"Section", 'String'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
  }

  /**
   * Section.instructor
   */
  export type Section$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * Section.sectionRegistrations
   */
  export type Section$sectionRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    cursor?: SectionRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * Section.transcriptGrades
   */
  export type Section$transcriptGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    cursor?: StudentTranscriptGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model SectionRegistration
   */

  export type AggregateSectionRegistration = {
    _count: SectionRegistrationCountAggregateOutputType | null
    _avg: SectionRegistrationAvgAggregateOutputType | null
    _sum: SectionRegistrationSumAggregateOutputType | null
    _min: SectionRegistrationMinAggregateOutputType | null
    _max: SectionRegistrationMaxAggregateOutputType | null
  }

  export type SectionRegistrationAvgAggregateOutputType = {
    credits: Decimal | null
    attendanceRate: number | null
  }

  export type SectionRegistrationSumAggregateOutputType = {
    credits: Decimal | null
    attendanceRate: number | null
  }

  export type SectionRegistrationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    statusCode: string | null
    registrationDate: Date | null
    registeredOn: Date | null
    creditType: string | null
    credits: Decimal | null
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionRegistrationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    statusCode: string | null
    registrationDate: Date | null
    registeredOn: Date | null
    creditType: string | null
    credits: Decimal | null
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionRegistrationCountAggregateOutputType = {
    id: number
    studentId: number
    sectionId: number
    academicPeriodId: number
    statusCode: number
    registrationDate: number
    registeredOn: number
    creditType: number
    credits: number
    gradingOptionCode: number
    academicLoad: number
    residencyStatus: number
    attendanceRate: number
    midtermGrade: number
    finalGrade: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionRegistrationAvgAggregateInputType = {
    credits?: true
    attendanceRate?: true
  }

  export type SectionRegistrationSumAggregateInputType = {
    credits?: true
    attendanceRate?: true
  }

  export type SectionRegistrationMinAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionRegistrationMaxAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionRegistrationCountAggregateInputType = {
    id?: true
    studentId?: true
    sectionId?: true
    academicPeriodId?: true
    statusCode?: true
    registrationDate?: true
    registeredOn?: true
    creditType?: true
    credits?: true
    gradingOptionCode?: true
    academicLoad?: true
    residencyStatus?: true
    attendanceRate?: true
    midtermGrade?: true
    finalGrade?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionRegistration to aggregate.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectionRegistrations
    **/
    _count?: true | SectionRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionRegistrationMaxAggregateInputType
  }

  export type GetSectionRegistrationAggregateType<T extends SectionRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSectionRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectionRegistration[P]>
      : GetScalarType<T[P], AggregateSectionRegistration[P]>
  }




  export type SectionRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionRegistrationWhereInput
    orderBy?: SectionRegistrationOrderByWithAggregationInput | SectionRegistrationOrderByWithAggregationInput[]
    by: SectionRegistrationScalarFieldEnum[] | SectionRegistrationScalarFieldEnum
    having?: SectionRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionRegistrationCountAggregateInputType | true
    _avg?: SectionRegistrationAvgAggregateInputType
    _sum?: SectionRegistrationSumAggregateInputType
    _min?: SectionRegistrationMinAggregateInputType
    _max?: SectionRegistrationMaxAggregateInputType
  }

  export type SectionRegistrationGroupByOutputType = {
    id: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date
    registeredOn: Date
    creditType: string
    credits: Decimal
    gradingOptionCode: string | null
    academicLoad: string | null
    residencyStatus: string | null
    attendanceRate: number | null
    midtermGrade: string | null
    finalGrade: string | null
    createdAt: Date
    updatedAt: Date
    _count: SectionRegistrationCountAggregateOutputType | null
    _avg: SectionRegistrationAvgAggregateOutputType | null
    _sum: SectionRegistrationSumAggregateOutputType | null
    _min: SectionRegistrationMinAggregateOutputType | null
    _max: SectionRegistrationMaxAggregateOutputType | null
  }

  type GetSectionRegistrationGroupByPayload<T extends SectionRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], SectionRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type SectionRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    transcriptGrade?: boolean | SectionRegistration$transcriptGradeArgs<ExtArgs>
  }, ExtArgs["result"]["sectionRegistration"]>

  export type SectionRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectionRegistration"]>

  export type SectionRegistrationSelectScalar = {
    id?: boolean
    studentId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    statusCode?: boolean
    registrationDate?: boolean
    registeredOn?: boolean
    creditType?: boolean
    credits?: boolean
    gradingOptionCode?: boolean
    academicLoad?: boolean
    residencyStatus?: boolean
    attendanceRate?: boolean
    midtermGrade?: boolean
    finalGrade?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    transcriptGrade?: boolean | SectionRegistration$transcriptGradeArgs<ExtArgs>
  }
  export type SectionRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }

  export type $SectionRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectionRegistration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      transcriptGrade: Prisma.$StudentTranscriptGradePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sectionId: string
      academicPeriodId: string
      statusCode: string
      registrationDate: Date
      registeredOn: Date
      creditType: string
      credits: Prisma.Decimal
      gradingOptionCode: string | null
      academicLoad: string | null
      residencyStatus: string | null
      attendanceRate: number | null
      midtermGrade: string | null
      finalGrade: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sectionRegistration"]>
    composites: {}
  }

  type SectionRegistrationGetPayload<S extends boolean | null | undefined | SectionRegistrationDefaultArgs> = $Result.GetResult<Prisma.$SectionRegistrationPayload, S>

  type SectionRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionRegistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionRegistrationCountAggregateInputType | true
    }

  export interface SectionRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionRegistration'], meta: { name: 'SectionRegistration' } }
    /**
     * Find zero or one SectionRegistration that matches the filter.
     * @param {SectionRegistrationFindUniqueArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionRegistrationFindUniqueArgs>(args: SelectSubset<T, SectionRegistrationFindUniqueArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SectionRegistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionRegistrationFindUniqueOrThrowArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SectionRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindFirstArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionRegistrationFindFirstArgs>(args?: SelectSubset<T, SectionRegistrationFindFirstArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SectionRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindFirstOrThrowArgs} args - Arguments to find a SectionRegistration
     * @example
     * // Get one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SectionRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectionRegistrations
     * const sectionRegistrations = await prisma.sectionRegistration.findMany()
     * 
     * // Get first 10 SectionRegistrations
     * const sectionRegistrations = await prisma.sectionRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionRegistrationWithIdOnly = await prisma.sectionRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionRegistrationFindManyArgs>(args?: SelectSubset<T, SectionRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SectionRegistration.
     * @param {SectionRegistrationCreateArgs} args - Arguments to create a SectionRegistration.
     * @example
     * // Create one SectionRegistration
     * const SectionRegistration = await prisma.sectionRegistration.create({
     *   data: {
     *     // ... data to create a SectionRegistration
     *   }
     * })
     * 
     */
    create<T extends SectionRegistrationCreateArgs>(args: SelectSubset<T, SectionRegistrationCreateArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SectionRegistrations.
     * @param {SectionRegistrationCreateManyArgs} args - Arguments to create many SectionRegistrations.
     * @example
     * // Create many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionRegistrationCreateManyArgs>(args?: SelectSubset<T, SectionRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SectionRegistrations and returns the data saved in the database.
     * @param {SectionRegistrationCreateManyAndReturnArgs} args - Arguments to create many SectionRegistrations.
     * @example
     * // Create many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SectionRegistrations and only return the `id`
     * const sectionRegistrationWithIdOnly = await prisma.sectionRegistration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SectionRegistration.
     * @param {SectionRegistrationDeleteArgs} args - Arguments to delete one SectionRegistration.
     * @example
     * // Delete one SectionRegistration
     * const SectionRegistration = await prisma.sectionRegistration.delete({
     *   where: {
     *     // ... filter to delete one SectionRegistration
     *   }
     * })
     * 
     */
    delete<T extends SectionRegistrationDeleteArgs>(args: SelectSubset<T, SectionRegistrationDeleteArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SectionRegistration.
     * @param {SectionRegistrationUpdateArgs} args - Arguments to update one SectionRegistration.
     * @example
     * // Update one SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionRegistrationUpdateArgs>(args: SelectSubset<T, SectionRegistrationUpdateArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SectionRegistrations.
     * @param {SectionRegistrationDeleteManyArgs} args - Arguments to filter SectionRegistrations to delete.
     * @example
     * // Delete a few SectionRegistrations
     * const { count } = await prisma.sectionRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionRegistrationDeleteManyArgs>(args?: SelectSubset<T, SectionRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectionRegistrations
     * const sectionRegistration = await prisma.sectionRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionRegistrationUpdateManyArgs>(args: SelectSubset<T, SectionRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SectionRegistration.
     * @param {SectionRegistrationUpsertArgs} args - Arguments to update or create a SectionRegistration.
     * @example
     * // Update or create a SectionRegistration
     * const sectionRegistration = await prisma.sectionRegistration.upsert({
     *   create: {
     *     // ... data to create a SectionRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectionRegistration we want to update
     *   }
     * })
     */
    upsert<T extends SectionRegistrationUpsertArgs>(args: SelectSubset<T, SectionRegistrationUpsertArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SectionRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationCountArgs} args - Arguments to filter SectionRegistrations to count.
     * @example
     * // Count the number of SectionRegistrations
     * const count = await prisma.sectionRegistration.count({
     *   where: {
     *     // ... the filter for the SectionRegistrations we want to count
     *   }
     * })
    **/
    count<T extends SectionRegistrationCountArgs>(
      args?: Subset<T, SectionRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectionRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionRegistrationAggregateArgs>(args: Subset<T, SectionRegistrationAggregateArgs>): Prisma.PrismaPromise<GetSectionRegistrationAggregateType<T>>

    /**
     * Group by SectionRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: SectionRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectionRegistration model
   */
  readonly fields: SectionRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectionRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transcriptGrade<T extends SectionRegistration$transcriptGradeArgs<ExtArgs> = {}>(args?: Subset<T, SectionRegistration$transcriptGradeArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectionRegistration model
   */ 
  interface SectionRegistrationFieldRefs {
    readonly id: FieldRef<"SectionRegistration", 'String'>
    readonly studentId: FieldRef<"SectionRegistration", 'String'>
    readonly sectionId: FieldRef<"SectionRegistration", 'String'>
    readonly academicPeriodId: FieldRef<"SectionRegistration", 'String'>
    readonly statusCode: FieldRef<"SectionRegistration", 'String'>
    readonly registrationDate: FieldRef<"SectionRegistration", 'DateTime'>
    readonly registeredOn: FieldRef<"SectionRegistration", 'DateTime'>
    readonly creditType: FieldRef<"SectionRegistration", 'String'>
    readonly credits: FieldRef<"SectionRegistration", 'Decimal'>
    readonly gradingOptionCode: FieldRef<"SectionRegistration", 'String'>
    readonly academicLoad: FieldRef<"SectionRegistration", 'String'>
    readonly residencyStatus: FieldRef<"SectionRegistration", 'String'>
    readonly attendanceRate: FieldRef<"SectionRegistration", 'Float'>
    readonly midtermGrade: FieldRef<"SectionRegistration", 'String'>
    readonly finalGrade: FieldRef<"SectionRegistration", 'String'>
    readonly createdAt: FieldRef<"SectionRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"SectionRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SectionRegistration findUnique
   */
  export type SectionRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration findUniqueOrThrow
   */
  export type SectionRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration findFirst
   */
  export type SectionRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionRegistrations.
     */
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration findFirstOrThrow
   */
  export type SectionRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistration to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionRegistrations.
     */
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration findMany
   */
  export type SectionRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SectionRegistrations to fetch.
     */
    where?: SectionRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionRegistrations to fetch.
     */
    orderBy?: SectionRegistrationOrderByWithRelationInput | SectionRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectionRegistrations.
     */
    cursor?: SectionRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionRegistrations.
     */
    skip?: number
    distinct?: SectionRegistrationScalarFieldEnum | SectionRegistrationScalarFieldEnum[]
  }

  /**
   * SectionRegistration create
   */
  export type SectionRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a SectionRegistration.
     */
    data: XOR<SectionRegistrationCreateInput, SectionRegistrationUncheckedCreateInput>
  }

  /**
   * SectionRegistration createMany
   */
  export type SectionRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectionRegistrations.
     */
    data: SectionRegistrationCreateManyInput | SectionRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectionRegistration createManyAndReturn
   */
  export type SectionRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SectionRegistrations.
     */
    data: SectionRegistrationCreateManyInput | SectionRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SectionRegistration update
   */
  export type SectionRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a SectionRegistration.
     */
    data: XOR<SectionRegistrationUpdateInput, SectionRegistrationUncheckedUpdateInput>
    /**
     * Choose, which SectionRegistration to update.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration updateMany
   */
  export type SectionRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectionRegistrations.
     */
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SectionRegistrations to update
     */
    where?: SectionRegistrationWhereInput
  }

  /**
   * SectionRegistration upsert
   */
  export type SectionRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the SectionRegistration to update in case it exists.
     */
    where: SectionRegistrationWhereUniqueInput
    /**
     * In case the SectionRegistration found by the `where` argument doesn't exist, create a new SectionRegistration with this data.
     */
    create: XOR<SectionRegistrationCreateInput, SectionRegistrationUncheckedCreateInput>
    /**
     * In case the SectionRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionRegistrationUpdateInput, SectionRegistrationUncheckedUpdateInput>
  }

  /**
   * SectionRegistration delete
   */
  export type SectionRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
    /**
     * Filter which SectionRegistration to delete.
     */
    where: SectionRegistrationWhereUniqueInput
  }

  /**
   * SectionRegistration deleteMany
   */
  export type SectionRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionRegistrations to delete
     */
    where?: SectionRegistrationWhereInput
  }

  /**
   * SectionRegistration.transcriptGrade
   */
  export type SectionRegistration$transcriptGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * SectionRegistration without action
   */
  export type SectionRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionRegistration
     */
    select?: SectionRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model StudentTranscriptGrade
   */

  export type AggregateStudentTranscriptGrade = {
    _count: StudentTranscriptGradeCountAggregateOutputType | null
    _avg: StudentTranscriptGradeAvgAggregateOutputType | null
    _sum: StudentTranscriptGradeSumAggregateOutputType | null
    _min: StudentTranscriptGradeMinAggregateOutputType | null
    _max: StudentTranscriptGradeMaxAggregateOutputType | null
  }

  export type StudentTranscriptGradeAvgAggregateOutputType = {
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
  }

  export type StudentTranscriptGradeSumAggregateOutputType = {
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
  }

  export type StudentTranscriptGradeMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionRegistrationId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    courseId: string | null
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
    finalGradeDate: Date | null
    status: string | null
    incomplete: boolean | null
    repeat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTranscriptGradeMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sectionRegistrationId: string | null
    sectionId: string | null
    academicPeriodId: string | null
    courseId: string | null
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal | null
    creditsEarned: Decimal | null
    finalGradeDate: Date | null
    status: string | null
    incomplete: boolean | null
    repeat: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTranscriptGradeCountAggregateOutputType = {
    id: number
    studentId: number
    sectionRegistrationId: number
    sectionId: number
    academicPeriodId: number
    courseId: number
    gradeSchemeCode: number
    gradeValue: number
    gradePoints: number
    qualityPoints: number
    creditsAttempted: number
    creditsEarned: number
    finalGradeDate: number
    status: number
    incomplete: number
    repeat: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentTranscriptGradeAvgAggregateInputType = {
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
  }

  export type StudentTranscriptGradeSumAggregateInputType = {
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
  }

  export type StudentTranscriptGradeMinAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTranscriptGradeMaxAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTranscriptGradeCountAggregateInputType = {
    id?: true
    studentId?: true
    sectionRegistrationId?: true
    sectionId?: true
    academicPeriodId?: true
    courseId?: true
    gradeSchemeCode?: true
    gradeValue?: true
    gradePoints?: true
    qualityPoints?: true
    creditsAttempted?: true
    creditsEarned?: true
    finalGradeDate?: true
    status?: true
    incomplete?: true
    repeat?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentTranscriptGradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTranscriptGrade to aggregate.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTranscriptGrades
    **/
    _count?: true | StudentTranscriptGradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTranscriptGradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTranscriptGradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTranscriptGradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTranscriptGradeMaxAggregateInputType
  }

  export type GetStudentTranscriptGradeAggregateType<T extends StudentTranscriptGradeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTranscriptGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTranscriptGrade[P]>
      : GetScalarType<T[P], AggregateStudentTranscriptGrade[P]>
  }




  export type StudentTranscriptGradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTranscriptGradeWhereInput
    orderBy?: StudentTranscriptGradeOrderByWithAggregationInput | StudentTranscriptGradeOrderByWithAggregationInput[]
    by: StudentTranscriptGradeScalarFieldEnum[] | StudentTranscriptGradeScalarFieldEnum
    having?: StudentTranscriptGradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTranscriptGradeCountAggregateInputType | true
    _avg?: StudentTranscriptGradeAvgAggregateInputType
    _sum?: StudentTranscriptGradeSumAggregateInputType
    _min?: StudentTranscriptGradeMinAggregateInputType
    _max?: StudentTranscriptGradeMaxAggregateInputType
  }

  export type StudentTranscriptGradeGroupByOutputType = {
    id: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode: string | null
    gradeValue: string | null
    gradePoints: Decimal | null
    qualityPoints: Decimal | null
    creditsAttempted: Decimal
    creditsEarned: Decimal
    finalGradeDate: Date | null
    status: string
    incomplete: boolean
    repeat: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentTranscriptGradeCountAggregateOutputType | null
    _avg: StudentTranscriptGradeAvgAggregateOutputType | null
    _sum: StudentTranscriptGradeSumAggregateOutputType | null
    _min: StudentTranscriptGradeMinAggregateOutputType | null
    _max: StudentTranscriptGradeMaxAggregateOutputType | null
  }

  type GetStudentTranscriptGradeGroupByPayload<T extends StudentTranscriptGradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTranscriptGradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTranscriptGradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTranscriptGradeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTranscriptGradeGroupByOutputType[P]>
        }
      >
    >


  export type StudentTranscriptGradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTranscriptGrade"]>

  export type StudentTranscriptGradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTranscriptGrade"]>

  export type StudentTranscriptGradeSelectScalar = {
    id?: boolean
    studentId?: boolean
    sectionRegistrationId?: boolean
    sectionId?: boolean
    academicPeriodId?: boolean
    courseId?: boolean
    gradeSchemeCode?: boolean
    gradeValue?: boolean
    gradePoints?: boolean
    qualityPoints?: boolean
    creditsAttempted?: boolean
    creditsEarned?: boolean
    finalGradeDate?: boolean
    status?: boolean
    incomplete?: boolean
    repeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentTranscriptGradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type StudentTranscriptGradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    sectionRegistration?: boolean | SectionRegistrationDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $StudentTranscriptGradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTranscriptGrade"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      sectionRegistration: Prisma.$SectionRegistrationPayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sectionRegistrationId: string
      sectionId: string
      academicPeriodId: string
      courseId: string
      gradeSchemeCode: string | null
      gradeValue: string | null
      gradePoints: Prisma.Decimal | null
      qualityPoints: Prisma.Decimal | null
      creditsAttempted: Prisma.Decimal
      creditsEarned: Prisma.Decimal
      finalGradeDate: Date | null
      status: string
      incomplete: boolean
      repeat: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentTranscriptGrade"]>
    composites: {}
  }

  type StudentTranscriptGradeGetPayload<S extends boolean | null | undefined | StudentTranscriptGradeDefaultArgs> = $Result.GetResult<Prisma.$StudentTranscriptGradePayload, S>

  type StudentTranscriptGradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTranscriptGradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentTranscriptGradeCountAggregateInputType | true
    }

  export interface StudentTranscriptGradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTranscriptGrade'], meta: { name: 'StudentTranscriptGrade' } }
    /**
     * Find zero or one StudentTranscriptGrade that matches the filter.
     * @param {StudentTranscriptGradeFindUniqueArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTranscriptGradeFindUniqueArgs>(args: SelectSubset<T, StudentTranscriptGradeFindUniqueArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentTranscriptGrade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentTranscriptGradeFindUniqueOrThrowArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTranscriptGradeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentTranscriptGrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindFirstArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTranscriptGradeFindFirstArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindFirstArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentTranscriptGrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindFirstOrThrowArgs} args - Arguments to find a StudentTranscriptGrade
     * @example
     * // Get one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTranscriptGradeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentTranscriptGrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTranscriptGrades
     * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany()
     * 
     * // Get first 10 StudentTranscriptGrades
     * const studentTranscriptGrades = await prisma.studentTranscriptGrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTranscriptGradeWithIdOnly = await prisma.studentTranscriptGrade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTranscriptGradeFindManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentTranscriptGrade.
     * @param {StudentTranscriptGradeCreateArgs} args - Arguments to create a StudentTranscriptGrade.
     * @example
     * // Create one StudentTranscriptGrade
     * const StudentTranscriptGrade = await prisma.studentTranscriptGrade.create({
     *   data: {
     *     // ... data to create a StudentTranscriptGrade
     *   }
     * })
     * 
     */
    create<T extends StudentTranscriptGradeCreateArgs>(args: SelectSubset<T, StudentTranscriptGradeCreateArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentTranscriptGrades.
     * @param {StudentTranscriptGradeCreateManyArgs} args - Arguments to create many StudentTranscriptGrades.
     * @example
     * // Create many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTranscriptGradeCreateManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTranscriptGrades and returns the data saved in the database.
     * @param {StudentTranscriptGradeCreateManyAndReturnArgs} args - Arguments to create many StudentTranscriptGrades.
     * @example
     * // Create many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTranscriptGrades and only return the `id`
     * const studentTranscriptGradeWithIdOnly = await prisma.studentTranscriptGrade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTranscriptGradeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentTranscriptGrade.
     * @param {StudentTranscriptGradeDeleteArgs} args - Arguments to delete one StudentTranscriptGrade.
     * @example
     * // Delete one StudentTranscriptGrade
     * const StudentTranscriptGrade = await prisma.studentTranscriptGrade.delete({
     *   where: {
     *     // ... filter to delete one StudentTranscriptGrade
     *   }
     * })
     * 
     */
    delete<T extends StudentTranscriptGradeDeleteArgs>(args: SelectSubset<T, StudentTranscriptGradeDeleteArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentTranscriptGrade.
     * @param {StudentTranscriptGradeUpdateArgs} args - Arguments to update one StudentTranscriptGrade.
     * @example
     * // Update one StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTranscriptGradeUpdateArgs>(args: SelectSubset<T, StudentTranscriptGradeUpdateArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentTranscriptGrades.
     * @param {StudentTranscriptGradeDeleteManyArgs} args - Arguments to filter StudentTranscriptGrades to delete.
     * @example
     * // Delete a few StudentTranscriptGrades
     * const { count } = await prisma.studentTranscriptGrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTranscriptGradeDeleteManyArgs>(args?: SelectSubset<T, StudentTranscriptGradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTranscriptGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTranscriptGrades
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTranscriptGradeUpdateManyArgs>(args: SelectSubset<T, StudentTranscriptGradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTranscriptGrade.
     * @param {StudentTranscriptGradeUpsertArgs} args - Arguments to update or create a StudentTranscriptGrade.
     * @example
     * // Update or create a StudentTranscriptGrade
     * const studentTranscriptGrade = await prisma.studentTranscriptGrade.upsert({
     *   create: {
     *     // ... data to create a StudentTranscriptGrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTranscriptGrade we want to update
     *   }
     * })
     */
    upsert<T extends StudentTranscriptGradeUpsertArgs>(args: SelectSubset<T, StudentTranscriptGradeUpsertArgs<ExtArgs>>): Prisma__StudentTranscriptGradeClient<$Result.GetResult<Prisma.$StudentTranscriptGradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentTranscriptGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeCountArgs} args - Arguments to filter StudentTranscriptGrades to count.
     * @example
     * // Count the number of StudentTranscriptGrades
     * const count = await prisma.studentTranscriptGrade.count({
     *   where: {
     *     // ... the filter for the StudentTranscriptGrades we want to count
     *   }
     * })
    **/
    count<T extends StudentTranscriptGradeCountArgs>(
      args?: Subset<T, StudentTranscriptGradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTranscriptGradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTranscriptGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTranscriptGradeAggregateArgs>(args: Subset<T, StudentTranscriptGradeAggregateArgs>): Prisma.PrismaPromise<GetStudentTranscriptGradeAggregateType<T>>

    /**
     * Group by StudentTranscriptGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTranscriptGradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTranscriptGradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTranscriptGradeGroupByArgs['orderBy'] }
        : { orderBy?: StudentTranscriptGradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTranscriptGradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTranscriptGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTranscriptGrade model
   */
  readonly fields: StudentTranscriptGradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTranscriptGrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTranscriptGradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sectionRegistration<T extends SectionRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionRegistrationDefaultArgs<ExtArgs>>): Prisma__SectionRegistrationClient<$Result.GetResult<Prisma.$SectionRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTranscriptGrade model
   */ 
  interface StudentTranscriptGradeFieldRefs {
    readonly id: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly studentId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly sectionRegistrationId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly sectionId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly academicPeriodId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly courseId: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradeSchemeCode: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradeValue: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly gradePoints: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly qualityPoints: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly creditsAttempted: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly creditsEarned: FieldRef<"StudentTranscriptGrade", 'Decimal'>
    readonly finalGradeDate: FieldRef<"StudentTranscriptGrade", 'DateTime'>
    readonly status: FieldRef<"StudentTranscriptGrade", 'String'>
    readonly incomplete: FieldRef<"StudentTranscriptGrade", 'Boolean'>
    readonly repeat: FieldRef<"StudentTranscriptGrade", 'Boolean'>
    readonly createdAt: FieldRef<"StudentTranscriptGrade", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentTranscriptGrade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentTranscriptGrade findUnique
   */
  export type StudentTranscriptGradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade findUniqueOrThrow
   */
  export type StudentTranscriptGradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade findFirst
   */
  export type StudentTranscriptGradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTranscriptGrades.
     */
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade findFirstOrThrow
   */
  export type StudentTranscriptGradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrade to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTranscriptGrades.
     */
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade findMany
   */
  export type StudentTranscriptGradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter, which StudentTranscriptGrades to fetch.
     */
    where?: StudentTranscriptGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTranscriptGrades to fetch.
     */
    orderBy?: StudentTranscriptGradeOrderByWithRelationInput | StudentTranscriptGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTranscriptGrades.
     */
    cursor?: StudentTranscriptGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTranscriptGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTranscriptGrades.
     */
    skip?: number
    distinct?: StudentTranscriptGradeScalarFieldEnum | StudentTranscriptGradeScalarFieldEnum[]
  }

  /**
   * StudentTranscriptGrade create
   */
  export type StudentTranscriptGradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTranscriptGrade.
     */
    data: XOR<StudentTranscriptGradeCreateInput, StudentTranscriptGradeUncheckedCreateInput>
  }

  /**
   * StudentTranscriptGrade createMany
   */
  export type StudentTranscriptGradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTranscriptGrades.
     */
    data: StudentTranscriptGradeCreateManyInput | StudentTranscriptGradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTranscriptGrade createManyAndReturn
   */
  export type StudentTranscriptGradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentTranscriptGrades.
     */
    data: StudentTranscriptGradeCreateManyInput | StudentTranscriptGradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTranscriptGrade update
   */
  export type StudentTranscriptGradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTranscriptGrade.
     */
    data: XOR<StudentTranscriptGradeUpdateInput, StudentTranscriptGradeUncheckedUpdateInput>
    /**
     * Choose, which StudentTranscriptGrade to update.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade updateMany
   */
  export type StudentTranscriptGradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTranscriptGrades.
     */
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyInput>
    /**
     * Filter which StudentTranscriptGrades to update
     */
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * StudentTranscriptGrade upsert
   */
  export type StudentTranscriptGradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTranscriptGrade to update in case it exists.
     */
    where: StudentTranscriptGradeWhereUniqueInput
    /**
     * In case the StudentTranscriptGrade found by the `where` argument doesn't exist, create a new StudentTranscriptGrade with this data.
     */
    create: XOR<StudentTranscriptGradeCreateInput, StudentTranscriptGradeUncheckedCreateInput>
    /**
     * In case the StudentTranscriptGrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTranscriptGradeUpdateInput, StudentTranscriptGradeUncheckedUpdateInput>
  }

  /**
   * StudentTranscriptGrade delete
   */
  export type StudentTranscriptGradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
    /**
     * Filter which StudentTranscriptGrade to delete.
     */
    where: StudentTranscriptGradeWhereUniqueInput
  }

  /**
   * StudentTranscriptGrade deleteMany
   */
  export type StudentTranscriptGradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTranscriptGrades to delete
     */
    where?: StudentTranscriptGradeWhereInput
  }

  /**
   * StudentTranscriptGrade without action
   */
  export type StudentTranscriptGradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTranscriptGrade
     */
    select?: StudentTranscriptGradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTranscriptGradeInclude<ExtArgs> | null
  }


  /**
   * Model AcademicProgram
   */

  export type AggregateAcademicProgram = {
    _count: AcademicProgramCountAggregateOutputType | null
    _avg: AcademicProgramAvgAggregateOutputType | null
    _sum: AcademicProgramSumAggregateOutputType | null
    _min: AcademicProgramMinAggregateOutputType | null
    _max: AcademicProgramMaxAggregateOutputType | null
  }

  export type AcademicProgramAvgAggregateOutputType = {
    creditsRequired: number | null
  }

  export type AcademicProgramSumAggregateOutputType = {
    creditsRequired: number | null
  }

  export type AcademicProgramMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    level: string | null
    degreeCode: string | null
    status: string | null
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicProgramMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    type: string | null
    level: string | null
    degreeCode: string | null
    status: string | null
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicProgramCountAggregateOutputType = {
    id: number
    code: number
    title: number
    type: number
    level: number
    degreeCode: number
    status: number
    startOn: number
    endOn: number
    accreditationCode: number
    creditsRequired: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicProgramAvgAggregateInputType = {
    creditsRequired?: true
  }

  export type AcademicProgramSumAggregateInputType = {
    creditsRequired?: true
  }

  export type AcademicProgramMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicProgramMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicProgramCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    type?: true
    level?: true
    degreeCode?: true
    status?: true
    startOn?: true
    endOn?: true
    accreditationCode?: true
    creditsRequired?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicProgram to aggregate.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPrograms
    **/
    _count?: true | AcademicProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicProgramMaxAggregateInputType
  }

  export type GetAcademicProgramAggregateType<T extends AcademicProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicProgram[P]>
      : GetScalarType<T[P], AggregateAcademicProgram[P]>
  }




  export type AcademicProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicProgramWhereInput
    orderBy?: AcademicProgramOrderByWithAggregationInput | AcademicProgramOrderByWithAggregationInput[]
    by: AcademicProgramScalarFieldEnum[] | AcademicProgramScalarFieldEnum
    having?: AcademicProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicProgramCountAggregateInputType | true
    _avg?: AcademicProgramAvgAggregateInputType
    _sum?: AcademicProgramSumAggregateInputType
    _min?: AcademicProgramMinAggregateInputType
    _max?: AcademicProgramMaxAggregateInputType
  }

  export type AcademicProgramGroupByOutputType = {
    id: string
    code: string
    title: string
    type: string
    level: string
    degreeCode: string | null
    status: string
    startOn: Date | null
    endOn: Date | null
    accreditationCode: string | null
    creditsRequired: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AcademicProgramCountAggregateOutputType | null
    _avg: AcademicProgramAvgAggregateOutputType | null
    _sum: AcademicProgramSumAggregateOutputType | null
    _min: AcademicProgramMinAggregateOutputType | null
    _max: AcademicProgramMaxAggregateOutputType | null
  }

  type GetAcademicProgramGroupByPayload<T extends AcademicProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicProgramGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicProgramGroupByOutputType[P]>
        }
      >
    >


  export type AcademicProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentPrograms?: boolean | AcademicProgram$studentProgramsArgs<ExtArgs>
    credentials?: boolean | AcademicProgram$credentialsArgs<ExtArgs>
    _count?: boolean | AcademicProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicProgram"]>

  export type AcademicProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicProgram"]>

  export type AcademicProgramSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    type?: boolean
    level?: boolean
    degreeCode?: boolean
    status?: boolean
    startOn?: boolean
    endOn?: boolean
    accreditationCode?: boolean
    creditsRequired?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPrograms?: boolean | AcademicProgram$studentProgramsArgs<ExtArgs>
    credentials?: boolean | AcademicProgram$credentialsArgs<ExtArgs>
    _count?: boolean | AcademicProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicProgram"
    objects: {
      studentPrograms: Prisma.$StudentAcademicProgramPayload<ExtArgs>[]
      credentials: Prisma.$AcademicCredentialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      type: string
      level: string
      degreeCode: string | null
      status: string
      startOn: Date | null
      endOn: Date | null
      accreditationCode: string | null
      creditsRequired: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicProgram"]>
    composites: {}
  }

  type AcademicProgramGetPayload<S extends boolean | null | undefined | AcademicProgramDefaultArgs> = $Result.GetResult<Prisma.$AcademicProgramPayload, S>

  type AcademicProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicProgramCountAggregateInputType | true
    }

  export interface AcademicProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicProgram'], meta: { name: 'AcademicProgram' } }
    /**
     * Find zero or one AcademicProgram that matches the filter.
     * @param {AcademicProgramFindUniqueArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicProgramFindUniqueArgs>(args: SelectSubset<T, AcademicProgramFindUniqueArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicProgramFindUniqueOrThrowArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindFirstArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicProgramFindFirstArgs>(args?: SelectSubset<T, AcademicProgramFindFirstArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindFirstOrThrowArgs} args - Arguments to find a AcademicProgram
     * @example
     * // Get one AcademicProgram
     * const academicProgram = await prisma.academicProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPrograms
     * const academicPrograms = await prisma.academicProgram.findMany()
     * 
     * // Get first 10 AcademicPrograms
     * const academicPrograms = await prisma.academicProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicProgramWithIdOnly = await prisma.academicProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicProgramFindManyArgs>(args?: SelectSubset<T, AcademicProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicProgram.
     * @param {AcademicProgramCreateArgs} args - Arguments to create a AcademicProgram.
     * @example
     * // Create one AcademicProgram
     * const AcademicProgram = await prisma.academicProgram.create({
     *   data: {
     *     // ... data to create a AcademicProgram
     *   }
     * })
     * 
     */
    create<T extends AcademicProgramCreateArgs>(args: SelectSubset<T, AcademicProgramCreateArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicPrograms.
     * @param {AcademicProgramCreateManyArgs} args - Arguments to create many AcademicPrograms.
     * @example
     * // Create many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicProgramCreateManyArgs>(args?: SelectSubset<T, AcademicProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPrograms and returns the data saved in the database.
     * @param {AcademicProgramCreateManyAndReturnArgs} args - Arguments to create many AcademicPrograms.
     * @example
     * // Create many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPrograms and only return the `id`
     * const academicProgramWithIdOnly = await prisma.academicProgram.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicProgram.
     * @param {AcademicProgramDeleteArgs} args - Arguments to delete one AcademicProgram.
     * @example
     * // Delete one AcademicProgram
     * const AcademicProgram = await prisma.academicProgram.delete({
     *   where: {
     *     // ... filter to delete one AcademicProgram
     *   }
     * })
     * 
     */
    delete<T extends AcademicProgramDeleteArgs>(args: SelectSubset<T, AcademicProgramDeleteArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicProgram.
     * @param {AcademicProgramUpdateArgs} args - Arguments to update one AcademicProgram.
     * @example
     * // Update one AcademicProgram
     * const academicProgram = await prisma.academicProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicProgramUpdateArgs>(args: SelectSubset<T, AcademicProgramUpdateArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicPrograms.
     * @param {AcademicProgramDeleteManyArgs} args - Arguments to filter AcademicPrograms to delete.
     * @example
     * // Delete a few AcademicPrograms
     * const { count } = await prisma.academicProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicProgramDeleteManyArgs>(args?: SelectSubset<T, AcademicProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPrograms
     * const academicProgram = await prisma.academicProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicProgramUpdateManyArgs>(args: SelectSubset<T, AcademicProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicProgram.
     * @param {AcademicProgramUpsertArgs} args - Arguments to update or create a AcademicProgram.
     * @example
     * // Update or create a AcademicProgram
     * const academicProgram = await prisma.academicProgram.upsert({
     *   create: {
     *     // ... data to create a AcademicProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicProgram we want to update
     *   }
     * })
     */
    upsert<T extends AcademicProgramUpsertArgs>(args: SelectSubset<T, AcademicProgramUpsertArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramCountArgs} args - Arguments to filter AcademicPrograms to count.
     * @example
     * // Count the number of AcademicPrograms
     * const count = await prisma.academicProgram.count({
     *   where: {
     *     // ... the filter for the AcademicPrograms we want to count
     *   }
     * })
    **/
    count<T extends AcademicProgramCountArgs>(
      args?: Subset<T, AcademicProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicProgramAggregateArgs>(args: Subset<T, AcademicProgramAggregateArgs>): Prisma.PrismaPromise<GetAcademicProgramAggregateType<T>>

    /**
     * Group by AcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicProgramGroupByArgs['orderBy'] }
        : { orderBy?: AcademicProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicProgram model
   */
  readonly fields: AcademicProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentPrograms<T extends AcademicProgram$studentProgramsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgram$studentProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany"> | Null>
    credentials<T extends AcademicProgram$credentialsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgram$credentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicProgram model
   */ 
  interface AcademicProgramFieldRefs {
    readonly id: FieldRef<"AcademicProgram", 'String'>
    readonly code: FieldRef<"AcademicProgram", 'String'>
    readonly title: FieldRef<"AcademicProgram", 'String'>
    readonly type: FieldRef<"AcademicProgram", 'String'>
    readonly level: FieldRef<"AcademicProgram", 'String'>
    readonly degreeCode: FieldRef<"AcademicProgram", 'String'>
    readonly status: FieldRef<"AcademicProgram", 'String'>
    readonly startOn: FieldRef<"AcademicProgram", 'DateTime'>
    readonly endOn: FieldRef<"AcademicProgram", 'DateTime'>
    readonly accreditationCode: FieldRef<"AcademicProgram", 'String'>
    readonly creditsRequired: FieldRef<"AcademicProgram", 'Int'>
    readonly description: FieldRef<"AcademicProgram", 'String'>
    readonly createdAt: FieldRef<"AcademicProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicProgram findUnique
   */
  export type AcademicProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram findUniqueOrThrow
   */
  export type AcademicProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram findFirst
   */
  export type AcademicProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPrograms.
     */
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram findFirstOrThrow
   */
  export type AcademicProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicProgram to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPrograms.
     */
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram findMany
   */
  export type AcademicProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPrograms to fetch.
     */
    where?: AcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPrograms to fetch.
     */
    orderBy?: AcademicProgramOrderByWithRelationInput | AcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPrograms.
     */
    cursor?: AcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPrograms.
     */
    skip?: number
    distinct?: AcademicProgramScalarFieldEnum | AcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram create
   */
  export type AcademicProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicProgram.
     */
    data: XOR<AcademicProgramCreateInput, AcademicProgramUncheckedCreateInput>
  }

  /**
   * AcademicProgram createMany
   */
  export type AcademicProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPrograms.
     */
    data: AcademicProgramCreateManyInput | AcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicProgram createManyAndReturn
   */
  export type AcademicProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicPrograms.
     */
    data: AcademicProgramCreateManyInput | AcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicProgram update
   */
  export type AcademicProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicProgram.
     */
    data: XOR<AcademicProgramUpdateInput, AcademicProgramUncheckedUpdateInput>
    /**
     * Choose, which AcademicProgram to update.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram updateMany
   */
  export type AcademicProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPrograms.
     */
    data: XOR<AcademicProgramUpdateManyMutationInput, AcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPrograms to update
     */
    where?: AcademicProgramWhereInput
  }

  /**
   * AcademicProgram upsert
   */
  export type AcademicProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicProgram to update in case it exists.
     */
    where: AcademicProgramWhereUniqueInput
    /**
     * In case the AcademicProgram found by the `where` argument doesn't exist, create a new AcademicProgram with this data.
     */
    create: XOR<AcademicProgramCreateInput, AcademicProgramUncheckedCreateInput>
    /**
     * In case the AcademicProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicProgramUpdateInput, AcademicProgramUncheckedUpdateInput>
  }

  /**
   * AcademicProgram delete
   */
  export type AcademicProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    /**
     * Filter which AcademicProgram to delete.
     */
    where: AcademicProgramWhereUniqueInput
  }

  /**
   * AcademicProgram deleteMany
   */
  export type AcademicProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPrograms to delete
     */
    where?: AcademicProgramWhereInput
  }

  /**
   * AcademicProgram.studentPrograms
   */
  export type AcademicProgram$studentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    cursor?: StudentAcademicProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * AcademicProgram.credentials
   */
  export type AcademicProgram$credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    cursor?: AcademicCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicProgram without action
   */
  export type AcademicProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
  }


  /**
   * Model StudentAcademicProgram
   */

  export type AggregateStudentAcademicProgram = {
    _count: StudentAcademicProgramCountAggregateOutputType | null
    _min: StudentAcademicProgramMinAggregateOutputType | null
    _max: StudentAcademicProgramMaxAggregateOutputType | null
  }

  export type StudentAcademicProgramMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicProgramId: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    catalogYear: string | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAcademicProgramMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicProgramId: string | null
    startOn: Date | null
    endOn: Date | null
    status: string | null
    catalogYear: string | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAcademicProgramCountAggregateOutputType = {
    id: number
    studentId: number
    academicProgramId: number
    startOn: number
    endOn: number
    status: number
    catalogYear: number
    primary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAcademicProgramMinAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAcademicProgramMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAcademicProgramCountAggregateInputType = {
    id?: true
    studentId?: true
    academicProgramId?: true
    startOn?: true
    endOn?: true
    status?: true
    catalogYear?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAcademicProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicProgram to aggregate.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAcademicPrograms
    **/
    _count?: true | StudentAcademicProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAcademicProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAcademicProgramMaxAggregateInputType
  }

  export type GetStudentAcademicProgramAggregateType<T extends StudentAcademicProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAcademicProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAcademicProgram[P]>
      : GetScalarType<T[P], AggregateStudentAcademicProgram[P]>
  }




  export type StudentAcademicProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicProgramWhereInput
    orderBy?: StudentAcademicProgramOrderByWithAggregationInput | StudentAcademicProgramOrderByWithAggregationInput[]
    by: StudentAcademicProgramScalarFieldEnum[] | StudentAcademicProgramScalarFieldEnum
    having?: StudentAcademicProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAcademicProgramCountAggregateInputType | true
    _min?: StudentAcademicProgramMinAggregateInputType
    _max?: StudentAcademicProgramMaxAggregateInputType
  }

  export type StudentAcademicProgramGroupByOutputType = {
    id: string
    studentId: string
    academicProgramId: string
    startOn: Date
    endOn: Date | null
    status: string
    catalogYear: string | null
    primary: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentAcademicProgramCountAggregateOutputType | null
    _min: StudentAcademicProgramMinAggregateOutputType | null
    _max: StudentAcademicProgramMaxAggregateOutputType | null
  }

  type GetStudentAcademicProgramGroupByPayload<T extends StudentAcademicProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAcademicProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAcademicProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAcademicProgramGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAcademicProgramGroupByOutputType[P]>
        }
      >
    >


  export type StudentAcademicProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicProgram"]>

  export type StudentAcademicProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicProgram"]>

  export type StudentAcademicProgramSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicProgramId?: boolean
    startOn?: boolean
    endOn?: boolean
    status?: boolean
    catalogYear?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAcademicProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }
  export type StudentAcademicProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicProgramDefaultArgs<ExtArgs>
  }

  export type $StudentAcademicProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAcademicProgram"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicProgram: Prisma.$AcademicProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicProgramId: string
      startOn: Date
      endOn: Date | null
      status: string
      catalogYear: string | null
      primary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAcademicProgram"]>
    composites: {}
  }

  type StudentAcademicProgramGetPayload<S extends boolean | null | undefined | StudentAcademicProgramDefaultArgs> = $Result.GetResult<Prisma.$StudentAcademicProgramPayload, S>

  type StudentAcademicProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentAcademicProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentAcademicProgramCountAggregateInputType | true
    }

  export interface StudentAcademicProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAcademicProgram'], meta: { name: 'StudentAcademicProgram' } }
    /**
     * Find zero or one StudentAcademicProgram that matches the filter.
     * @param {StudentAcademicProgramFindUniqueArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAcademicProgramFindUniqueArgs>(args: SelectSubset<T, StudentAcademicProgramFindUniqueArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentAcademicProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentAcademicProgramFindUniqueOrThrowArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAcademicProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentAcademicProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindFirstArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAcademicProgramFindFirstArgs>(args?: SelectSubset<T, StudentAcademicProgramFindFirstArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentAcademicProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindFirstOrThrowArgs} args - Arguments to find a StudentAcademicProgram
     * @example
     * // Get one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAcademicProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentAcademicPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAcademicPrograms
     * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany()
     * 
     * // Get first 10 StudentAcademicPrograms
     * const studentAcademicPrograms = await prisma.studentAcademicProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAcademicProgramWithIdOnly = await prisma.studentAcademicProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAcademicProgramFindManyArgs>(args?: SelectSubset<T, StudentAcademicProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentAcademicProgram.
     * @param {StudentAcademicProgramCreateArgs} args - Arguments to create a StudentAcademicProgram.
     * @example
     * // Create one StudentAcademicProgram
     * const StudentAcademicProgram = await prisma.studentAcademicProgram.create({
     *   data: {
     *     // ... data to create a StudentAcademicProgram
     *   }
     * })
     * 
     */
    create<T extends StudentAcademicProgramCreateArgs>(args: SelectSubset<T, StudentAcademicProgramCreateArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentAcademicPrograms.
     * @param {StudentAcademicProgramCreateManyArgs} args - Arguments to create many StudentAcademicPrograms.
     * @example
     * // Create many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAcademicProgramCreateManyArgs>(args?: SelectSubset<T, StudentAcademicProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAcademicPrograms and returns the data saved in the database.
     * @param {StudentAcademicProgramCreateManyAndReturnArgs} args - Arguments to create many StudentAcademicPrograms.
     * @example
     * // Create many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAcademicPrograms and only return the `id`
     * const studentAcademicProgramWithIdOnly = await prisma.studentAcademicProgram.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAcademicProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentAcademicProgram.
     * @param {StudentAcademicProgramDeleteArgs} args - Arguments to delete one StudentAcademicProgram.
     * @example
     * // Delete one StudentAcademicProgram
     * const StudentAcademicProgram = await prisma.studentAcademicProgram.delete({
     *   where: {
     *     // ... filter to delete one StudentAcademicProgram
     *   }
     * })
     * 
     */
    delete<T extends StudentAcademicProgramDeleteArgs>(args: SelectSubset<T, StudentAcademicProgramDeleteArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentAcademicProgram.
     * @param {StudentAcademicProgramUpdateArgs} args - Arguments to update one StudentAcademicProgram.
     * @example
     * // Update one StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAcademicProgramUpdateArgs>(args: SelectSubset<T, StudentAcademicProgramUpdateArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentAcademicPrograms.
     * @param {StudentAcademicProgramDeleteManyArgs} args - Arguments to filter StudentAcademicPrograms to delete.
     * @example
     * // Delete a few StudentAcademicPrograms
     * const { count } = await prisma.studentAcademicProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAcademicProgramDeleteManyArgs>(args?: SelectSubset<T, StudentAcademicProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAcademicPrograms
     * const studentAcademicProgram = await prisma.studentAcademicProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAcademicProgramUpdateManyArgs>(args: SelectSubset<T, StudentAcademicProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAcademicProgram.
     * @param {StudentAcademicProgramUpsertArgs} args - Arguments to update or create a StudentAcademicProgram.
     * @example
     * // Update or create a StudentAcademicProgram
     * const studentAcademicProgram = await prisma.studentAcademicProgram.upsert({
     *   create: {
     *     // ... data to create a StudentAcademicProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAcademicProgram we want to update
     *   }
     * })
     */
    upsert<T extends StudentAcademicProgramUpsertArgs>(args: SelectSubset<T, StudentAcademicProgramUpsertArgs<ExtArgs>>): Prisma__StudentAcademicProgramClient<$Result.GetResult<Prisma.$StudentAcademicProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentAcademicPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramCountArgs} args - Arguments to filter StudentAcademicPrograms to count.
     * @example
     * // Count the number of StudentAcademicPrograms
     * const count = await prisma.studentAcademicProgram.count({
     *   where: {
     *     // ... the filter for the StudentAcademicPrograms we want to count
     *   }
     * })
    **/
    count<T extends StudentAcademicProgramCountArgs>(
      args?: Subset<T, StudentAcademicProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAcademicProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAcademicProgramAggregateArgs>(args: Subset<T, StudentAcademicProgramAggregateArgs>): Prisma.PrismaPromise<GetStudentAcademicProgramAggregateType<T>>

    /**
     * Group by StudentAcademicProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAcademicProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAcademicProgramGroupByArgs['orderBy'] }
        : { orderBy?: StudentAcademicProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAcademicProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAcademicProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAcademicProgram model
   */
  readonly fields: StudentAcademicProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAcademicProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAcademicProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicProgram<T extends AcademicProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicProgramDefaultArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAcademicProgram model
   */ 
  interface StudentAcademicProgramFieldRefs {
    readonly id: FieldRef<"StudentAcademicProgram", 'String'>
    readonly studentId: FieldRef<"StudentAcademicProgram", 'String'>
    readonly academicProgramId: FieldRef<"StudentAcademicProgram", 'String'>
    readonly startOn: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly endOn: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly status: FieldRef<"StudentAcademicProgram", 'String'>
    readonly catalogYear: FieldRef<"StudentAcademicProgram", 'String'>
    readonly primary: FieldRef<"StudentAcademicProgram", 'Boolean'>
    readonly createdAt: FieldRef<"StudentAcademicProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAcademicProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAcademicProgram findUnique
   */
  export type StudentAcademicProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram findUniqueOrThrow
   */
  export type StudentAcademicProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram findFirst
   */
  export type StudentAcademicProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicPrograms.
     */
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram findFirstOrThrow
   */
  export type StudentAcademicProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicProgram to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicPrograms.
     */
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram findMany
   */
  export type StudentAcademicProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicPrograms to fetch.
     */
    where?: StudentAcademicProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicPrograms to fetch.
     */
    orderBy?: StudentAcademicProgramOrderByWithRelationInput | StudentAcademicProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAcademicPrograms.
     */
    cursor?: StudentAcademicProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicPrograms.
     */
    skip?: number
    distinct?: StudentAcademicProgramScalarFieldEnum | StudentAcademicProgramScalarFieldEnum[]
  }

  /**
   * StudentAcademicProgram create
   */
  export type StudentAcademicProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAcademicProgram.
     */
    data: XOR<StudentAcademicProgramCreateInput, StudentAcademicProgramUncheckedCreateInput>
  }

  /**
   * StudentAcademicProgram createMany
   */
  export type StudentAcademicProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAcademicPrograms.
     */
    data: StudentAcademicProgramCreateManyInput | StudentAcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAcademicProgram createManyAndReturn
   */
  export type StudentAcademicProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentAcademicPrograms.
     */
    data: StudentAcademicProgramCreateManyInput | StudentAcademicProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAcademicProgram update
   */
  export type StudentAcademicProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAcademicProgram.
     */
    data: XOR<StudentAcademicProgramUpdateInput, StudentAcademicProgramUncheckedUpdateInput>
    /**
     * Choose, which StudentAcademicProgram to update.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram updateMany
   */
  export type StudentAcademicProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAcademicPrograms.
     */
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicPrograms to update
     */
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * StudentAcademicProgram upsert
   */
  export type StudentAcademicProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAcademicProgram to update in case it exists.
     */
    where: StudentAcademicProgramWhereUniqueInput
    /**
     * In case the StudentAcademicProgram found by the `where` argument doesn't exist, create a new StudentAcademicProgram with this data.
     */
    create: XOR<StudentAcademicProgramCreateInput, StudentAcademicProgramUncheckedCreateInput>
    /**
     * In case the StudentAcademicProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAcademicProgramUpdateInput, StudentAcademicProgramUncheckedUpdateInput>
  }

  /**
   * StudentAcademicProgram delete
   */
  export type StudentAcademicProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
    /**
     * Filter which StudentAcademicProgram to delete.
     */
    where: StudentAcademicProgramWhereUniqueInput
  }

  /**
   * StudentAcademicProgram deleteMany
   */
  export type StudentAcademicProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicPrograms to delete
     */
    where?: StudentAcademicProgramWhereInput
  }

  /**
   * StudentAcademicProgram without action
   */
  export type StudentAcademicProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicProgram
     */
    select?: StudentAcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicProgramInclude<ExtArgs> | null
  }


  /**
   * Model AcademicCredential
   */

  export type AggregateAcademicCredential = {
    _count: AcademicCredentialCountAggregateOutputType | null
    _min: AcademicCredentialMinAggregateOutputType | null
    _max: AcademicCredentialMaxAggregateOutputType | null
  }

  export type AcademicCredentialMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    credentialCode: string | null
    academicProgramId: string | null
    awardedOn: Date | null
    status: string | null
    academicPeriodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicCredentialMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    credentialCode: string | null
    academicProgramId: string | null
    awardedOn: Date | null
    status: string | null
    academicPeriodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicCredentialCountAggregateOutputType = {
    id: number
    studentId: number
    credentialCode: number
    academicProgramId: number
    awardedOn: number
    status: number
    academicPeriodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicCredentialMinAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicCredentialMaxAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicCredentialCountAggregateInputType = {
    id?: true
    studentId?: true
    credentialCode?: true
    academicProgramId?: true
    awardedOn?: true
    status?: true
    academicPeriodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCredential to aggregate.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicCredentials
    **/
    _count?: true | AcademicCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicCredentialMaxAggregateInputType
  }

  export type GetAcademicCredentialAggregateType<T extends AcademicCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicCredential[P]>
      : GetScalarType<T[P], AggregateAcademicCredential[P]>
  }




  export type AcademicCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicCredentialWhereInput
    orderBy?: AcademicCredentialOrderByWithAggregationInput | AcademicCredentialOrderByWithAggregationInput[]
    by: AcademicCredentialScalarFieldEnum[] | AcademicCredentialScalarFieldEnum
    having?: AcademicCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicCredentialCountAggregateInputType | true
    _min?: AcademicCredentialMinAggregateInputType
    _max?: AcademicCredentialMaxAggregateInputType
  }

  export type AcademicCredentialGroupByOutputType = {
    id: string
    studentId: string
    credentialCode: string
    academicProgramId: string | null
    awardedOn: Date
    status: string
    academicPeriodId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AcademicCredentialCountAggregateOutputType | null
    _min: AcademicCredentialMinAggregateOutputType | null
    _max: AcademicCredentialMaxAggregateOutputType | null
  }

  type GetAcademicCredentialGroupByPayload<T extends AcademicCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicCredentialGroupByOutputType[P]>
        }
      >
    >


  export type AcademicCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["academicCredential"]>

  export type AcademicCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }, ExtArgs["result"]["academicCredential"]>

  export type AcademicCredentialSelectScalar = {
    id?: boolean
    studentId?: boolean
    credentialCode?: boolean
    academicProgramId?: boolean
    awardedOn?: boolean
    status?: boolean
    academicPeriodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }
  export type AcademicCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicProgram?: boolean | AcademicCredential$academicProgramArgs<ExtArgs>
    academicPeriod?: boolean | AcademicCredential$academicPeriodArgs<ExtArgs>
  }

  export type $AcademicCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicCredential"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicProgram: Prisma.$AcademicProgramPayload<ExtArgs> | null
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      credentialCode: string
      academicProgramId: string | null
      awardedOn: Date
      status: string
      academicPeriodId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicCredential"]>
    composites: {}
  }

  type AcademicCredentialGetPayload<S extends boolean | null | undefined | AcademicCredentialDefaultArgs> = $Result.GetResult<Prisma.$AcademicCredentialPayload, S>

  type AcademicCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicCredentialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicCredentialCountAggregateInputType | true
    }

  export interface AcademicCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicCredential'], meta: { name: 'AcademicCredential' } }
    /**
     * Find zero or one AcademicCredential that matches the filter.
     * @param {AcademicCredentialFindUniqueArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicCredentialFindUniqueArgs>(args: SelectSubset<T, AcademicCredentialFindUniqueArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicCredential that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicCredentialFindUniqueOrThrowArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindFirstArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicCredentialFindFirstArgs>(args?: SelectSubset<T, AcademicCredentialFindFirstArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindFirstOrThrowArgs} args - Arguments to find a AcademicCredential
     * @example
     * // Get one AcademicCredential
     * const academicCredential = await prisma.academicCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicCredentials
     * const academicCredentials = await prisma.academicCredential.findMany()
     * 
     * // Get first 10 AcademicCredentials
     * const academicCredentials = await prisma.academicCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicCredentialWithIdOnly = await prisma.academicCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicCredentialFindManyArgs>(args?: SelectSubset<T, AcademicCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicCredential.
     * @param {AcademicCredentialCreateArgs} args - Arguments to create a AcademicCredential.
     * @example
     * // Create one AcademicCredential
     * const AcademicCredential = await prisma.academicCredential.create({
     *   data: {
     *     // ... data to create a AcademicCredential
     *   }
     * })
     * 
     */
    create<T extends AcademicCredentialCreateArgs>(args: SelectSubset<T, AcademicCredentialCreateArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicCredentials.
     * @param {AcademicCredentialCreateManyArgs} args - Arguments to create many AcademicCredentials.
     * @example
     * // Create many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicCredentialCreateManyArgs>(args?: SelectSubset<T, AcademicCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicCredentials and returns the data saved in the database.
     * @param {AcademicCredentialCreateManyAndReturnArgs} args - Arguments to create many AcademicCredentials.
     * @example
     * // Create many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicCredentials and only return the `id`
     * const academicCredentialWithIdOnly = await prisma.academicCredential.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicCredential.
     * @param {AcademicCredentialDeleteArgs} args - Arguments to delete one AcademicCredential.
     * @example
     * // Delete one AcademicCredential
     * const AcademicCredential = await prisma.academicCredential.delete({
     *   where: {
     *     // ... filter to delete one AcademicCredential
     *   }
     * })
     * 
     */
    delete<T extends AcademicCredentialDeleteArgs>(args: SelectSubset<T, AcademicCredentialDeleteArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicCredential.
     * @param {AcademicCredentialUpdateArgs} args - Arguments to update one AcademicCredential.
     * @example
     * // Update one AcademicCredential
     * const academicCredential = await prisma.academicCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicCredentialUpdateArgs>(args: SelectSubset<T, AcademicCredentialUpdateArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicCredentials.
     * @param {AcademicCredentialDeleteManyArgs} args - Arguments to filter AcademicCredentials to delete.
     * @example
     * // Delete a few AcademicCredentials
     * const { count } = await prisma.academicCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicCredentialDeleteManyArgs>(args?: SelectSubset<T, AcademicCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicCredentials
     * const academicCredential = await prisma.academicCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicCredentialUpdateManyArgs>(args: SelectSubset<T, AcademicCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicCredential.
     * @param {AcademicCredentialUpsertArgs} args - Arguments to update or create a AcademicCredential.
     * @example
     * // Update or create a AcademicCredential
     * const academicCredential = await prisma.academicCredential.upsert({
     *   create: {
     *     // ... data to create a AcademicCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicCredential we want to update
     *   }
     * })
     */
    upsert<T extends AcademicCredentialUpsertArgs>(args: SelectSubset<T, AcademicCredentialUpsertArgs<ExtArgs>>): Prisma__AcademicCredentialClient<$Result.GetResult<Prisma.$AcademicCredentialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialCountArgs} args - Arguments to filter AcademicCredentials to count.
     * @example
     * // Count the number of AcademicCredentials
     * const count = await prisma.academicCredential.count({
     *   where: {
     *     // ... the filter for the AcademicCredentials we want to count
     *   }
     * })
    **/
    count<T extends AcademicCredentialCountArgs>(
      args?: Subset<T, AcademicCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicCredentialAggregateArgs>(args: Subset<T, AcademicCredentialAggregateArgs>): Prisma.PrismaPromise<GetAcademicCredentialAggregateType<T>>

    /**
     * Group by AcademicCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicCredentialGroupByArgs['orderBy'] }
        : { orderBy?: AcademicCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicCredential model
   */
  readonly fields: AcademicCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicProgram<T extends AcademicCredential$academicProgramArgs<ExtArgs> = {}>(args?: Subset<T, AcademicCredential$academicProgramArgs<ExtArgs>>): Prisma__AcademicProgramClient<$Result.GetResult<Prisma.$AcademicProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    academicPeriod<T extends AcademicCredential$academicPeriodArgs<ExtArgs> = {}>(args?: Subset<T, AcademicCredential$academicPeriodArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicCredential model
   */ 
  interface AcademicCredentialFieldRefs {
    readonly id: FieldRef<"AcademicCredential", 'String'>
    readonly studentId: FieldRef<"AcademicCredential", 'String'>
    readonly credentialCode: FieldRef<"AcademicCredential", 'String'>
    readonly academicProgramId: FieldRef<"AcademicCredential", 'String'>
    readonly awardedOn: FieldRef<"AcademicCredential", 'DateTime'>
    readonly status: FieldRef<"AcademicCredential", 'String'>
    readonly academicPeriodId: FieldRef<"AcademicCredential", 'String'>
    readonly createdAt: FieldRef<"AcademicCredential", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicCredential findUnique
   */
  export type AcademicCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential findUniqueOrThrow
   */
  export type AcademicCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential findFirst
   */
  export type AcademicCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCredentials.
     */
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential findFirstOrThrow
   */
  export type AcademicCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredential to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicCredentials.
     */
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential findMany
   */
  export type AcademicCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter, which AcademicCredentials to fetch.
     */
    where?: AcademicCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicCredentials to fetch.
     */
    orderBy?: AcademicCredentialOrderByWithRelationInput | AcademicCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicCredentials.
     */
    cursor?: AcademicCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicCredentials.
     */
    skip?: number
    distinct?: AcademicCredentialScalarFieldEnum | AcademicCredentialScalarFieldEnum[]
  }

  /**
   * AcademicCredential create
   */
  export type AcademicCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicCredential.
     */
    data: XOR<AcademicCredentialCreateInput, AcademicCredentialUncheckedCreateInput>
  }

  /**
   * AcademicCredential createMany
   */
  export type AcademicCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicCredentials.
     */
    data: AcademicCredentialCreateManyInput | AcademicCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicCredential createManyAndReturn
   */
  export type AcademicCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicCredentials.
     */
    data: AcademicCredentialCreateManyInput | AcademicCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicCredential update
   */
  export type AcademicCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicCredential.
     */
    data: XOR<AcademicCredentialUpdateInput, AcademicCredentialUncheckedUpdateInput>
    /**
     * Choose, which AcademicCredential to update.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential updateMany
   */
  export type AcademicCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicCredentials.
     */
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyInput>
    /**
     * Filter which AcademicCredentials to update
     */
    where?: AcademicCredentialWhereInput
  }

  /**
   * AcademicCredential upsert
   */
  export type AcademicCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicCredential to update in case it exists.
     */
    where: AcademicCredentialWhereUniqueInput
    /**
     * In case the AcademicCredential found by the `where` argument doesn't exist, create a new AcademicCredential with this data.
     */
    create: XOR<AcademicCredentialCreateInput, AcademicCredentialUncheckedCreateInput>
    /**
     * In case the AcademicCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicCredentialUpdateInput, AcademicCredentialUncheckedUpdateInput>
  }

  /**
   * AcademicCredential delete
   */
  export type AcademicCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
    /**
     * Filter which AcademicCredential to delete.
     */
    where: AcademicCredentialWhereUniqueInput
  }

  /**
   * AcademicCredential deleteMany
   */
  export type AcademicCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicCredentials to delete
     */
    where?: AcademicCredentialWhereInput
  }

  /**
   * AcademicCredential.academicProgram
   */
  export type AcademicCredential$academicProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicProgram
     */
    select?: AcademicProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicProgramInclude<ExtArgs> | null
    where?: AcademicProgramWhereInput
  }

  /**
   * AcademicCredential.academicPeriod
   */
  export type AcademicCredential$academicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPeriod
     */
    select?: AcademicPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPeriodInclude<ExtArgs> | null
    where?: AcademicPeriodWhereInput
  }

  /**
   * AcademicCredential without action
   */
  export type AcademicCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicCredential
     */
    select?: AcademicCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicCredentialInclude<ExtArgs> | null
  }


  /**
   * Model StudentRisk
   */

  export type AggregateStudentRisk = {
    _count: StudentRiskCountAggregateOutputType | null
    _avg: StudentRiskAvgAggregateOutputType | null
    _sum: StudentRiskSumAggregateOutputType | null
    _min: StudentRiskMinAggregateOutputType | null
    _max: StudentRiskMaxAggregateOutputType | null
  }

  export type StudentRiskAvgAggregateOutputType = {
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
  }

  export type StudentRiskSumAggregateOutputType = {
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
  }

  export type StudentRiskMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicPeriodId: string | null
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
    overallRiskBucket: $Enums.RiskBucket | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type StudentRiskMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicPeriodId: string | null
    attendanceRiskScore: number | null
    academicSupportRiskScore: number | null
    overallRiskBucket: $Enums.RiskBucket | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type StudentRiskCountAggregateOutputType = {
    id: number
    studentId: number
    academicPeriodId: number
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type StudentRiskAvgAggregateInputType = {
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
  }

  export type StudentRiskSumAggregateInputType = {
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
  }

  export type StudentRiskMinAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
  }

  export type StudentRiskMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
  }

  export type StudentRiskCountAggregateInputType = {
    id?: true
    studentId?: true
    academicPeriodId?: true
    attendanceRiskScore?: true
    academicSupportRiskScore?: true
    overallRiskBucket?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type StudentRiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRisk to aggregate.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentRisks
    **/
    _count?: true | StudentRiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentRiskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentRiskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentRiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentRiskMaxAggregateInputType
  }

  export type GetStudentRiskAggregateType<T extends StudentRiskAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentRisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentRisk[P]>
      : GetScalarType<T[P], AggregateStudentRisk[P]>
  }




  export type StudentRiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRiskWhereInput
    orderBy?: StudentRiskOrderByWithAggregationInput | StudentRiskOrderByWithAggregationInput[]
    by: StudentRiskScalarFieldEnum[] | StudentRiskScalarFieldEnum
    having?: StudentRiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentRiskCountAggregateInputType | true
    _avg?: StudentRiskAvgAggregateInputType
    _sum?: StudentRiskSumAggregateInputType
    _min?: StudentRiskMinAggregateInputType
    _max?: StudentRiskMaxAggregateInputType
  }

  export type StudentRiskGroupByOutputType = {
    id: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt: Date
    createdAt: Date
    _count: StudentRiskCountAggregateOutputType | null
    _avg: StudentRiskAvgAggregateOutputType | null
    _sum: StudentRiskSumAggregateOutputType | null
    _min: StudentRiskMinAggregateOutputType | null
    _max: StudentRiskMaxAggregateOutputType | null
  }

  type GetStudentRiskGroupByPayload<T extends StudentRiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentRiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentRiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentRiskGroupByOutputType[P]>
            : GetScalarType<T[P], StudentRiskGroupByOutputType[P]>
        }
      >
    >


  export type StudentRiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRisk"]>

  export type StudentRiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRisk"]>

  export type StudentRiskSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicPeriodId?: boolean
    attendanceRiskScore?: boolean
    academicSupportRiskScore?: boolean
    overallRiskBucket?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type StudentRiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }
  export type StudentRiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicPeriod?: boolean | AcademicPeriodDefaultArgs<ExtArgs>
  }

  export type $StudentRiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentRisk"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicPeriod: Prisma.$AcademicPeriodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicPeriodId: string
      attendanceRiskScore: number
      academicSupportRiskScore: number
      overallRiskBucket: $Enums.RiskBucket
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["studentRisk"]>
    composites: {}
  }

  type StudentRiskGetPayload<S extends boolean | null | undefined | StudentRiskDefaultArgs> = $Result.GetResult<Prisma.$StudentRiskPayload, S>

  type StudentRiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentRiskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentRiskCountAggregateInputType | true
    }

  export interface StudentRiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentRisk'], meta: { name: 'StudentRisk' } }
    /**
     * Find zero or one StudentRisk that matches the filter.
     * @param {StudentRiskFindUniqueArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentRiskFindUniqueArgs>(args: SelectSubset<T, StudentRiskFindUniqueArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentRisk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentRiskFindUniqueOrThrowArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentRiskFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentRiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentRisk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindFirstArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentRiskFindFirstArgs>(args?: SelectSubset<T, StudentRiskFindFirstArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentRisk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindFirstOrThrowArgs} args - Arguments to find a StudentRisk
     * @example
     * // Get one StudentRisk
     * const studentRisk = await prisma.studentRisk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentRiskFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentRiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentRisks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentRisks
     * const studentRisks = await prisma.studentRisk.findMany()
     * 
     * // Get first 10 StudentRisks
     * const studentRisks = await prisma.studentRisk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentRiskWithIdOnly = await prisma.studentRisk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentRiskFindManyArgs>(args?: SelectSubset<T, StudentRiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentRisk.
     * @param {StudentRiskCreateArgs} args - Arguments to create a StudentRisk.
     * @example
     * // Create one StudentRisk
     * const StudentRisk = await prisma.studentRisk.create({
     *   data: {
     *     // ... data to create a StudentRisk
     *   }
     * })
     * 
     */
    create<T extends StudentRiskCreateArgs>(args: SelectSubset<T, StudentRiskCreateArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentRisks.
     * @param {StudentRiskCreateManyArgs} args - Arguments to create many StudentRisks.
     * @example
     * // Create many StudentRisks
     * const studentRisk = await prisma.studentRisk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentRiskCreateManyArgs>(args?: SelectSubset<T, StudentRiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentRisks and returns the data saved in the database.
     * @param {StudentRiskCreateManyAndReturnArgs} args - Arguments to create many StudentRisks.
     * @example
     * // Create many StudentRisks
     * const studentRisk = await prisma.studentRisk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentRisks and only return the `id`
     * const studentRiskWithIdOnly = await prisma.studentRisk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentRiskCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentRiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentRisk.
     * @param {StudentRiskDeleteArgs} args - Arguments to delete one StudentRisk.
     * @example
     * // Delete one StudentRisk
     * const StudentRisk = await prisma.studentRisk.delete({
     *   where: {
     *     // ... filter to delete one StudentRisk
     *   }
     * })
     * 
     */
    delete<T extends StudentRiskDeleteArgs>(args: SelectSubset<T, StudentRiskDeleteArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentRisk.
     * @param {StudentRiskUpdateArgs} args - Arguments to update one StudentRisk.
     * @example
     * // Update one StudentRisk
     * const studentRisk = await prisma.studentRisk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentRiskUpdateArgs>(args: SelectSubset<T, StudentRiskUpdateArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentRisks.
     * @param {StudentRiskDeleteManyArgs} args - Arguments to filter StudentRisks to delete.
     * @example
     * // Delete a few StudentRisks
     * const { count } = await prisma.studentRisk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentRiskDeleteManyArgs>(args?: SelectSubset<T, StudentRiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentRisks
     * const studentRisk = await prisma.studentRisk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentRiskUpdateManyArgs>(args: SelectSubset<T, StudentRiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentRisk.
     * @param {StudentRiskUpsertArgs} args - Arguments to update or create a StudentRisk.
     * @example
     * // Update or create a StudentRisk
     * const studentRisk = await prisma.studentRisk.upsert({
     *   create: {
     *     // ... data to create a StudentRisk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentRisk we want to update
     *   }
     * })
     */
    upsert<T extends StudentRiskUpsertArgs>(args: SelectSubset<T, StudentRiskUpsertArgs<ExtArgs>>): Prisma__StudentRiskClient<$Result.GetResult<Prisma.$StudentRiskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentRisks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskCountArgs} args - Arguments to filter StudentRisks to count.
     * @example
     * // Count the number of StudentRisks
     * const count = await prisma.studentRisk.count({
     *   where: {
     *     // ... the filter for the StudentRisks we want to count
     *   }
     * })
    **/
    count<T extends StudentRiskCountArgs>(
      args?: Subset<T, StudentRiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentRiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentRiskAggregateArgs>(args: Subset<T, StudentRiskAggregateArgs>): Prisma.PrismaPromise<GetStudentRiskAggregateType<T>>

    /**
     * Group by StudentRisk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentRiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentRiskGroupByArgs['orderBy'] }
        : { orderBy?: StudentRiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentRiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentRiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentRisk model
   */
  readonly fields: StudentRiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentRisk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentRiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academicPeriod<T extends AcademicPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicPeriodDefaultArgs<ExtArgs>>): Prisma__AcademicPeriodClient<$Result.GetResult<Prisma.$AcademicPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentRisk model
   */ 
  interface StudentRiskFieldRefs {
    readonly id: FieldRef<"StudentRisk", 'String'>
    readonly studentId: FieldRef<"StudentRisk", 'String'>
    readonly academicPeriodId: FieldRef<"StudentRisk", 'String'>
    readonly attendanceRiskScore: FieldRef<"StudentRisk", 'Float'>
    readonly academicSupportRiskScore: FieldRef<"StudentRisk", 'Float'>
    readonly overallRiskBucket: FieldRef<"StudentRisk", 'RiskBucket'>
    readonly updatedAt: FieldRef<"StudentRisk", 'DateTime'>
    readonly createdAt: FieldRef<"StudentRisk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentRisk findUnique
   */
  export type StudentRiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk findUniqueOrThrow
   */
  export type StudentRiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk findFirst
   */
  export type StudentRiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRisks.
     */
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk findFirstOrThrow
   */
  export type StudentRiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisk to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRisks.
     */
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk findMany
   */
  export type StudentRiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter, which StudentRisks to fetch.
     */
    where?: StudentRiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRisks to fetch.
     */
    orderBy?: StudentRiskOrderByWithRelationInput | StudentRiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentRisks.
     */
    cursor?: StudentRiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRisks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRisks.
     */
    skip?: number
    distinct?: StudentRiskScalarFieldEnum | StudentRiskScalarFieldEnum[]
  }

  /**
   * StudentRisk create
   */
  export type StudentRiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentRisk.
     */
    data: XOR<StudentRiskCreateInput, StudentRiskUncheckedCreateInput>
  }

  /**
   * StudentRisk createMany
   */
  export type StudentRiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentRisks.
     */
    data: StudentRiskCreateManyInput | StudentRiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentRisk createManyAndReturn
   */
  export type StudentRiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentRisks.
     */
    data: StudentRiskCreateManyInput | StudentRiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentRisk update
   */
  export type StudentRiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentRisk.
     */
    data: XOR<StudentRiskUpdateInput, StudentRiskUncheckedUpdateInput>
    /**
     * Choose, which StudentRisk to update.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk updateMany
   */
  export type StudentRiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentRisks.
     */
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyInput>
    /**
     * Filter which StudentRisks to update
     */
    where?: StudentRiskWhereInput
  }

  /**
   * StudentRisk upsert
   */
  export type StudentRiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentRisk to update in case it exists.
     */
    where: StudentRiskWhereUniqueInput
    /**
     * In case the StudentRisk found by the `where` argument doesn't exist, create a new StudentRisk with this data.
     */
    create: XOR<StudentRiskCreateInput, StudentRiskUncheckedCreateInput>
    /**
     * In case the StudentRisk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentRiskUpdateInput, StudentRiskUncheckedUpdateInput>
  }

  /**
   * StudentRisk delete
   */
  export type StudentRiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
    /**
     * Filter which StudentRisk to delete.
     */
    where: StudentRiskWhereUniqueInput
  }

  /**
   * StudentRisk deleteMany
   */
  export type StudentRiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRisks to delete
     */
    where?: StudentRiskWhereInput
  }

  /**
   * StudentRisk without action
   */
  export type StudentRiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRisk
     */
    select?: StudentRiskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRiskInclude<ExtArgs> | null
  }


  /**
   * Model SimulationState
   */

  export type AggregateSimulationState = {
    _count: SimulationStateCountAggregateOutputType | null
    _min: SimulationStateMinAggregateOutputType | null
    _max: SimulationStateMaxAggregateOutputType | null
  }

  export type SimulationStateMinAggregateOutputType = {
    id: string | null
    currentSimDate: Date | null
    lastTickDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationStateMaxAggregateOutputType = {
    id: string | null
    currentSimDate: Date | null
    lastTickDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationStateCountAggregateOutputType = {
    id: number
    currentSimDate: number
    lastTickDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SimulationStateMinAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationStateMaxAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationStateCountAggregateInputType = {
    id?: true
    currentSimDate?: true
    lastTickDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SimulationStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationState to aggregate.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationStates
    **/
    _count?: true | SimulationStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationStateMaxAggregateInputType
  }

  export type GetSimulationStateAggregateType<T extends SimulationStateAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationState[P]>
      : GetScalarType<T[P], AggregateSimulationState[P]>
  }




  export type SimulationStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationStateWhereInput
    orderBy?: SimulationStateOrderByWithAggregationInput | SimulationStateOrderByWithAggregationInput[]
    by: SimulationStateScalarFieldEnum[] | SimulationStateScalarFieldEnum
    having?: SimulationStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationStateCountAggregateInputType | true
    _min?: SimulationStateMinAggregateInputType
    _max?: SimulationStateMaxAggregateInputType
  }

  export type SimulationStateGroupByOutputType = {
    id: string
    currentSimDate: Date
    lastTickDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SimulationStateCountAggregateOutputType | null
    _min: SimulationStateMinAggregateOutputType | null
    _max: SimulationStateMaxAggregateOutputType | null
  }

  type GetSimulationStateGroupByPayload<T extends SimulationStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationStateGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationStateGroupByOutputType[P]>
        }
      >
    >


  export type SimulationStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simulationState"]>

  export type SimulationStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simulationState"]>

  export type SimulationStateSelectScalar = {
    id?: boolean
    currentSimDate?: boolean
    lastTickDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SimulationStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currentSimDate: Date
      lastTickDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["simulationState"]>
    composites: {}
  }

  type SimulationStateGetPayload<S extends boolean | null | undefined | SimulationStateDefaultArgs> = $Result.GetResult<Prisma.$SimulationStatePayload, S>

  type SimulationStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimulationStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimulationStateCountAggregateInputType | true
    }

  export interface SimulationStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationState'], meta: { name: 'SimulationState' } }
    /**
     * Find zero or one SimulationState that matches the filter.
     * @param {SimulationStateFindUniqueArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationStateFindUniqueArgs>(args: SelectSubset<T, SimulationStateFindUniqueArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimulationState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimulationStateFindUniqueOrThrowArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationStateFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimulationState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindFirstArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationStateFindFirstArgs>(args?: SelectSubset<T, SimulationStateFindFirstArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimulationState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindFirstOrThrowArgs} args - Arguments to find a SimulationState
     * @example
     * // Get one SimulationState
     * const simulationState = await prisma.simulationState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationStateFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimulationStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationStates
     * const simulationStates = await prisma.simulationState.findMany()
     * 
     * // Get first 10 SimulationStates
     * const simulationStates = await prisma.simulationState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationStateWithIdOnly = await prisma.simulationState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationStateFindManyArgs>(args?: SelectSubset<T, SimulationStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimulationState.
     * @param {SimulationStateCreateArgs} args - Arguments to create a SimulationState.
     * @example
     * // Create one SimulationState
     * const SimulationState = await prisma.simulationState.create({
     *   data: {
     *     // ... data to create a SimulationState
     *   }
     * })
     * 
     */
    create<T extends SimulationStateCreateArgs>(args: SelectSubset<T, SimulationStateCreateArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimulationStates.
     * @param {SimulationStateCreateManyArgs} args - Arguments to create many SimulationStates.
     * @example
     * // Create many SimulationStates
     * const simulationState = await prisma.simulationState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationStateCreateManyArgs>(args?: SelectSubset<T, SimulationStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationStates and returns the data saved in the database.
     * @param {SimulationStateCreateManyAndReturnArgs} args - Arguments to create many SimulationStates.
     * @example
     * // Create many SimulationStates
     * const simulationState = await prisma.simulationState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationStates and only return the `id`
     * const simulationStateWithIdOnly = await prisma.simulationState.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationStateCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimulationState.
     * @param {SimulationStateDeleteArgs} args - Arguments to delete one SimulationState.
     * @example
     * // Delete one SimulationState
     * const SimulationState = await prisma.simulationState.delete({
     *   where: {
     *     // ... filter to delete one SimulationState
     *   }
     * })
     * 
     */
    delete<T extends SimulationStateDeleteArgs>(args: SelectSubset<T, SimulationStateDeleteArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimulationState.
     * @param {SimulationStateUpdateArgs} args - Arguments to update one SimulationState.
     * @example
     * // Update one SimulationState
     * const simulationState = await prisma.simulationState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationStateUpdateArgs>(args: SelectSubset<T, SimulationStateUpdateArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimulationStates.
     * @param {SimulationStateDeleteManyArgs} args - Arguments to filter SimulationStates to delete.
     * @example
     * // Delete a few SimulationStates
     * const { count } = await prisma.simulationState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationStateDeleteManyArgs>(args?: SelectSubset<T, SimulationStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationStates
     * const simulationState = await prisma.simulationState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationStateUpdateManyArgs>(args: SelectSubset<T, SimulationStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimulationState.
     * @param {SimulationStateUpsertArgs} args - Arguments to update or create a SimulationState.
     * @example
     * // Update or create a SimulationState
     * const simulationState = await prisma.simulationState.upsert({
     *   create: {
     *     // ... data to create a SimulationState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationState we want to update
     *   }
     * })
     */
    upsert<T extends SimulationStateUpsertArgs>(args: SelectSubset<T, SimulationStateUpsertArgs<ExtArgs>>): Prisma__SimulationStateClient<$Result.GetResult<Prisma.$SimulationStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimulationStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateCountArgs} args - Arguments to filter SimulationStates to count.
     * @example
     * // Count the number of SimulationStates
     * const count = await prisma.simulationState.count({
     *   where: {
     *     // ... the filter for the SimulationStates we want to count
     *   }
     * })
    **/
    count<T extends SimulationStateCountArgs>(
      args?: Subset<T, SimulationStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationStateAggregateArgs>(args: Subset<T, SimulationStateAggregateArgs>): Prisma.PrismaPromise<GetSimulationStateAggregateType<T>>

    /**
     * Group by SimulationState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationStateGroupByArgs['orderBy'] }
        : { orderBy?: SimulationStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationState model
   */
  readonly fields: SimulationStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationState model
   */ 
  interface SimulationStateFieldRefs {
    readonly id: FieldRef<"SimulationState", 'String'>
    readonly currentSimDate: FieldRef<"SimulationState", 'DateTime'>
    readonly lastTickDate: FieldRef<"SimulationState", 'DateTime'>
    readonly createdAt: FieldRef<"SimulationState", 'DateTime'>
    readonly updatedAt: FieldRef<"SimulationState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimulationState findUnique
   */
  export type SimulationStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState findUniqueOrThrow
   */
  export type SimulationStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState findFirst
   */
  export type SimulationStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationStates.
     */
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState findFirstOrThrow
   */
  export type SimulationStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter, which SimulationState to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationStates.
     */
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState findMany
   */
  export type SimulationStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter, which SimulationStates to fetch.
     */
    where?: SimulationStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationStates to fetch.
     */
    orderBy?: SimulationStateOrderByWithRelationInput | SimulationStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationStates.
     */
    cursor?: SimulationStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationStates.
     */
    skip?: number
    distinct?: SimulationStateScalarFieldEnum | SimulationStateScalarFieldEnum[]
  }

  /**
   * SimulationState create
   */
  export type SimulationStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * The data needed to create a SimulationState.
     */
    data: XOR<SimulationStateCreateInput, SimulationStateUncheckedCreateInput>
  }

  /**
   * SimulationState createMany
   */
  export type SimulationStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationStates.
     */
    data: SimulationStateCreateManyInput | SimulationStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationState createManyAndReturn
   */
  export type SimulationStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimulationStates.
     */
    data: SimulationStateCreateManyInput | SimulationStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationState update
   */
  export type SimulationStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * The data needed to update a SimulationState.
     */
    data: XOR<SimulationStateUpdateInput, SimulationStateUncheckedUpdateInput>
    /**
     * Choose, which SimulationState to update.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState updateMany
   */
  export type SimulationStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationStates.
     */
    data: XOR<SimulationStateUpdateManyMutationInput, SimulationStateUncheckedUpdateManyInput>
    /**
     * Filter which SimulationStates to update
     */
    where?: SimulationStateWhereInput
  }

  /**
   * SimulationState upsert
   */
  export type SimulationStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * The filter to search for the SimulationState to update in case it exists.
     */
    where: SimulationStateWhereUniqueInput
    /**
     * In case the SimulationState found by the `where` argument doesn't exist, create a new SimulationState with this data.
     */
    create: XOR<SimulationStateCreateInput, SimulationStateUncheckedCreateInput>
    /**
     * In case the SimulationState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationStateUpdateInput, SimulationStateUncheckedUpdateInput>
  }

  /**
   * SimulationState delete
   */
  export type SimulationStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
    /**
     * Filter which SimulationState to delete.
     */
    where: SimulationStateWhereUniqueInput
  }

  /**
   * SimulationState deleteMany
   */
  export type SimulationStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationStates to delete
     */
    where?: SimulationStateWhereInput
  }

  /**
   * SimulationState without action
   */
  export type SimulationStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationState
     */
    select?: SimulationStateSelect<ExtArgs> | null
  }


  /**
   * Model CrmContact
   */

  export type AggregateCrmContact = {
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  export type CrmContactMinAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    type: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactMaxAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    type: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmContactCountAggregateOutputType = {
    id: number
    workspace: number
    app: number
    name: number
    type: number
    email: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrmContactMinAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactMaxAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmContactCountAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrmContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContact to aggregate.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmContacts
    **/
    _count?: true | CrmContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmContactMaxAggregateInputType
  }

  export type GetCrmContactAggregateType<T extends CrmContactAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmContact[P]>
      : GetScalarType<T[P], AggregateCrmContact[P]>
  }




  export type CrmContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmContactWhereInput
    orderBy?: CrmContactOrderByWithAggregationInput | CrmContactOrderByWithAggregationInput[]
    by: CrmContactScalarFieldEnum[] | CrmContactScalarFieldEnum
    having?: CrmContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmContactCountAggregateInputType | true
    _min?: CrmContactMinAggregateInputType
    _max?: CrmContactMaxAggregateInputType
  }

  export type CrmContactGroupByOutputType = {
    id: string
    workspace: string
    app: string
    name: string
    type: string
    email: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: CrmContactCountAggregateOutputType | null
    _min: CrmContactMinAggregateOutputType | null
    _max: CrmContactMaxAggregateOutputType | null
  }

  type GetCrmContactGroupByPayload<T extends CrmContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
            : GetScalarType<T[P], CrmContactGroupByOutputType[P]>
        }
      >
    >


  export type CrmContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunities?: boolean | CrmContact$opportunitiesArgs<ExtArgs>
    activities?: boolean | CrmContact$activitiesArgs<ExtArgs>
    _count?: boolean | CrmContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crmContact"]>

  export type CrmContactSelectScalar = {
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrmContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | CrmContact$opportunitiesArgs<ExtArgs>
    activities?: boolean | CrmContact$activitiesArgs<ExtArgs>
    _count?: boolean | CrmContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrmContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrmContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmContact"
    objects: {
      opportunities: Prisma.$CrmOpportunityPayload<ExtArgs>[]
      activities: Prisma.$CrmActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspace: string
      app: string
      name: string
      type: string
      email: string | null
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crmContact"]>
    composites: {}
  }

  type CrmContactGetPayload<S extends boolean | null | undefined | CrmContactDefaultArgs> = $Result.GetResult<Prisma.$CrmContactPayload, S>

  type CrmContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrmContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrmContactCountAggregateInputType | true
    }

  export interface CrmContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmContact'], meta: { name: 'CrmContact' } }
    /**
     * Find zero or one CrmContact that matches the filter.
     * @param {CrmContactFindUniqueArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmContactFindUniqueArgs>(args: SelectSubset<T, CrmContactFindUniqueArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrmContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrmContactFindUniqueOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmContactFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrmContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmContactFindFirstArgs>(args?: SelectSubset<T, CrmContactFindFirstArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrmContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindFirstOrThrowArgs} args - Arguments to find a CrmContact
     * @example
     * // Get one CrmContact
     * const crmContact = await prisma.crmContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmContactFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrmContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmContacts
     * const crmContacts = await prisma.crmContact.findMany()
     * 
     * // Get first 10 CrmContacts
     * const crmContacts = await prisma.crmContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmContactFindManyArgs>(args?: SelectSubset<T, CrmContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrmContact.
     * @param {CrmContactCreateArgs} args - Arguments to create a CrmContact.
     * @example
     * // Create one CrmContact
     * const CrmContact = await prisma.crmContact.create({
     *   data: {
     *     // ... data to create a CrmContact
     *   }
     * })
     * 
     */
    create<T extends CrmContactCreateArgs>(args: SelectSubset<T, CrmContactCreateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrmContacts.
     * @param {CrmContactCreateManyArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmContactCreateManyArgs>(args?: SelectSubset<T, CrmContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmContacts and returns the data saved in the database.
     * @param {CrmContactCreateManyAndReturnArgs} args - Arguments to create many CrmContacts.
     * @example
     * // Create many CrmContacts
     * const crmContact = await prisma.crmContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmContacts and only return the `id`
     * const crmContactWithIdOnly = await prisma.crmContact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmContactCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrmContact.
     * @param {CrmContactDeleteArgs} args - Arguments to delete one CrmContact.
     * @example
     * // Delete one CrmContact
     * const CrmContact = await prisma.crmContact.delete({
     *   where: {
     *     // ... filter to delete one CrmContact
     *   }
     * })
     * 
     */
    delete<T extends CrmContactDeleteArgs>(args: SelectSubset<T, CrmContactDeleteArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrmContact.
     * @param {CrmContactUpdateArgs} args - Arguments to update one CrmContact.
     * @example
     * // Update one CrmContact
     * const crmContact = await prisma.crmContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmContactUpdateArgs>(args: SelectSubset<T, CrmContactUpdateArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrmContacts.
     * @param {CrmContactDeleteManyArgs} args - Arguments to filter CrmContacts to delete.
     * @example
     * // Delete a few CrmContacts
     * const { count } = await prisma.crmContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmContactDeleteManyArgs>(args?: SelectSubset<T, CrmContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmContacts
     * const crmContact = await prisma.crmContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmContactUpdateManyArgs>(args: SelectSubset<T, CrmContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrmContact.
     * @param {CrmContactUpsertArgs} args - Arguments to update or create a CrmContact.
     * @example
     * // Update or create a CrmContact
     * const crmContact = await prisma.crmContact.upsert({
     *   create: {
     *     // ... data to create a CrmContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmContact we want to update
     *   }
     * })
     */
    upsert<T extends CrmContactUpsertArgs>(args: SelectSubset<T, CrmContactUpsertArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrmContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactCountArgs} args - Arguments to filter CrmContacts to count.
     * @example
     * // Count the number of CrmContacts
     * const count = await prisma.crmContact.count({
     *   where: {
     *     // ... the filter for the CrmContacts we want to count
     *   }
     * })
    **/
    count<T extends CrmContactCountArgs>(
      args?: Subset<T, CrmContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmContactAggregateArgs>(args: Subset<T, CrmContactAggregateArgs>): Prisma.PrismaPromise<GetCrmContactAggregateType<T>>

    /**
     * Group by CrmContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmContactGroupByArgs['orderBy'] }
        : { orderBy?: CrmContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmContact model
   */
  readonly fields: CrmContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunities<T extends CrmContact$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, CrmContact$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends CrmContact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, CrmContact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmContact model
   */ 
  interface CrmContactFieldRefs {
    readonly id: FieldRef<"CrmContact", 'String'>
    readonly workspace: FieldRef<"CrmContact", 'String'>
    readonly app: FieldRef<"CrmContact", 'String'>
    readonly name: FieldRef<"CrmContact", 'String'>
    readonly type: FieldRef<"CrmContact", 'String'>
    readonly email: FieldRef<"CrmContact", 'String'>
    readonly phone: FieldRef<"CrmContact", 'String'>
    readonly createdAt: FieldRef<"CrmContact", 'DateTime'>
    readonly updatedAt: FieldRef<"CrmContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmContact findUnique
   */
  export type CrmContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findUniqueOrThrow
   */
  export type CrmContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact findFirst
   */
  export type CrmContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findFirstOrThrow
   */
  export type CrmContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContact to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmContacts.
     */
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact findMany
   */
  export type CrmContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter, which CrmContacts to fetch.
     */
    where?: CrmContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmContacts to fetch.
     */
    orderBy?: CrmContactOrderByWithRelationInput | CrmContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmContacts.
     */
    cursor?: CrmContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmContacts.
     */
    skip?: number
    distinct?: CrmContactScalarFieldEnum | CrmContactScalarFieldEnum[]
  }

  /**
   * CrmContact create
   */
  export type CrmContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmContact.
     */
    data: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
  }

  /**
   * CrmContact createMany
   */
  export type CrmContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmContact createManyAndReturn
   */
  export type CrmContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrmContacts.
     */
    data: CrmContactCreateManyInput | CrmContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmContact update
   */
  export type CrmContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmContact.
     */
    data: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
    /**
     * Choose, which CrmContact to update.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact updateMany
   */
  export type CrmContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmContacts.
     */
    data: XOR<CrmContactUpdateManyMutationInput, CrmContactUncheckedUpdateManyInput>
    /**
     * Filter which CrmContacts to update
     */
    where?: CrmContactWhereInput
  }

  /**
   * CrmContact upsert
   */
  export type CrmContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmContact to update in case it exists.
     */
    where: CrmContactWhereUniqueInput
    /**
     * In case the CrmContact found by the `where` argument doesn't exist, create a new CrmContact with this data.
     */
    create: XOR<CrmContactCreateInput, CrmContactUncheckedCreateInput>
    /**
     * In case the CrmContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmContactUpdateInput, CrmContactUncheckedUpdateInput>
  }

  /**
   * CrmContact delete
   */
  export type CrmContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    /**
     * Filter which CrmContact to delete.
     */
    where: CrmContactWhereUniqueInput
  }

  /**
   * CrmContact deleteMany
   */
  export type CrmContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmContacts to delete
     */
    where?: CrmContactWhereInput
  }

  /**
   * CrmContact.opportunities
   */
  export type CrmContact$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    where?: CrmOpportunityWhereInput
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    cursor?: CrmOpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmOpportunityScalarFieldEnum | CrmOpportunityScalarFieldEnum[]
  }

  /**
   * CrmContact.activities
   */
  export type CrmContact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    where?: CrmActivityWhereInput
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    cursor?: CrmActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmContact without action
   */
  export type CrmContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
  }


  /**
   * Model CrmAccount
   */

  export type AggregateCrmAccount = {
    _count: CrmAccountCountAggregateOutputType | null
    _min: CrmAccountMinAggregateOutputType | null
    _max: CrmAccountMaxAggregateOutputType | null
  }

  export type CrmAccountMinAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmAccountMaxAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmAccountCountAggregateOutputType = {
    id: number
    workspace: number
    app: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrmAccountMinAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmAccountMaxAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmAccountCountAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrmAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmAccount to aggregate.
     */
    where?: CrmAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmAccounts to fetch.
     */
    orderBy?: CrmAccountOrderByWithRelationInput | CrmAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmAccounts
    **/
    _count?: true | CrmAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmAccountMaxAggregateInputType
  }

  export type GetCrmAccountAggregateType<T extends CrmAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmAccount[P]>
      : GetScalarType<T[P], AggregateCrmAccount[P]>
  }




  export type CrmAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmAccountWhereInput
    orderBy?: CrmAccountOrderByWithAggregationInput | CrmAccountOrderByWithAggregationInput[]
    by: CrmAccountScalarFieldEnum[] | CrmAccountScalarFieldEnum
    having?: CrmAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmAccountCountAggregateInputType | true
    _min?: CrmAccountMinAggregateInputType
    _max?: CrmAccountMaxAggregateInputType
  }

  export type CrmAccountGroupByOutputType = {
    id: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: CrmAccountCountAggregateOutputType | null
    _min: CrmAccountMinAggregateOutputType | null
    _max: CrmAccountMaxAggregateOutputType | null
  }

  type GetCrmAccountGroupByPayload<T extends CrmAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmAccountGroupByOutputType[P]>
            : GetScalarType<T[P], CrmAccountGroupByOutputType[P]>
        }
      >
    >


  export type CrmAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunities?: boolean | CrmAccount$opportunitiesArgs<ExtArgs>
    activities?: boolean | CrmAccount$activitiesArgs<ExtArgs>
    _count?: boolean | CrmAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmAccount"]>

  export type CrmAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crmAccount"]>

  export type CrmAccountSelectScalar = {
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrmAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | CrmAccount$opportunitiesArgs<ExtArgs>
    activities?: boolean | CrmAccount$activitiesArgs<ExtArgs>
    _count?: boolean | CrmAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrmAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrmAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmAccount"
    objects: {
      opportunities: Prisma.$CrmOpportunityPayload<ExtArgs>[]
      activities: Prisma.$CrmActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspace: string
      app: string
      name: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crmAccount"]>
    composites: {}
  }

  type CrmAccountGetPayload<S extends boolean | null | undefined | CrmAccountDefaultArgs> = $Result.GetResult<Prisma.$CrmAccountPayload, S>

  type CrmAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrmAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrmAccountCountAggregateInputType | true
    }

  export interface CrmAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmAccount'], meta: { name: 'CrmAccount' } }
    /**
     * Find zero or one CrmAccount that matches the filter.
     * @param {CrmAccountFindUniqueArgs} args - Arguments to find a CrmAccount
     * @example
     * // Get one CrmAccount
     * const crmAccount = await prisma.crmAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmAccountFindUniqueArgs>(args: SelectSubset<T, CrmAccountFindUniqueArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrmAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrmAccountFindUniqueOrThrowArgs} args - Arguments to find a CrmAccount
     * @example
     * // Get one CrmAccount
     * const crmAccount = await prisma.crmAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrmAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountFindFirstArgs} args - Arguments to find a CrmAccount
     * @example
     * // Get one CrmAccount
     * const crmAccount = await prisma.crmAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmAccountFindFirstArgs>(args?: SelectSubset<T, CrmAccountFindFirstArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrmAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountFindFirstOrThrowArgs} args - Arguments to find a CrmAccount
     * @example
     * // Get one CrmAccount
     * const crmAccount = await prisma.crmAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrmAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmAccounts
     * const crmAccounts = await prisma.crmAccount.findMany()
     * 
     * // Get first 10 CrmAccounts
     * const crmAccounts = await prisma.crmAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmAccountWithIdOnly = await prisma.crmAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmAccountFindManyArgs>(args?: SelectSubset<T, CrmAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrmAccount.
     * @param {CrmAccountCreateArgs} args - Arguments to create a CrmAccount.
     * @example
     * // Create one CrmAccount
     * const CrmAccount = await prisma.crmAccount.create({
     *   data: {
     *     // ... data to create a CrmAccount
     *   }
     * })
     * 
     */
    create<T extends CrmAccountCreateArgs>(args: SelectSubset<T, CrmAccountCreateArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrmAccounts.
     * @param {CrmAccountCreateManyArgs} args - Arguments to create many CrmAccounts.
     * @example
     * // Create many CrmAccounts
     * const crmAccount = await prisma.crmAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmAccountCreateManyArgs>(args?: SelectSubset<T, CrmAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmAccounts and returns the data saved in the database.
     * @param {CrmAccountCreateManyAndReturnArgs} args - Arguments to create many CrmAccounts.
     * @example
     * // Create many CrmAccounts
     * const crmAccount = await prisma.crmAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmAccounts and only return the `id`
     * const crmAccountWithIdOnly = await prisma.crmAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrmAccount.
     * @param {CrmAccountDeleteArgs} args - Arguments to delete one CrmAccount.
     * @example
     * // Delete one CrmAccount
     * const CrmAccount = await prisma.crmAccount.delete({
     *   where: {
     *     // ... filter to delete one CrmAccount
     *   }
     * })
     * 
     */
    delete<T extends CrmAccountDeleteArgs>(args: SelectSubset<T, CrmAccountDeleteArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrmAccount.
     * @param {CrmAccountUpdateArgs} args - Arguments to update one CrmAccount.
     * @example
     * // Update one CrmAccount
     * const crmAccount = await prisma.crmAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmAccountUpdateArgs>(args: SelectSubset<T, CrmAccountUpdateArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrmAccounts.
     * @param {CrmAccountDeleteManyArgs} args - Arguments to filter CrmAccounts to delete.
     * @example
     * // Delete a few CrmAccounts
     * const { count } = await prisma.crmAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmAccountDeleteManyArgs>(args?: SelectSubset<T, CrmAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmAccounts
     * const crmAccount = await prisma.crmAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmAccountUpdateManyArgs>(args: SelectSubset<T, CrmAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrmAccount.
     * @param {CrmAccountUpsertArgs} args - Arguments to update or create a CrmAccount.
     * @example
     * // Update or create a CrmAccount
     * const crmAccount = await prisma.crmAccount.upsert({
     *   create: {
     *     // ... data to create a CrmAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmAccount we want to update
     *   }
     * })
     */
    upsert<T extends CrmAccountUpsertArgs>(args: SelectSubset<T, CrmAccountUpsertArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrmAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountCountArgs} args - Arguments to filter CrmAccounts to count.
     * @example
     * // Count the number of CrmAccounts
     * const count = await prisma.crmAccount.count({
     *   where: {
     *     // ... the filter for the CrmAccounts we want to count
     *   }
     * })
    **/
    count<T extends CrmAccountCountArgs>(
      args?: Subset<T, CrmAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmAccountAggregateArgs>(args: Subset<T, CrmAccountAggregateArgs>): Prisma.PrismaPromise<GetCrmAccountAggregateType<T>>

    /**
     * Group by CrmAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmAccountGroupByArgs['orderBy'] }
        : { orderBy?: CrmAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmAccount model
   */
  readonly fields: CrmAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunities<T extends CrmAccount$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, CrmAccount$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends CrmAccount$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, CrmAccount$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmAccount model
   */ 
  interface CrmAccountFieldRefs {
    readonly id: FieldRef<"CrmAccount", 'String'>
    readonly workspace: FieldRef<"CrmAccount", 'String'>
    readonly app: FieldRef<"CrmAccount", 'String'>
    readonly name: FieldRef<"CrmAccount", 'String'>
    readonly type: FieldRef<"CrmAccount", 'String'>
    readonly createdAt: FieldRef<"CrmAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"CrmAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmAccount findUnique
   */
  export type CrmAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter, which CrmAccount to fetch.
     */
    where: CrmAccountWhereUniqueInput
  }

  /**
   * CrmAccount findUniqueOrThrow
   */
  export type CrmAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter, which CrmAccount to fetch.
     */
    where: CrmAccountWhereUniqueInput
  }

  /**
   * CrmAccount findFirst
   */
  export type CrmAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter, which CrmAccount to fetch.
     */
    where?: CrmAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmAccounts to fetch.
     */
    orderBy?: CrmAccountOrderByWithRelationInput | CrmAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmAccounts.
     */
    cursor?: CrmAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmAccounts.
     */
    distinct?: CrmAccountScalarFieldEnum | CrmAccountScalarFieldEnum[]
  }

  /**
   * CrmAccount findFirstOrThrow
   */
  export type CrmAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter, which CrmAccount to fetch.
     */
    where?: CrmAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmAccounts to fetch.
     */
    orderBy?: CrmAccountOrderByWithRelationInput | CrmAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmAccounts.
     */
    cursor?: CrmAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmAccounts.
     */
    distinct?: CrmAccountScalarFieldEnum | CrmAccountScalarFieldEnum[]
  }

  /**
   * CrmAccount findMany
   */
  export type CrmAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter, which CrmAccounts to fetch.
     */
    where?: CrmAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmAccounts to fetch.
     */
    orderBy?: CrmAccountOrderByWithRelationInput | CrmAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmAccounts.
     */
    cursor?: CrmAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmAccounts.
     */
    skip?: number
    distinct?: CrmAccountScalarFieldEnum | CrmAccountScalarFieldEnum[]
  }

  /**
   * CrmAccount create
   */
  export type CrmAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmAccount.
     */
    data: XOR<CrmAccountCreateInput, CrmAccountUncheckedCreateInput>
  }

  /**
   * CrmAccount createMany
   */
  export type CrmAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmAccounts.
     */
    data: CrmAccountCreateManyInput | CrmAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmAccount createManyAndReturn
   */
  export type CrmAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrmAccounts.
     */
    data: CrmAccountCreateManyInput | CrmAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmAccount update
   */
  export type CrmAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmAccount.
     */
    data: XOR<CrmAccountUpdateInput, CrmAccountUncheckedUpdateInput>
    /**
     * Choose, which CrmAccount to update.
     */
    where: CrmAccountWhereUniqueInput
  }

  /**
   * CrmAccount updateMany
   */
  export type CrmAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmAccounts.
     */
    data: XOR<CrmAccountUpdateManyMutationInput, CrmAccountUncheckedUpdateManyInput>
    /**
     * Filter which CrmAccounts to update
     */
    where?: CrmAccountWhereInput
  }

  /**
   * CrmAccount upsert
   */
  export type CrmAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmAccount to update in case it exists.
     */
    where: CrmAccountWhereUniqueInput
    /**
     * In case the CrmAccount found by the `where` argument doesn't exist, create a new CrmAccount with this data.
     */
    create: XOR<CrmAccountCreateInput, CrmAccountUncheckedCreateInput>
    /**
     * In case the CrmAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmAccountUpdateInput, CrmAccountUncheckedUpdateInput>
  }

  /**
   * CrmAccount delete
   */
  export type CrmAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    /**
     * Filter which CrmAccount to delete.
     */
    where: CrmAccountWhereUniqueInput
  }

  /**
   * CrmAccount deleteMany
   */
  export type CrmAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmAccounts to delete
     */
    where?: CrmAccountWhereInput
  }

  /**
   * CrmAccount.opportunities
   */
  export type CrmAccount$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    where?: CrmOpportunityWhereInput
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    cursor?: CrmOpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmOpportunityScalarFieldEnum | CrmOpportunityScalarFieldEnum[]
  }

  /**
   * CrmAccount.activities
   */
  export type CrmAccount$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    where?: CrmActivityWhereInput
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    cursor?: CrmActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmAccount without action
   */
  export type CrmAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
  }


  /**
   * Model CrmOpportunity
   */

  export type AggregateCrmOpportunity = {
    _count: CrmOpportunityCountAggregateOutputType | null
    _avg: CrmOpportunityAvgAggregateOutputType | null
    _sum: CrmOpportunitySumAggregateOutputType | null
    _min: CrmOpportunityMinAggregateOutputType | null
    _max: CrmOpportunityMaxAggregateOutputType | null
  }

  export type CrmOpportunityAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CrmOpportunitySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CrmOpportunityMinAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    stage: string | null
    status: string | null
    contactId: string | null
    accountId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmOpportunityMaxAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    name: string | null
    stage: string | null
    status: string | null
    contactId: string | null
    accountId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrmOpportunityCountAggregateOutputType = {
    id: number
    workspace: number
    app: number
    name: number
    stage: number
    status: number
    contactId: number
    accountId: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrmOpportunityAvgAggregateInputType = {
    amount?: true
  }

  export type CrmOpportunitySumAggregateInputType = {
    amount?: true
  }

  export type CrmOpportunityMinAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    stage?: true
    status?: true
    contactId?: true
    accountId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmOpportunityMaxAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    stage?: true
    status?: true
    contactId?: true
    accountId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrmOpportunityCountAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    name?: true
    stage?: true
    status?: true
    contactId?: true
    accountId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrmOpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmOpportunity to aggregate.
     */
    where?: CrmOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmOpportunities to fetch.
     */
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmOpportunities
    **/
    _count?: true | CrmOpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrmOpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrmOpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmOpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmOpportunityMaxAggregateInputType
  }

  export type GetCrmOpportunityAggregateType<T extends CrmOpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmOpportunity[P]>
      : GetScalarType<T[P], AggregateCrmOpportunity[P]>
  }




  export type CrmOpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmOpportunityWhereInput
    orderBy?: CrmOpportunityOrderByWithAggregationInput | CrmOpportunityOrderByWithAggregationInput[]
    by: CrmOpportunityScalarFieldEnum[] | CrmOpportunityScalarFieldEnum
    having?: CrmOpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmOpportunityCountAggregateInputType | true
    _avg?: CrmOpportunityAvgAggregateInputType
    _sum?: CrmOpportunitySumAggregateInputType
    _min?: CrmOpportunityMinAggregateInputType
    _max?: CrmOpportunityMaxAggregateInputType
  }

  export type CrmOpportunityGroupByOutputType = {
    id: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId: string | null
    accountId: string | null
    amount: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CrmOpportunityCountAggregateOutputType | null
    _avg: CrmOpportunityAvgAggregateOutputType | null
    _sum: CrmOpportunitySumAggregateOutputType | null
    _min: CrmOpportunityMinAggregateOutputType | null
    _max: CrmOpportunityMaxAggregateOutputType | null
  }

  type GetCrmOpportunityGroupByPayload<T extends CrmOpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmOpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmOpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmOpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], CrmOpportunityGroupByOutputType[P]>
        }
      >
    >


  export type CrmOpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    stage?: boolean
    status?: boolean
    contactId?: boolean
    accountId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | CrmOpportunity$contactArgs<ExtArgs>
    account?: boolean | CrmOpportunity$accountArgs<ExtArgs>
    activities?: boolean | CrmOpportunity$activitiesArgs<ExtArgs>
    _count?: boolean | CrmOpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crmOpportunity"]>

  export type CrmOpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    stage?: boolean
    status?: boolean
    contactId?: boolean
    accountId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | CrmOpportunity$contactArgs<ExtArgs>
    account?: boolean | CrmOpportunity$accountArgs<ExtArgs>
  }, ExtArgs["result"]["crmOpportunity"]>

  export type CrmOpportunitySelectScalar = {
    id?: boolean
    workspace?: boolean
    app?: boolean
    name?: boolean
    stage?: boolean
    status?: boolean
    contactId?: boolean
    accountId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrmOpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | CrmOpportunity$contactArgs<ExtArgs>
    account?: boolean | CrmOpportunity$accountArgs<ExtArgs>
    activities?: boolean | CrmOpportunity$activitiesArgs<ExtArgs>
    _count?: boolean | CrmOpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrmOpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | CrmOpportunity$contactArgs<ExtArgs>
    account?: boolean | CrmOpportunity$accountArgs<ExtArgs>
  }

  export type $CrmOpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmOpportunity"
    objects: {
      contact: Prisma.$CrmContactPayload<ExtArgs> | null
      account: Prisma.$CrmAccountPayload<ExtArgs> | null
      activities: Prisma.$CrmActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspace: string
      app: string
      name: string
      stage: string
      status: string
      contactId: string | null
      accountId: string | null
      amount: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crmOpportunity"]>
    composites: {}
  }

  type CrmOpportunityGetPayload<S extends boolean | null | undefined | CrmOpportunityDefaultArgs> = $Result.GetResult<Prisma.$CrmOpportunityPayload, S>

  type CrmOpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrmOpportunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrmOpportunityCountAggregateInputType | true
    }

  export interface CrmOpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmOpportunity'], meta: { name: 'CrmOpportunity' } }
    /**
     * Find zero or one CrmOpportunity that matches the filter.
     * @param {CrmOpportunityFindUniqueArgs} args - Arguments to find a CrmOpportunity
     * @example
     * // Get one CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmOpportunityFindUniqueArgs>(args: SelectSubset<T, CrmOpportunityFindUniqueArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrmOpportunity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrmOpportunityFindUniqueOrThrowArgs} args - Arguments to find a CrmOpportunity
     * @example
     * // Get one CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmOpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmOpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrmOpportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityFindFirstArgs} args - Arguments to find a CrmOpportunity
     * @example
     * // Get one CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmOpportunityFindFirstArgs>(args?: SelectSubset<T, CrmOpportunityFindFirstArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrmOpportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityFindFirstOrThrowArgs} args - Arguments to find a CrmOpportunity
     * @example
     * // Get one CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmOpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmOpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrmOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmOpportunities
     * const crmOpportunities = await prisma.crmOpportunity.findMany()
     * 
     * // Get first 10 CrmOpportunities
     * const crmOpportunities = await prisma.crmOpportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmOpportunityWithIdOnly = await prisma.crmOpportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmOpportunityFindManyArgs>(args?: SelectSubset<T, CrmOpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrmOpportunity.
     * @param {CrmOpportunityCreateArgs} args - Arguments to create a CrmOpportunity.
     * @example
     * // Create one CrmOpportunity
     * const CrmOpportunity = await prisma.crmOpportunity.create({
     *   data: {
     *     // ... data to create a CrmOpportunity
     *   }
     * })
     * 
     */
    create<T extends CrmOpportunityCreateArgs>(args: SelectSubset<T, CrmOpportunityCreateArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrmOpportunities.
     * @param {CrmOpportunityCreateManyArgs} args - Arguments to create many CrmOpportunities.
     * @example
     * // Create many CrmOpportunities
     * const crmOpportunity = await prisma.crmOpportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmOpportunityCreateManyArgs>(args?: SelectSubset<T, CrmOpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmOpportunities and returns the data saved in the database.
     * @param {CrmOpportunityCreateManyAndReturnArgs} args - Arguments to create many CrmOpportunities.
     * @example
     * // Create many CrmOpportunities
     * const crmOpportunity = await prisma.crmOpportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmOpportunities and only return the `id`
     * const crmOpportunityWithIdOnly = await prisma.crmOpportunity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmOpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmOpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrmOpportunity.
     * @param {CrmOpportunityDeleteArgs} args - Arguments to delete one CrmOpportunity.
     * @example
     * // Delete one CrmOpportunity
     * const CrmOpportunity = await prisma.crmOpportunity.delete({
     *   where: {
     *     // ... filter to delete one CrmOpportunity
     *   }
     * })
     * 
     */
    delete<T extends CrmOpportunityDeleteArgs>(args: SelectSubset<T, CrmOpportunityDeleteArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrmOpportunity.
     * @param {CrmOpportunityUpdateArgs} args - Arguments to update one CrmOpportunity.
     * @example
     * // Update one CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmOpportunityUpdateArgs>(args: SelectSubset<T, CrmOpportunityUpdateArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrmOpportunities.
     * @param {CrmOpportunityDeleteManyArgs} args - Arguments to filter CrmOpportunities to delete.
     * @example
     * // Delete a few CrmOpportunities
     * const { count } = await prisma.crmOpportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmOpportunityDeleteManyArgs>(args?: SelectSubset<T, CrmOpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmOpportunities
     * const crmOpportunity = await prisma.crmOpportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmOpportunityUpdateManyArgs>(args: SelectSubset<T, CrmOpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrmOpportunity.
     * @param {CrmOpportunityUpsertArgs} args - Arguments to update or create a CrmOpportunity.
     * @example
     * // Update or create a CrmOpportunity
     * const crmOpportunity = await prisma.crmOpportunity.upsert({
     *   create: {
     *     // ... data to create a CrmOpportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmOpportunity we want to update
     *   }
     * })
     */
    upsert<T extends CrmOpportunityUpsertArgs>(args: SelectSubset<T, CrmOpportunityUpsertArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrmOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityCountArgs} args - Arguments to filter CrmOpportunities to count.
     * @example
     * // Count the number of CrmOpportunities
     * const count = await prisma.crmOpportunity.count({
     *   where: {
     *     // ... the filter for the CrmOpportunities we want to count
     *   }
     * })
    **/
    count<T extends CrmOpportunityCountArgs>(
      args?: Subset<T, CrmOpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmOpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmOpportunityAggregateArgs>(args: Subset<T, CrmOpportunityAggregateArgs>): Prisma.PrismaPromise<GetCrmOpportunityAggregateType<T>>

    /**
     * Group by CrmOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmOpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmOpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmOpportunityGroupByArgs['orderBy'] }
        : { orderBy?: CrmOpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmOpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmOpportunity model
   */
  readonly fields: CrmOpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmOpportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmOpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends CrmOpportunity$contactArgs<ExtArgs> = {}>(args?: Subset<T, CrmOpportunity$contactArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    account<T extends CrmOpportunity$accountArgs<ExtArgs> = {}>(args?: Subset<T, CrmOpportunity$accountArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    activities<T extends CrmOpportunity$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, CrmOpportunity$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmOpportunity model
   */ 
  interface CrmOpportunityFieldRefs {
    readonly id: FieldRef<"CrmOpportunity", 'String'>
    readonly workspace: FieldRef<"CrmOpportunity", 'String'>
    readonly app: FieldRef<"CrmOpportunity", 'String'>
    readonly name: FieldRef<"CrmOpportunity", 'String'>
    readonly stage: FieldRef<"CrmOpportunity", 'String'>
    readonly status: FieldRef<"CrmOpportunity", 'String'>
    readonly contactId: FieldRef<"CrmOpportunity", 'String'>
    readonly accountId: FieldRef<"CrmOpportunity", 'String'>
    readonly amount: FieldRef<"CrmOpportunity", 'Decimal'>
    readonly createdAt: FieldRef<"CrmOpportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"CrmOpportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmOpportunity findUnique
   */
  export type CrmOpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which CrmOpportunity to fetch.
     */
    where: CrmOpportunityWhereUniqueInput
  }

  /**
   * CrmOpportunity findUniqueOrThrow
   */
  export type CrmOpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which CrmOpportunity to fetch.
     */
    where: CrmOpportunityWhereUniqueInput
  }

  /**
   * CrmOpportunity findFirst
   */
  export type CrmOpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which CrmOpportunity to fetch.
     */
    where?: CrmOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmOpportunities to fetch.
     */
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmOpportunities.
     */
    cursor?: CrmOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmOpportunities.
     */
    distinct?: CrmOpportunityScalarFieldEnum | CrmOpportunityScalarFieldEnum[]
  }

  /**
   * CrmOpportunity findFirstOrThrow
   */
  export type CrmOpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which CrmOpportunity to fetch.
     */
    where?: CrmOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmOpportunities to fetch.
     */
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmOpportunities.
     */
    cursor?: CrmOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmOpportunities.
     */
    distinct?: CrmOpportunityScalarFieldEnum | CrmOpportunityScalarFieldEnum[]
  }

  /**
   * CrmOpportunity findMany
   */
  export type CrmOpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which CrmOpportunities to fetch.
     */
    where?: CrmOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmOpportunities to fetch.
     */
    orderBy?: CrmOpportunityOrderByWithRelationInput | CrmOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmOpportunities.
     */
    cursor?: CrmOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmOpportunities.
     */
    skip?: number
    distinct?: CrmOpportunityScalarFieldEnum | CrmOpportunityScalarFieldEnum[]
  }

  /**
   * CrmOpportunity create
   */
  export type CrmOpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmOpportunity.
     */
    data: XOR<CrmOpportunityCreateInput, CrmOpportunityUncheckedCreateInput>
  }

  /**
   * CrmOpportunity createMany
   */
  export type CrmOpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmOpportunities.
     */
    data: CrmOpportunityCreateManyInput | CrmOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmOpportunity createManyAndReturn
   */
  export type CrmOpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrmOpportunities.
     */
    data: CrmOpportunityCreateManyInput | CrmOpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmOpportunity update
   */
  export type CrmOpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmOpportunity.
     */
    data: XOR<CrmOpportunityUpdateInput, CrmOpportunityUncheckedUpdateInput>
    /**
     * Choose, which CrmOpportunity to update.
     */
    where: CrmOpportunityWhereUniqueInput
  }

  /**
   * CrmOpportunity updateMany
   */
  export type CrmOpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmOpportunities.
     */
    data: XOR<CrmOpportunityUpdateManyMutationInput, CrmOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which CrmOpportunities to update
     */
    where?: CrmOpportunityWhereInput
  }

  /**
   * CrmOpportunity upsert
   */
  export type CrmOpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmOpportunity to update in case it exists.
     */
    where: CrmOpportunityWhereUniqueInput
    /**
     * In case the CrmOpportunity found by the `where` argument doesn't exist, create a new CrmOpportunity with this data.
     */
    create: XOR<CrmOpportunityCreateInput, CrmOpportunityUncheckedCreateInput>
    /**
     * In case the CrmOpportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmOpportunityUpdateInput, CrmOpportunityUncheckedUpdateInput>
  }

  /**
   * CrmOpportunity delete
   */
  export type CrmOpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    /**
     * Filter which CrmOpportunity to delete.
     */
    where: CrmOpportunityWhereUniqueInput
  }

  /**
   * CrmOpportunity deleteMany
   */
  export type CrmOpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmOpportunities to delete
     */
    where?: CrmOpportunityWhereInput
  }

  /**
   * CrmOpportunity.contact
   */
  export type CrmOpportunity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    where?: CrmContactWhereInput
  }

  /**
   * CrmOpportunity.account
   */
  export type CrmOpportunity$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    where?: CrmAccountWhereInput
  }

  /**
   * CrmOpportunity.activities
   */
  export type CrmOpportunity$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    where?: CrmActivityWhereInput
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    cursor?: CrmActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmOpportunity without action
   */
  export type CrmOpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
  }


  /**
   * Model CrmActivity
   */

  export type AggregateCrmActivity = {
    _count: CrmActivityCountAggregateOutputType | null
    _min: CrmActivityMinAggregateOutputType | null
    _max: CrmActivityMaxAggregateOutputType | null
  }

  export type CrmActivityMinAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    type: string | null
    subject: string | null
    contactId: string | null
    accountId: string | null
    opportunityId: string | null
    createdAt: Date | null
  }

  export type CrmActivityMaxAggregateOutputType = {
    id: string | null
    workspace: string | null
    app: string | null
    type: string | null
    subject: string | null
    contactId: string | null
    accountId: string | null
    opportunityId: string | null
    createdAt: Date | null
  }

  export type CrmActivityCountAggregateOutputType = {
    id: number
    workspace: number
    app: number
    type: number
    subject: number
    contactId: number
    accountId: number
    opportunityId: number
    createdAt: number
    _all: number
  }


  export type CrmActivityMinAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    type?: true
    subject?: true
    contactId?: true
    accountId?: true
    opportunityId?: true
    createdAt?: true
  }

  export type CrmActivityMaxAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    type?: true
    subject?: true
    contactId?: true
    accountId?: true
    opportunityId?: true
    createdAt?: true
  }

  export type CrmActivityCountAggregateInputType = {
    id?: true
    workspace?: true
    app?: true
    type?: true
    subject?: true
    contactId?: true
    accountId?: true
    opportunityId?: true
    createdAt?: true
    _all?: true
  }

  export type CrmActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmActivity to aggregate.
     */
    where?: CrmActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmActivities to fetch.
     */
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrmActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrmActivities
    **/
    _count?: true | CrmActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrmActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrmActivityMaxAggregateInputType
  }

  export type GetCrmActivityAggregateType<T extends CrmActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateCrmActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrmActivity[P]>
      : GetScalarType<T[P], AggregateCrmActivity[P]>
  }




  export type CrmActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrmActivityWhereInput
    orderBy?: CrmActivityOrderByWithAggregationInput | CrmActivityOrderByWithAggregationInput[]
    by: CrmActivityScalarFieldEnum[] | CrmActivityScalarFieldEnum
    having?: CrmActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrmActivityCountAggregateInputType | true
    _min?: CrmActivityMinAggregateInputType
    _max?: CrmActivityMaxAggregateInputType
  }

  export type CrmActivityGroupByOutputType = {
    id: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId: string | null
    accountId: string | null
    opportunityId: string | null
    createdAt: Date
    _count: CrmActivityCountAggregateOutputType | null
    _min: CrmActivityMinAggregateOutputType | null
    _max: CrmActivityMaxAggregateOutputType | null
  }

  type GetCrmActivityGroupByPayload<T extends CrmActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrmActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrmActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrmActivityGroupByOutputType[P]>
            : GetScalarType<T[P], CrmActivityGroupByOutputType[P]>
        }
      >
    >


  export type CrmActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    type?: boolean
    subject?: boolean
    contactId?: boolean
    accountId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
    contact?: boolean | CrmActivity$contactArgs<ExtArgs>
    account?: boolean | CrmActivity$accountArgs<ExtArgs>
    opportunity?: boolean | CrmActivity$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["crmActivity"]>

  export type CrmActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspace?: boolean
    app?: boolean
    type?: boolean
    subject?: boolean
    contactId?: boolean
    accountId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
    contact?: boolean | CrmActivity$contactArgs<ExtArgs>
    account?: boolean | CrmActivity$accountArgs<ExtArgs>
    opportunity?: boolean | CrmActivity$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["crmActivity"]>

  export type CrmActivitySelectScalar = {
    id?: boolean
    workspace?: boolean
    app?: boolean
    type?: boolean
    subject?: boolean
    contactId?: boolean
    accountId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
  }

  export type CrmActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | CrmActivity$contactArgs<ExtArgs>
    account?: boolean | CrmActivity$accountArgs<ExtArgs>
    opportunity?: boolean | CrmActivity$opportunityArgs<ExtArgs>
  }
  export type CrmActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | CrmActivity$contactArgs<ExtArgs>
    account?: boolean | CrmActivity$accountArgs<ExtArgs>
    opportunity?: boolean | CrmActivity$opportunityArgs<ExtArgs>
  }

  export type $CrmActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrmActivity"
    objects: {
      contact: Prisma.$CrmContactPayload<ExtArgs> | null
      account: Prisma.$CrmAccountPayload<ExtArgs> | null
      opportunity: Prisma.$CrmOpportunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspace: string
      app: string
      type: string
      subject: string
      contactId: string | null
      accountId: string | null
      opportunityId: string | null
      createdAt: Date
    }, ExtArgs["result"]["crmActivity"]>
    composites: {}
  }

  type CrmActivityGetPayload<S extends boolean | null | undefined | CrmActivityDefaultArgs> = $Result.GetResult<Prisma.$CrmActivityPayload, S>

  type CrmActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrmActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrmActivityCountAggregateInputType | true
    }

  export interface CrmActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrmActivity'], meta: { name: 'CrmActivity' } }
    /**
     * Find zero or one CrmActivity that matches the filter.
     * @param {CrmActivityFindUniqueArgs} args - Arguments to find a CrmActivity
     * @example
     * // Get one CrmActivity
     * const crmActivity = await prisma.crmActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrmActivityFindUniqueArgs>(args: SelectSubset<T, CrmActivityFindUniqueArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrmActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrmActivityFindUniqueOrThrowArgs} args - Arguments to find a CrmActivity
     * @example
     * // Get one CrmActivity
     * const crmActivity = await prisma.crmActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrmActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, CrmActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrmActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityFindFirstArgs} args - Arguments to find a CrmActivity
     * @example
     * // Get one CrmActivity
     * const crmActivity = await prisma.crmActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrmActivityFindFirstArgs>(args?: SelectSubset<T, CrmActivityFindFirstArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrmActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityFindFirstOrThrowArgs} args - Arguments to find a CrmActivity
     * @example
     * // Get one CrmActivity
     * const crmActivity = await prisma.crmActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrmActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, CrmActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrmActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrmActivities
     * const crmActivities = await prisma.crmActivity.findMany()
     * 
     * // Get first 10 CrmActivities
     * const crmActivities = await prisma.crmActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crmActivityWithIdOnly = await prisma.crmActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrmActivityFindManyArgs>(args?: SelectSubset<T, CrmActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrmActivity.
     * @param {CrmActivityCreateArgs} args - Arguments to create a CrmActivity.
     * @example
     * // Create one CrmActivity
     * const CrmActivity = await prisma.crmActivity.create({
     *   data: {
     *     // ... data to create a CrmActivity
     *   }
     * })
     * 
     */
    create<T extends CrmActivityCreateArgs>(args: SelectSubset<T, CrmActivityCreateArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrmActivities.
     * @param {CrmActivityCreateManyArgs} args - Arguments to create many CrmActivities.
     * @example
     * // Create many CrmActivities
     * const crmActivity = await prisma.crmActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrmActivityCreateManyArgs>(args?: SelectSubset<T, CrmActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrmActivities and returns the data saved in the database.
     * @param {CrmActivityCreateManyAndReturnArgs} args - Arguments to create many CrmActivities.
     * @example
     * // Create many CrmActivities
     * const crmActivity = await prisma.crmActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrmActivities and only return the `id`
     * const crmActivityWithIdOnly = await prisma.crmActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrmActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, CrmActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrmActivity.
     * @param {CrmActivityDeleteArgs} args - Arguments to delete one CrmActivity.
     * @example
     * // Delete one CrmActivity
     * const CrmActivity = await prisma.crmActivity.delete({
     *   where: {
     *     // ... filter to delete one CrmActivity
     *   }
     * })
     * 
     */
    delete<T extends CrmActivityDeleteArgs>(args: SelectSubset<T, CrmActivityDeleteArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrmActivity.
     * @param {CrmActivityUpdateArgs} args - Arguments to update one CrmActivity.
     * @example
     * // Update one CrmActivity
     * const crmActivity = await prisma.crmActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrmActivityUpdateArgs>(args: SelectSubset<T, CrmActivityUpdateArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrmActivities.
     * @param {CrmActivityDeleteManyArgs} args - Arguments to filter CrmActivities to delete.
     * @example
     * // Delete a few CrmActivities
     * const { count } = await prisma.crmActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrmActivityDeleteManyArgs>(args?: SelectSubset<T, CrmActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrmActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrmActivities
     * const crmActivity = await prisma.crmActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrmActivityUpdateManyArgs>(args: SelectSubset<T, CrmActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrmActivity.
     * @param {CrmActivityUpsertArgs} args - Arguments to update or create a CrmActivity.
     * @example
     * // Update or create a CrmActivity
     * const crmActivity = await prisma.crmActivity.upsert({
     *   create: {
     *     // ... data to create a CrmActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrmActivity we want to update
     *   }
     * })
     */
    upsert<T extends CrmActivityUpsertArgs>(args: SelectSubset<T, CrmActivityUpsertArgs<ExtArgs>>): Prisma__CrmActivityClient<$Result.GetResult<Prisma.$CrmActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrmActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityCountArgs} args - Arguments to filter CrmActivities to count.
     * @example
     * // Count the number of CrmActivities
     * const count = await prisma.crmActivity.count({
     *   where: {
     *     // ... the filter for the CrmActivities we want to count
     *   }
     * })
    **/
    count<T extends CrmActivityCountArgs>(
      args?: Subset<T, CrmActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrmActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrmActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrmActivityAggregateArgs>(args: Subset<T, CrmActivityAggregateArgs>): Prisma.PrismaPromise<GetCrmActivityAggregateType<T>>

    /**
     * Group by CrmActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrmActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrmActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrmActivityGroupByArgs['orderBy'] }
        : { orderBy?: CrmActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrmActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrmActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrmActivity model
   */
  readonly fields: CrmActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrmActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrmActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends CrmActivity$contactArgs<ExtArgs> = {}>(args?: Subset<T, CrmActivity$contactArgs<ExtArgs>>): Prisma__CrmContactClient<$Result.GetResult<Prisma.$CrmContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    account<T extends CrmActivity$accountArgs<ExtArgs> = {}>(args?: Subset<T, CrmActivity$accountArgs<ExtArgs>>): Prisma__CrmAccountClient<$Result.GetResult<Prisma.$CrmAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    opportunity<T extends CrmActivity$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, CrmActivity$opportunityArgs<ExtArgs>>): Prisma__CrmOpportunityClient<$Result.GetResult<Prisma.$CrmOpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrmActivity model
   */ 
  interface CrmActivityFieldRefs {
    readonly id: FieldRef<"CrmActivity", 'String'>
    readonly workspace: FieldRef<"CrmActivity", 'String'>
    readonly app: FieldRef<"CrmActivity", 'String'>
    readonly type: FieldRef<"CrmActivity", 'String'>
    readonly subject: FieldRef<"CrmActivity", 'String'>
    readonly contactId: FieldRef<"CrmActivity", 'String'>
    readonly accountId: FieldRef<"CrmActivity", 'String'>
    readonly opportunityId: FieldRef<"CrmActivity", 'String'>
    readonly createdAt: FieldRef<"CrmActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrmActivity findUnique
   */
  export type CrmActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter, which CrmActivity to fetch.
     */
    where: CrmActivityWhereUniqueInput
  }

  /**
   * CrmActivity findUniqueOrThrow
   */
  export type CrmActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter, which CrmActivity to fetch.
     */
    where: CrmActivityWhereUniqueInput
  }

  /**
   * CrmActivity findFirst
   */
  export type CrmActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter, which CrmActivity to fetch.
     */
    where?: CrmActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmActivities to fetch.
     */
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmActivities.
     */
    cursor?: CrmActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmActivities.
     */
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmActivity findFirstOrThrow
   */
  export type CrmActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter, which CrmActivity to fetch.
     */
    where?: CrmActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmActivities to fetch.
     */
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrmActivities.
     */
    cursor?: CrmActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrmActivities.
     */
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmActivity findMany
   */
  export type CrmActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter, which CrmActivities to fetch.
     */
    where?: CrmActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrmActivities to fetch.
     */
    orderBy?: CrmActivityOrderByWithRelationInput | CrmActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrmActivities.
     */
    cursor?: CrmActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrmActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrmActivities.
     */
    skip?: number
    distinct?: CrmActivityScalarFieldEnum | CrmActivityScalarFieldEnum[]
  }

  /**
   * CrmActivity create
   */
  export type CrmActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a CrmActivity.
     */
    data: XOR<CrmActivityCreateInput, CrmActivityUncheckedCreateInput>
  }

  /**
   * CrmActivity createMany
   */
  export type CrmActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrmActivities.
     */
    data: CrmActivityCreateManyInput | CrmActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrmActivity createManyAndReturn
   */
  export type CrmActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrmActivities.
     */
    data: CrmActivityCreateManyInput | CrmActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrmActivity update
   */
  export type CrmActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a CrmActivity.
     */
    data: XOR<CrmActivityUpdateInput, CrmActivityUncheckedUpdateInput>
    /**
     * Choose, which CrmActivity to update.
     */
    where: CrmActivityWhereUniqueInput
  }

  /**
   * CrmActivity updateMany
   */
  export type CrmActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrmActivities.
     */
    data: XOR<CrmActivityUpdateManyMutationInput, CrmActivityUncheckedUpdateManyInput>
    /**
     * Filter which CrmActivities to update
     */
    where?: CrmActivityWhereInput
  }

  /**
   * CrmActivity upsert
   */
  export type CrmActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the CrmActivity to update in case it exists.
     */
    where: CrmActivityWhereUniqueInput
    /**
     * In case the CrmActivity found by the `where` argument doesn't exist, create a new CrmActivity with this data.
     */
    create: XOR<CrmActivityCreateInput, CrmActivityUncheckedCreateInput>
    /**
     * In case the CrmActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrmActivityUpdateInput, CrmActivityUncheckedUpdateInput>
  }

  /**
   * CrmActivity delete
   */
  export type CrmActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
    /**
     * Filter which CrmActivity to delete.
     */
    where: CrmActivityWhereUniqueInput
  }

  /**
   * CrmActivity deleteMany
   */
  export type CrmActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrmActivities to delete
     */
    where?: CrmActivityWhereInput
  }

  /**
   * CrmActivity.contact
   */
  export type CrmActivity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmContact
     */
    select?: CrmContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmContactInclude<ExtArgs> | null
    where?: CrmContactWhereInput
  }

  /**
   * CrmActivity.account
   */
  export type CrmActivity$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmAccount
     */
    select?: CrmAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmAccountInclude<ExtArgs> | null
    where?: CrmAccountWhereInput
  }

  /**
   * CrmActivity.opportunity
   */
  export type CrmActivity$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmOpportunity
     */
    select?: CrmOpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmOpportunityInclude<ExtArgs> | null
    where?: CrmOpportunityWhereInput
  }

  /**
   * CrmActivity without action
   */
  export type CrmActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrmActivity
     */
    select?: CrmActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrmActivityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PersonScalarFieldEnum: {
    id: 'id',
    birthDate: 'birthDate',
    gender: 'gender',
    citizenshipStatus: 'citizenshipStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const PersonNameScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    given: 'given',
    middle: 'middle',
    family: 'family',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonNameScalarFieldEnum = (typeof PersonNameScalarFieldEnum)[keyof typeof PersonNameScalarFieldEnum]


  export const EmailAddressScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    address: 'address',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailAddressScalarFieldEnum = (typeof EmailAddressScalarFieldEnum)[keyof typeof EmailAddressScalarFieldEnum]


  export const PhoneScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    number: 'number',
    extension: 'extension',
    type: 'type',
    preferred: 'preferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhoneScalarFieldEnum = (typeof PhoneScalarFieldEnum)[keyof typeof PhoneScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    type: 'type',
    line1: 'line1',
    line2: 'line2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const DoNotEngageGlobalScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    emailBlocked: 'emailBlocked',
    smsBlocked: 'smsBlocked',
    phoneBlocked: 'phoneBlocked',
    source: 'source',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedById: 'updatedById'
  };

  export type DoNotEngageGlobalScalarFieldEnum = (typeof DoNotEngageGlobalScalarFieldEnum)[keyof typeof DoNotEngageGlobalScalarFieldEnum]


  export const DoNotEngageAgentScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type DoNotEngageAgentScalarFieldEnum = (typeof DoNotEngageAgentScalarFieldEnum)[keyof typeof DoNotEngageAgentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    type: 'type',
    status: 'status',
    startOn: 'startOn',
    entryAcademicPeriodId: 'entryAcademicPeriodId',
    academicLevel: 'academicLevel',
    residency: 'residency',
    studentClassification: 'studentClassification',
    studentLoad: 'studentLoad',
    academicStandingCode: 'academicStandingCode',
    studentNumber: 'studentNumber',
    isFirstGen: 'isFirstGen',
    isPellEligible: 'isPellEligible',
    isInState: 'isInState',
    workHoursPerWeek: 'workHoursPerWeek',
    commuteMinutes: 'commuteMinutes',
    hasHousingInstability: 'hasHousingInstability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const AcademicPeriodScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    type: 'type',
    startOn: 'startOn',
    endOn: 'endOn',
    censusOn: 'censusOn',
    registrationStartOn: 'registrationStartOn',
    registrationEndOn: 'registrationEndOn',
    academicYear: 'academicYear',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicPeriodScalarFieldEnum = (typeof AcademicPeriodScalarFieldEnum)[keyof typeof AcademicPeriodScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    subjectCode: 'subjectCode',
    number: 'number',
    title: 'title',
    description: 'description',
    creditType: 'creditType',
    creditsMinimum: 'creditsMinimum',
    creditsMaximum: 'creditsMaximum',
    creditsIncrement: 'creditsIncrement',
    courseLevel: 'courseLevel',
    status: 'status',
    effectiveStartDate: 'effectiveStartDate',
    effectiveEndDate: 'effectiveEndDate',
    catalogYear: 'catalogYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    academicPeriodId: 'academicPeriodId',
    number: 'number',
    title: 'title',
    crn: 'crn',
    startOn: 'startOn',
    endOn: 'endOn',
    status: 'status',
    capacity: 'capacity',
    enrolled: 'enrolled',
    available: 'available',
    waitlistCapacity: 'waitlistCapacity',
    waitlistEnrolled: 'waitlistEnrolled',
    instructionalMethodCode: 'instructionalMethodCode',
    daysOfWeek: 'daysOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    building: 'building',
    roomNumber: 'roomNumber',
    creditType: 'creditType',
    creditsMinimum: 'creditsMinimum',
    creditsMaximum: 'creditsMaximum',
    instructorPersonId: 'instructorPersonId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const SectionRegistrationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sectionId: 'sectionId',
    academicPeriodId: 'academicPeriodId',
    statusCode: 'statusCode',
    registrationDate: 'registrationDate',
    registeredOn: 'registeredOn',
    creditType: 'creditType',
    credits: 'credits',
    gradingOptionCode: 'gradingOptionCode',
    academicLoad: 'academicLoad',
    residencyStatus: 'residencyStatus',
    attendanceRate: 'attendanceRate',
    midtermGrade: 'midtermGrade',
    finalGrade: 'finalGrade',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionRegistrationScalarFieldEnum = (typeof SectionRegistrationScalarFieldEnum)[keyof typeof SectionRegistrationScalarFieldEnum]


  export const StudentTranscriptGradeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sectionRegistrationId: 'sectionRegistrationId',
    sectionId: 'sectionId',
    academicPeriodId: 'academicPeriodId',
    courseId: 'courseId',
    gradeSchemeCode: 'gradeSchemeCode',
    gradeValue: 'gradeValue',
    gradePoints: 'gradePoints',
    qualityPoints: 'qualityPoints',
    creditsAttempted: 'creditsAttempted',
    creditsEarned: 'creditsEarned',
    finalGradeDate: 'finalGradeDate',
    status: 'status',
    incomplete: 'incomplete',
    repeat: 'repeat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentTranscriptGradeScalarFieldEnum = (typeof StudentTranscriptGradeScalarFieldEnum)[keyof typeof StudentTranscriptGradeScalarFieldEnum]


  export const AcademicProgramScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    type: 'type',
    level: 'level',
    degreeCode: 'degreeCode',
    status: 'status',
    startOn: 'startOn',
    endOn: 'endOn',
    accreditationCode: 'accreditationCode',
    creditsRequired: 'creditsRequired',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicProgramScalarFieldEnum = (typeof AcademicProgramScalarFieldEnum)[keyof typeof AcademicProgramScalarFieldEnum]


  export const StudentAcademicProgramScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicProgramId: 'academicProgramId',
    startOn: 'startOn',
    endOn: 'endOn',
    status: 'status',
    catalogYear: 'catalogYear',
    primary: 'primary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAcademicProgramScalarFieldEnum = (typeof StudentAcademicProgramScalarFieldEnum)[keyof typeof StudentAcademicProgramScalarFieldEnum]


  export const AcademicCredentialScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    credentialCode: 'credentialCode',
    academicProgramId: 'academicProgramId',
    awardedOn: 'awardedOn',
    status: 'status',
    academicPeriodId: 'academicPeriodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicCredentialScalarFieldEnum = (typeof AcademicCredentialScalarFieldEnum)[keyof typeof AcademicCredentialScalarFieldEnum]


  export const StudentRiskScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicPeriodId: 'academicPeriodId',
    attendanceRiskScore: 'attendanceRiskScore',
    academicSupportRiskScore: 'academicSupportRiskScore',
    overallRiskBucket: 'overallRiskBucket',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type StudentRiskScalarFieldEnum = (typeof StudentRiskScalarFieldEnum)[keyof typeof StudentRiskScalarFieldEnum]


  export const SimulationStateScalarFieldEnum: {
    id: 'id',
    currentSimDate: 'currentSimDate',
    lastTickDate: 'lastTickDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SimulationStateScalarFieldEnum = (typeof SimulationStateScalarFieldEnum)[keyof typeof SimulationStateScalarFieldEnum]


  export const CrmContactScalarFieldEnum: {
    id: 'id',
    workspace: 'workspace',
    app: 'app',
    name: 'name',
    type: 'type',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrmContactScalarFieldEnum = (typeof CrmContactScalarFieldEnum)[keyof typeof CrmContactScalarFieldEnum]


  export const CrmAccountScalarFieldEnum: {
    id: 'id',
    workspace: 'workspace',
    app: 'app',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrmAccountScalarFieldEnum = (typeof CrmAccountScalarFieldEnum)[keyof typeof CrmAccountScalarFieldEnum]


  export const CrmOpportunityScalarFieldEnum: {
    id: 'id',
    workspace: 'workspace',
    app: 'app',
    name: 'name',
    stage: 'stage',
    status: 'status',
    contactId: 'contactId',
    accountId: 'accountId',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrmOpportunityScalarFieldEnum = (typeof CrmOpportunityScalarFieldEnum)[keyof typeof CrmOpportunityScalarFieldEnum]


  export const CrmActivityScalarFieldEnum: {
    id: 'id',
    workspace: 'workspace',
    app: 'app',
    type: 'type',
    subject: 'subject',
    contactId: 'contactId',
    accountId: 'accountId',
    opportunityId: 'opportunityId',
    createdAt: 'createdAt'
  };

  export type CrmActivityScalarFieldEnum = (typeof CrmActivityScalarFieldEnum)[keyof typeof CrmActivityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RiskBucket'
   */
  export type EnumRiskBucketFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskBucket'>
    


  /**
   * Reference to a field of type 'RiskBucket[]'
   */
  export type ListEnumRiskBucketFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskBucket[]'>
    
  /**
   * Deep Input Types
   */


  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    birthDate?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: StringNullableFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    names?: PersonNameListRelationFilter
    emails?: EmailAddressListRelationFilter
    phones?: PhoneListRelationFilter
    addresses?: AddressListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    sections?: SectionListRelationFilter
    doNotEngageGlobal?: XOR<DoNotEngageGlobalNullableRelationFilter, DoNotEngageGlobalWhereInput> | null
    doNotEngageAgents?: DoNotEngageAgentListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    citizenshipStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    names?: PersonNameOrderByRelationAggregateInput
    emails?: EmailAddressOrderByRelationAggregateInput
    phones?: PhoneOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    sections?: SectionOrderByRelationAggregateInput
    doNotEngageGlobal?: DoNotEngageGlobalOrderByWithRelationInput
    doNotEngageAgents?: DoNotEngageAgentOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    birthDate?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: StringNullableFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    names?: PersonNameListRelationFilter
    emails?: EmailAddressListRelationFilter
    phones?: PhoneListRelationFilter
    addresses?: AddressListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    sections?: SectionListRelationFilter
    doNotEngageGlobal?: XOR<DoNotEngageGlobalNullableRelationFilter, DoNotEngageGlobalWhereInput> | null
    doNotEngageAgents?: DoNotEngageAgentListRelationFilter
  }, "id">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    citizenshipStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Person"> | string | null
    citizenshipStatus?: StringNullableWithAggregatesFilter<"Person"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
  }

  export type PersonNameWhereInput = {
    AND?: PersonNameWhereInput | PersonNameWhereInput[]
    OR?: PersonNameWhereInput[]
    NOT?: PersonNameWhereInput | PersonNameWhereInput[]
    id?: StringFilter<"PersonName"> | string
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type PersonNameOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrderInput | SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type PersonNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonNameWhereInput | PersonNameWhereInput[]
    OR?: PersonNameWhereInput[]
    NOT?: PersonNameWhereInput | PersonNameWhereInput[]
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id">

  export type PersonNameOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrderInput | SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonNameCountOrderByAggregateInput
    _max?: PersonNameMaxOrderByAggregateInput
    _min?: PersonNameMinOrderByAggregateInput
  }

  export type PersonNameScalarWhereWithAggregatesInput = {
    AND?: PersonNameScalarWhereWithAggregatesInput | PersonNameScalarWhereWithAggregatesInput[]
    OR?: PersonNameScalarWhereWithAggregatesInput[]
    NOT?: PersonNameScalarWhereWithAggregatesInput | PersonNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonName"> | string
    personId?: StringWithAggregatesFilter<"PersonName"> | string
    given?: StringWithAggregatesFilter<"PersonName"> | string
    middle?: StringNullableWithAggregatesFilter<"PersonName"> | string | null
    family?: StringWithAggregatesFilter<"PersonName"> | string
    type?: StringWithAggregatesFilter<"PersonName"> | string
    preferred?: BoolWithAggregatesFilter<"PersonName"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonName"> | Date | string
  }

  export type EmailAddressWhereInput = {
    AND?: EmailAddressWhereInput | EmailAddressWhereInput[]
    OR?: EmailAddressWhereInput[]
    NOT?: EmailAddressWhereInput | EmailAddressWhereInput[]
    id?: StringFilter<"EmailAddress"> | string
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type EmailAddressOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type EmailAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId_address?: EmailAddressPersonIdAddressCompoundUniqueInput
    AND?: EmailAddressWhereInput | EmailAddressWhereInput[]
    OR?: EmailAddressWhereInput[]
    NOT?: EmailAddressWhereInput | EmailAddressWhereInput[]
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id" | "personId_address">

  export type EmailAddressOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailAddressCountOrderByAggregateInput
    _max?: EmailAddressMaxOrderByAggregateInput
    _min?: EmailAddressMinOrderByAggregateInput
  }

  export type EmailAddressScalarWhereWithAggregatesInput = {
    AND?: EmailAddressScalarWhereWithAggregatesInput | EmailAddressScalarWhereWithAggregatesInput[]
    OR?: EmailAddressScalarWhereWithAggregatesInput[]
    NOT?: EmailAddressScalarWhereWithAggregatesInput | EmailAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAddress"> | string
    personId?: StringWithAggregatesFilter<"EmailAddress"> | string
    address?: StringWithAggregatesFilter<"EmailAddress"> | string
    type?: StringWithAggregatesFilter<"EmailAddress"> | string
    preferred?: BoolWithAggregatesFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAddress"> | Date | string
  }

  export type PhoneWhereInput = {
    AND?: PhoneWhereInput | PhoneWhereInput[]
    OR?: PhoneWhereInput[]
    NOT?: PhoneWhereInput | PhoneWhereInput[]
    id?: StringFilter<"Phone"> | string
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type PhoneOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrderInput | SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type PhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhoneWhereInput | PhoneWhereInput[]
    OR?: PhoneWhereInput[]
    NOT?: PhoneWhereInput | PhoneWhereInput[]
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id">

  export type PhoneOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrderInput | SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhoneCountOrderByAggregateInput
    _max?: PhoneMaxOrderByAggregateInput
    _min?: PhoneMinOrderByAggregateInput
  }

  export type PhoneScalarWhereWithAggregatesInput = {
    AND?: PhoneScalarWhereWithAggregatesInput | PhoneScalarWhereWithAggregatesInput[]
    OR?: PhoneScalarWhereWithAggregatesInput[]
    NOT?: PhoneScalarWhereWithAggregatesInput | PhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Phone"> | string
    personId?: StringWithAggregatesFilter<"Phone"> | string
    number?: StringWithAggregatesFilter<"Phone"> | string
    extension?: StringNullableWithAggregatesFilter<"Phone"> | string | null
    type?: StringWithAggregatesFilter<"Phone"> | string
    preferred?: BoolWithAggregatesFilter<"Phone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Phone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phone"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    personId?: StringWithAggregatesFilter<"Address"> | string
    type?: StringWithAggregatesFilter<"Address"> | string
    line1?: StringWithAggregatesFilter<"Address"> | string
    line2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type DoNotEngageGlobalWhereInput = {
    AND?: DoNotEngageGlobalWhereInput | DoNotEngageGlobalWhereInput[]
    OR?: DoNotEngageGlobalWhereInput[]
    NOT?: DoNotEngageGlobalWhereInput | DoNotEngageGlobalWhereInput[]
    id?: StringFilter<"DoNotEngageGlobal"> | string
    personId?: StringFilter<"DoNotEngageGlobal"> | string
    emailBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    smsBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    phoneBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    source?: StringFilter<"DoNotEngageGlobal"> | string
    reason?: StringNullableFilter<"DoNotEngageGlobal"> | string | null
    createdAt?: DateTimeFilter<"DoNotEngageGlobal"> | Date | string
    updatedAt?: DateTimeFilter<"DoNotEngageGlobal"> | Date | string
    updatedById?: StringNullableFilter<"DoNotEngageGlobal"> | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type DoNotEngageGlobalOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    emailBlocked?: SortOrder
    smsBlocked?: SortOrder
    phoneBlocked?: SortOrder
    source?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type DoNotEngageGlobalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    AND?: DoNotEngageGlobalWhereInput | DoNotEngageGlobalWhereInput[]
    OR?: DoNotEngageGlobalWhereInput[]
    NOT?: DoNotEngageGlobalWhereInput | DoNotEngageGlobalWhereInput[]
    emailBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    smsBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    phoneBlocked?: BoolFilter<"DoNotEngageGlobal"> | boolean
    source?: StringFilter<"DoNotEngageGlobal"> | string
    reason?: StringNullableFilter<"DoNotEngageGlobal"> | string | null
    createdAt?: DateTimeFilter<"DoNotEngageGlobal"> | Date | string
    updatedAt?: DateTimeFilter<"DoNotEngageGlobal"> | Date | string
    updatedById?: StringNullableFilter<"DoNotEngageGlobal"> | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id" | "personId">

  export type DoNotEngageGlobalOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    emailBlocked?: SortOrder
    smsBlocked?: SortOrder
    phoneBlocked?: SortOrder
    source?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: DoNotEngageGlobalCountOrderByAggregateInput
    _max?: DoNotEngageGlobalMaxOrderByAggregateInput
    _min?: DoNotEngageGlobalMinOrderByAggregateInput
  }

  export type DoNotEngageGlobalScalarWhereWithAggregatesInput = {
    AND?: DoNotEngageGlobalScalarWhereWithAggregatesInput | DoNotEngageGlobalScalarWhereWithAggregatesInput[]
    OR?: DoNotEngageGlobalScalarWhereWithAggregatesInput[]
    NOT?: DoNotEngageGlobalScalarWhereWithAggregatesInput | DoNotEngageGlobalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoNotEngageGlobal"> | string
    personId?: StringWithAggregatesFilter<"DoNotEngageGlobal"> | string
    emailBlocked?: BoolWithAggregatesFilter<"DoNotEngageGlobal"> | boolean
    smsBlocked?: BoolWithAggregatesFilter<"DoNotEngageGlobal"> | boolean
    phoneBlocked?: BoolWithAggregatesFilter<"DoNotEngageGlobal"> | boolean
    source?: StringWithAggregatesFilter<"DoNotEngageGlobal"> | string
    reason?: StringNullableWithAggregatesFilter<"DoNotEngageGlobal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DoNotEngageGlobal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DoNotEngageGlobal"> | Date | string
    updatedById?: StringNullableWithAggregatesFilter<"DoNotEngageGlobal"> | string | null
  }

  export type DoNotEngageAgentWhereInput = {
    AND?: DoNotEngageAgentWhereInput | DoNotEngageAgentWhereInput[]
    OR?: DoNotEngageAgentWhereInput[]
    NOT?: DoNotEngageAgentWhereInput | DoNotEngageAgentWhereInput[]
    id?: StringFilter<"DoNotEngageAgent"> | string
    personId?: StringFilter<"DoNotEngageAgent"> | string
    agentId?: StringFilter<"DoNotEngageAgent"> | string
    createdAt?: DateTimeFilter<"DoNotEngageAgent"> | Date | string
    createdById?: StringNullableFilter<"DoNotEngageAgent"> | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type DoNotEngageAgentOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type DoNotEngageAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId_agentId?: DoNotEngageAgentPersonIdAgentIdCompoundUniqueInput
    AND?: DoNotEngageAgentWhereInput | DoNotEngageAgentWhereInput[]
    OR?: DoNotEngageAgentWhereInput[]
    NOT?: DoNotEngageAgentWhereInput | DoNotEngageAgentWhereInput[]
    personId?: StringFilter<"DoNotEngageAgent"> | string
    agentId?: StringFilter<"DoNotEngageAgent"> | string
    createdAt?: DateTimeFilter<"DoNotEngageAgent"> | Date | string
    createdById?: StringNullableFilter<"DoNotEngageAgent"> | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }, "id" | "personId_agentId">

  export type DoNotEngageAgentOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: DoNotEngageAgentCountOrderByAggregateInput
    _max?: DoNotEngageAgentMaxOrderByAggregateInput
    _min?: DoNotEngageAgentMinOrderByAggregateInput
  }

  export type DoNotEngageAgentScalarWhereWithAggregatesInput = {
    AND?: DoNotEngageAgentScalarWhereWithAggregatesInput | DoNotEngageAgentScalarWhereWithAggregatesInput[]
    OR?: DoNotEngageAgentScalarWhereWithAggregatesInput[]
    NOT?: DoNotEngageAgentScalarWhereWithAggregatesInput | DoNotEngageAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoNotEngageAgent"> | string
    personId?: StringWithAggregatesFilter<"DoNotEngageAgent"> | string
    agentId?: StringWithAggregatesFilter<"DoNotEngageAgent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DoNotEngageAgent"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"DoNotEngageAgent"> | string | null
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    personId?: StringFilter<"Student"> | string
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    studentNumber?: StringFilter<"Student"> | string
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    entryAcademicPeriod?: XOR<AcademicPeriodNullableRelationFilter, AcademicPeriodWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    studentAcademicPrograms?: StudentAcademicProgramListRelationFilter
    academicCredentials?: AcademicCredentialListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrderInput | SortOrder
    academicLevel?: SortOrderInput | SortOrder
    residency?: SortOrderInput | SortOrder
    studentClassification?: SortOrderInput | SortOrder
    studentLoad?: SortOrderInput | SortOrder
    academicStandingCode?: SortOrderInput | SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    entryAcademicPeriod?: AcademicPeriodOrderByWithRelationInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    studentAcademicPrograms?: StudentAcademicProgramOrderByRelationAggregateInput
    academicCredentials?: AcademicCredentialOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
    studentRisks?: StudentRiskOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    studentNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    entryAcademicPeriod?: XOR<AcademicPeriodNullableRelationFilter, AcademicPeriodWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    studentAcademicPrograms?: StudentAcademicProgramListRelationFilter
    academicCredentials?: AcademicCredentialListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }, "id" | "personId" | "studentNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrderInput | SortOrder
    academicLevel?: SortOrderInput | SortOrder
    residency?: SortOrderInput | SortOrder
    studentClassification?: SortOrderInput | SortOrder
    studentLoad?: SortOrderInput | SortOrder
    academicStandingCode?: SortOrderInput | SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    personId?: StringWithAggregatesFilter<"Student"> | string
    type?: StringWithAggregatesFilter<"Student"> | string
    status?: StringWithAggregatesFilter<"Student"> | string
    startOn?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicLevel?: StringNullableWithAggregatesFilter<"Student"> | string | null
    residency?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentClassification?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentLoad?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicStandingCode?: StringNullableWithAggregatesFilter<"Student"> | string | null
    studentNumber?: StringWithAggregatesFilter<"Student"> | string
    isFirstGen?: BoolWithAggregatesFilter<"Student"> | boolean
    isPellEligible?: BoolWithAggregatesFilter<"Student"> | boolean
    isInState?: BoolWithAggregatesFilter<"Student"> | boolean
    workHoursPerWeek?: IntWithAggregatesFilter<"Student"> | number
    commuteMinutes?: IntWithAggregatesFilter<"Student"> | number
    hasHousingInstability?: BoolWithAggregatesFilter<"Student"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type AcademicPeriodWhereInput = {
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    id?: StringFilter<"AcademicPeriod"> | string
    code?: StringFilter<"AcademicPeriod"> | string
    title?: StringFilter<"AcademicPeriod"> | string
    type?: StringFilter<"AcademicPeriod"> | string
    startOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringFilter<"AcademicPeriod"> | string
    status?: StringFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    sections?: SectionListRelationFilter
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    entryStudents?: StudentListRelationFilter
    credentialPeriods?: AcademicCredentialListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }

  export type AcademicPeriodOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrderInput | SortOrder
    registrationStartOn?: SortOrderInput | SortOrder
    registrationEndOn?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: SectionOrderByRelationAggregateInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
    entryStudents?: StudentOrderByRelationAggregateInput
    credentialPeriods?: AcademicCredentialOrderByRelationAggregateInput
    studentRisks?: StudentRiskOrderByRelationAggregateInput
  }

  export type AcademicPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    OR?: AcademicPeriodWhereInput[]
    NOT?: AcademicPeriodWhereInput | AcademicPeriodWhereInput[]
    title?: StringFilter<"AcademicPeriod"> | string
    type?: StringFilter<"AcademicPeriod"> | string
    startOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringFilter<"AcademicPeriod"> | string
    status?: StringFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicPeriod"> | Date | string
    sections?: SectionListRelationFilter
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
    entryStudents?: StudentListRelationFilter
    credentialPeriods?: AcademicCredentialListRelationFilter
    studentRisks?: StudentRiskListRelationFilter
  }, "id" | "code">

  export type AcademicPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrderInput | SortOrder
    registrationStartOn?: SortOrderInput | SortOrder
    registrationEndOn?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicPeriodCountOrderByAggregateInput
    _max?: AcademicPeriodMaxOrderByAggregateInput
    _min?: AcademicPeriodMinOrderByAggregateInput
  }

  export type AcademicPeriodScalarWhereWithAggregatesInput = {
    AND?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    OR?: AcademicPeriodScalarWhereWithAggregatesInput[]
    NOT?: AcademicPeriodScalarWhereWithAggregatesInput | AcademicPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    code?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    title?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    type?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    startOn?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    endOn?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    censusOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    registrationStartOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    registrationEndOn?: DateTimeNullableWithAggregatesFilter<"AcademicPeriod"> | Date | string | null
    academicYear?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    status?: StringWithAggregatesFilter<"AcademicPeriod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicPeriod"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    subjectCode?: StringFilter<"Course"> | string
    number?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    creditType?: StringFilter<"Course"> | string
    creditsMinimum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFilter<"Course"> | string
    status?: StringFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    sections?: SectionListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrderInput | SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrderInput | SortOrder
    effectiveEndDate?: SortOrderInput | SortOrder
    catalogYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: SectionOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subjectCode_number_catalogYear?: CourseSubjectCodeNumberCatalogYearCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    subjectCode?: StringFilter<"Course"> | string
    number?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    creditType?: StringFilter<"Course"> | string
    creditsMinimum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFilter<"Course"> | string
    status?: StringFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    sections?: SectionListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }, "id" | "subjectCode_number_catalogYear">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrderInput | SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrderInput | SortOrder
    effectiveEndDate?: SortOrderInput | SortOrder
    catalogYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    subjectCode?: StringWithAggregatesFilter<"Course"> | string
    number?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    creditType?: StringWithAggregatesFilter<"Course"> | string
    creditsMinimum?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    creditsIncrement?: DecimalNullableWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringWithAggregatesFilter<"Course"> | string
    status?: StringWithAggregatesFilter<"Course"> | string
    effectiveStartDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    effectiveEndDate?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    catalogYear?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    instructor?: XOR<PersonNullableRelationFilter, PersonWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrderInput | SortOrder
    waitlistEnrolled?: SortOrderInput | SortOrder
    instructionalMethodCode?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    instructor?: PersonOrderByWithRelationInput
    sectionRegistrations?: SectionRegistrationOrderByRelationAggregateInput
    transcriptGrades?: StudentTranscriptGradeOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    academicPeriodId_crn?: SectionAcademicPeriodIdCrnCompoundUniqueInput
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    instructor?: XOR<PersonNullableRelationFilter, PersonWhereInput> | null
    sectionRegistrations?: SectionRegistrationListRelationFilter
    transcriptGrades?: StudentTranscriptGradeListRelationFilter
  }, "id" | "academicPeriodId_crn">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrderInput | SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrderInput | SortOrder
    waitlistEnrolled?: SortOrderInput | SortOrder
    instructionalMethodCode?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    roomNumber?: SortOrderInput | SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    courseId?: StringWithAggregatesFilter<"Section"> | string
    academicPeriodId?: StringWithAggregatesFilter<"Section"> | string
    number?: StringWithAggregatesFilter<"Section"> | string
    title?: StringNullableWithAggregatesFilter<"Section"> | string | null
    crn?: StringWithAggregatesFilter<"Section"> | string
    startOn?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    endOn?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    status?: StringWithAggregatesFilter<"Section"> | string
    capacity?: IntWithAggregatesFilter<"Section"> | number
    enrolled?: IntWithAggregatesFilter<"Section"> | number
    available?: IntWithAggregatesFilter<"Section"> | number
    waitlistCapacity?: IntNullableWithAggregatesFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableWithAggregatesFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableWithAggregatesFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableWithAggregatesFilter<"Section"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"Section"> | string | null
    building?: StringNullableWithAggregatesFilter<"Section"> | string | null
    roomNumber?: StringNullableWithAggregatesFilter<"Section"> | string | null
    creditType?: StringWithAggregatesFilter<"Section"> | string
    creditsMinimum?: DecimalWithAggregatesFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalWithAggregatesFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableWithAggregatesFilter<"Section"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type SectionRegistrationWhereInput = {
    AND?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    OR?: SectionRegistrationWhereInput[]
    NOT?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    id?: StringFilter<"SectionRegistration"> | string
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    transcriptGrade?: XOR<StudentTranscriptGradeNullableRelationFilter, StudentTranscriptGradeWhereInput> | null
  }

  export type SectionRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrderInput | SortOrder
    academicLoad?: SortOrderInput | SortOrder
    residencyStatus?: SortOrderInput | SortOrder
    attendanceRate?: SortOrderInput | SortOrder
    midtermGrade?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    transcriptGrade?: StudentTranscriptGradeOrderByWithRelationInput
  }

  export type SectionRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_sectionId?: SectionRegistrationStudentIdSectionIdCompoundUniqueInput
    AND?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    OR?: SectionRegistrationWhereInput[]
    NOT?: SectionRegistrationWhereInput | SectionRegistrationWhereInput[]
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    transcriptGrade?: XOR<StudentTranscriptGradeNullableRelationFilter, StudentTranscriptGradeWhereInput> | null
  }, "id" | "studentId_sectionId">

  export type SectionRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrderInput | SortOrder
    academicLoad?: SortOrderInput | SortOrder
    residencyStatus?: SortOrderInput | SortOrder
    attendanceRate?: SortOrderInput | SortOrder
    midtermGrade?: SortOrderInput | SortOrder
    finalGrade?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionRegistrationCountOrderByAggregateInput
    _avg?: SectionRegistrationAvgOrderByAggregateInput
    _max?: SectionRegistrationMaxOrderByAggregateInput
    _min?: SectionRegistrationMinOrderByAggregateInput
    _sum?: SectionRegistrationSumOrderByAggregateInput
  }

  export type SectionRegistrationScalarWhereWithAggregatesInput = {
    AND?: SectionRegistrationScalarWhereWithAggregatesInput | SectionRegistrationScalarWhereWithAggregatesInput[]
    OR?: SectionRegistrationScalarWhereWithAggregatesInput[]
    NOT?: SectionRegistrationScalarWhereWithAggregatesInput | SectionRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectionRegistration"> | string
    studentId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    sectionId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    academicPeriodId?: StringWithAggregatesFilter<"SectionRegistration"> | string
    statusCode?: StringWithAggregatesFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    creditType?: StringWithAggregatesFilter<"SectionRegistration"> | string
    credits?: DecimalWithAggregatesFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableWithAggregatesFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableWithAggregatesFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SectionRegistration"> | Date | string
  }

  export type StudentTranscriptGradeWhereInput = {
    AND?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    OR?: StudentTranscriptGradeWhereInput[]
    NOT?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    id?: StringFilter<"StudentTranscriptGrade"> | string
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    sectionRegistration?: XOR<SectionRegistrationRelationFilter, SectionRegistrationWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type StudentTranscriptGradeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrderInput | SortOrder
    gradeValue?: SortOrderInput | SortOrder
    gradePoints?: SortOrderInput | SortOrder
    qualityPoints?: SortOrderInput | SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrderInput | SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    sectionRegistration?: SectionRegistrationOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type StudentTranscriptGradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionRegistrationId?: string
    AND?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    OR?: StudentTranscriptGradeWhereInput[]
    NOT?: StudentTranscriptGradeWhereInput | StudentTranscriptGradeWhereInput[]
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    sectionRegistration?: XOR<SectionRegistrationRelationFilter, SectionRegistrationWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "sectionRegistrationId">

  export type StudentTranscriptGradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrderInput | SortOrder
    gradeValue?: SortOrderInput | SortOrder
    gradePoints?: SortOrderInput | SortOrder
    qualityPoints?: SortOrderInput | SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrderInput | SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentTranscriptGradeCountOrderByAggregateInput
    _avg?: StudentTranscriptGradeAvgOrderByAggregateInput
    _max?: StudentTranscriptGradeMaxOrderByAggregateInput
    _min?: StudentTranscriptGradeMinOrderByAggregateInput
    _sum?: StudentTranscriptGradeSumOrderByAggregateInput
  }

  export type StudentTranscriptGradeScalarWhereWithAggregatesInput = {
    AND?: StudentTranscriptGradeScalarWhereWithAggregatesInput | StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    OR?: StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    NOT?: StudentTranscriptGradeScalarWhereWithAggregatesInput | StudentTranscriptGradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    studentId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    courseId?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableWithAggregatesFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableWithAggregatesFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalWithAggregatesFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolWithAggregatesFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolWithAggregatesFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentTranscriptGrade"> | Date | string
  }

  export type AcademicProgramWhereInput = {
    AND?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    OR?: AcademicProgramWhereInput[]
    NOT?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    id?: StringFilter<"AcademicProgram"> | string
    code?: StringFilter<"AcademicProgram"> | string
    title?: StringFilter<"AcademicProgram"> | string
    type?: StringFilter<"AcademicProgram"> | string
    level?: StringFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableFilter<"AcademicProgram"> | string | null
    status?: StringFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntFilter<"AcademicProgram"> | number
    description?: StringNullableFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    studentPrograms?: StudentAcademicProgramListRelationFilter
    credentials?: AcademicCredentialListRelationFilter
  }

  export type AcademicProgramOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrderInput | SortOrder
    status?: SortOrder
    startOn?: SortOrderInput | SortOrder
    endOn?: SortOrderInput | SortOrder
    accreditationCode?: SortOrderInput | SortOrder
    creditsRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentPrograms?: StudentAcademicProgramOrderByRelationAggregateInput
    credentials?: AcademicCredentialOrderByRelationAggregateInput
  }

  export type AcademicProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    OR?: AcademicProgramWhereInput[]
    NOT?: AcademicProgramWhereInput | AcademicProgramWhereInput[]
    title?: StringFilter<"AcademicProgram"> | string
    type?: StringFilter<"AcademicProgram"> | string
    level?: StringFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableFilter<"AcademicProgram"> | string | null
    status?: StringFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntFilter<"AcademicProgram"> | number
    description?: StringNullableFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicProgram"> | Date | string
    studentPrograms?: StudentAcademicProgramListRelationFilter
    credentials?: AcademicCredentialListRelationFilter
  }, "id" | "code">

  export type AcademicProgramOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrderInput | SortOrder
    status?: SortOrder
    startOn?: SortOrderInput | SortOrder
    endOn?: SortOrderInput | SortOrder
    accreditationCode?: SortOrderInput | SortOrder
    creditsRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicProgramCountOrderByAggregateInput
    _avg?: AcademicProgramAvgOrderByAggregateInput
    _max?: AcademicProgramMaxOrderByAggregateInput
    _min?: AcademicProgramMinOrderByAggregateInput
    _sum?: AcademicProgramSumOrderByAggregateInput
  }

  export type AcademicProgramScalarWhereWithAggregatesInput = {
    AND?: AcademicProgramScalarWhereWithAggregatesInput | AcademicProgramScalarWhereWithAggregatesInput[]
    OR?: AcademicProgramScalarWhereWithAggregatesInput[]
    NOT?: AcademicProgramScalarWhereWithAggregatesInput | AcademicProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicProgram"> | string
    code?: StringWithAggregatesFilter<"AcademicProgram"> | string
    title?: StringWithAggregatesFilter<"AcademicProgram"> | string
    type?: StringWithAggregatesFilter<"AcademicProgram"> | string
    level?: StringWithAggregatesFilter<"AcademicProgram"> | string
    degreeCode?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    status?: StringWithAggregatesFilter<"AcademicProgram"> | string
    startOn?: DateTimeNullableWithAggregatesFilter<"AcademicProgram"> | Date | string | null
    endOn?: DateTimeNullableWithAggregatesFilter<"AcademicProgram"> | Date | string | null
    accreditationCode?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    creditsRequired?: IntWithAggregatesFilter<"AcademicProgram"> | number
    description?: StringNullableWithAggregatesFilter<"AcademicProgram"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicProgram"> | Date | string
  }

  export type StudentAcademicProgramWhereInput = {
    AND?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    OR?: StudentAcademicProgramWhereInput[]
    NOT?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    id?: StringFilter<"StudentAcademicProgram"> | string
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramRelationFilter, AcademicProgramWhereInput>
  }

  export type StudentAcademicProgramOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrderInput | SortOrder
    status?: SortOrder
    catalogYear?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicProgram?: AcademicProgramOrderByWithRelationInput
  }

  export type StudentAcademicProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    OR?: StudentAcademicProgramWhereInput[]
    NOT?: StudentAcademicProgramWhereInput | StudentAcademicProgramWhereInput[]
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramRelationFilter, AcademicProgramWhereInput>
  }, "id">

  export type StudentAcademicProgramOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrderInput | SortOrder
    status?: SortOrder
    catalogYear?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAcademicProgramCountOrderByAggregateInput
    _max?: StudentAcademicProgramMaxOrderByAggregateInput
    _min?: StudentAcademicProgramMinOrderByAggregateInput
  }

  export type StudentAcademicProgramScalarWhereWithAggregatesInput = {
    AND?: StudentAcademicProgramScalarWhereWithAggregatesInput | StudentAcademicProgramScalarWhereWithAggregatesInput[]
    OR?: StudentAcademicProgramScalarWhereWithAggregatesInput[]
    NOT?: StudentAcademicProgramScalarWhereWithAggregatesInput | StudentAcademicProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    studentId?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableWithAggregatesFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableWithAggregatesFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolWithAggregatesFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAcademicProgram"> | Date | string
  }

  export type AcademicCredentialWhereInput = {
    AND?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    OR?: AcademicCredentialWhereInput[]
    NOT?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    id?: StringFilter<"AcademicCredential"> | string
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramNullableRelationFilter, AcademicProgramWhereInput> | null
    academicPeriod?: XOR<AcademicPeriodNullableRelationFilter, AcademicPeriodWhereInput> | null
  }

  export type AcademicCredentialOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrderInput | SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicProgram?: AcademicProgramOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
  }

  export type AcademicCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    OR?: AcademicCredentialWhereInput[]
    NOT?: AcademicCredentialWhereInput | AcademicCredentialWhereInput[]
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicProgram?: XOR<AcademicProgramNullableRelationFilter, AcademicProgramWhereInput> | null
    academicPeriod?: XOR<AcademicPeriodNullableRelationFilter, AcademicPeriodWhereInput> | null
  }, "id">

  export type AcademicCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrderInput | SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicCredentialCountOrderByAggregateInput
    _max?: AcademicCredentialMaxOrderByAggregateInput
    _min?: AcademicCredentialMinOrderByAggregateInput
  }

  export type AcademicCredentialScalarWhereWithAggregatesInput = {
    AND?: AcademicCredentialScalarWhereWithAggregatesInput | AcademicCredentialScalarWhereWithAggregatesInput[]
    OR?: AcademicCredentialScalarWhereWithAggregatesInput[]
    NOT?: AcademicCredentialScalarWhereWithAggregatesInput | AcademicCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicCredential"> | string
    studentId?: StringWithAggregatesFilter<"AcademicCredential"> | string
    credentialCode?: StringWithAggregatesFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableWithAggregatesFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
    status?: StringWithAggregatesFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableWithAggregatesFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicCredential"> | Date | string
  }

  export type StudentRiskWhereInput = {
    AND?: StudentRiskWhereInput | StudentRiskWhereInput[]
    OR?: StudentRiskWhereInput[]
    NOT?: StudentRiskWhereInput | StudentRiskWhereInput[]
    id?: StringFilter<"StudentRisk"> | string
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
  }

  export type StudentRiskOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicPeriod?: AcademicPeriodOrderByWithRelationInput
  }

  export type StudentRiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_academicPeriodId?: StudentRiskStudentIdAcademicPeriodIdCompoundUniqueInput
    AND?: StudentRiskWhereInput | StudentRiskWhereInput[]
    OR?: StudentRiskWhereInput[]
    NOT?: StudentRiskWhereInput | StudentRiskWhereInput[]
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicPeriod?: XOR<AcademicPeriodRelationFilter, AcademicPeriodWhereInput>
  }, "id" | "studentId_academicPeriodId">

  export type StudentRiskOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: StudentRiskCountOrderByAggregateInput
    _avg?: StudentRiskAvgOrderByAggregateInput
    _max?: StudentRiskMaxOrderByAggregateInput
    _min?: StudentRiskMinOrderByAggregateInput
    _sum?: StudentRiskSumOrderByAggregateInput
  }

  export type StudentRiskScalarWhereWithAggregatesInput = {
    AND?: StudentRiskScalarWhereWithAggregatesInput | StudentRiskScalarWhereWithAggregatesInput[]
    OR?: StudentRiskScalarWhereWithAggregatesInput[]
    NOT?: StudentRiskScalarWhereWithAggregatesInput | StudentRiskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentRisk"> | string
    studentId?: StringWithAggregatesFilter<"StudentRisk"> | string
    academicPeriodId?: StringWithAggregatesFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatWithAggregatesFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatWithAggregatesFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketWithAggregatesFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeWithAggregatesFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentRisk"> | Date | string
  }

  export type SimulationStateWhereInput = {
    AND?: SimulationStateWhereInput | SimulationStateWhereInput[]
    OR?: SimulationStateWhereInput[]
    NOT?: SimulationStateWhereInput | SimulationStateWhereInput[]
    id?: StringFilter<"SimulationState"> | string
    currentSimDate?: DateTimeFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationState"> | Date | string
  }

  export type SimulationStateOrderByWithRelationInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationStateWhereInput | SimulationStateWhereInput[]
    OR?: SimulationStateWhereInput[]
    NOT?: SimulationStateWhereInput | SimulationStateWhereInput[]
    currentSimDate?: DateTimeFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationState"> | Date | string
  }, "id">

  export type SimulationStateOrderByWithAggregationInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SimulationStateCountOrderByAggregateInput
    _max?: SimulationStateMaxOrderByAggregateInput
    _min?: SimulationStateMinOrderByAggregateInput
  }

  export type SimulationStateScalarWhereWithAggregatesInput = {
    AND?: SimulationStateScalarWhereWithAggregatesInput | SimulationStateScalarWhereWithAggregatesInput[]
    OR?: SimulationStateScalarWhereWithAggregatesInput[]
    NOT?: SimulationStateScalarWhereWithAggregatesInput | SimulationStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationState"> | string
    currentSimDate?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
    lastTickDate?: DateTimeNullableWithAggregatesFilter<"SimulationState"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SimulationState"> | Date | string
  }

  export type CrmContactWhereInput = {
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    id?: StringFilter<"CrmContact"> | string
    workspace?: StringFilter<"CrmContact"> | string
    app?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    type?: StringFilter<"CrmContact"> | string
    email?: StringNullableFilter<"CrmContact"> | string | null
    phone?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    opportunities?: CrmOpportunityListRelationFilter
    activities?: CrmActivityListRelationFilter
  }

  export type CrmContactOrderByWithRelationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunities?: CrmOpportunityOrderByRelationAggregateInput
    activities?: CrmActivityOrderByRelationAggregateInput
  }

  export type CrmContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmContactWhereInput | CrmContactWhereInput[]
    OR?: CrmContactWhereInput[]
    NOT?: CrmContactWhereInput | CrmContactWhereInput[]
    workspace?: StringFilter<"CrmContact"> | string
    app?: StringFilter<"CrmContact"> | string
    name?: StringFilter<"CrmContact"> | string
    type?: StringFilter<"CrmContact"> | string
    email?: StringNullableFilter<"CrmContact"> | string | null
    phone?: StringNullableFilter<"CrmContact"> | string | null
    createdAt?: DateTimeFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeFilter<"CrmContact"> | Date | string
    opportunities?: CrmOpportunityListRelationFilter
    activities?: CrmActivityListRelationFilter
  }, "id">

  export type CrmContactOrderByWithAggregationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrmContactCountOrderByAggregateInput
    _max?: CrmContactMaxOrderByAggregateInput
    _min?: CrmContactMinOrderByAggregateInput
  }

  export type CrmContactScalarWhereWithAggregatesInput = {
    AND?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    OR?: CrmContactScalarWhereWithAggregatesInput[]
    NOT?: CrmContactScalarWhereWithAggregatesInput | CrmContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmContact"> | string
    workspace?: StringWithAggregatesFilter<"CrmContact"> | string
    app?: StringWithAggregatesFilter<"CrmContact"> | string
    name?: StringWithAggregatesFilter<"CrmContact"> | string
    type?: StringWithAggregatesFilter<"CrmContact"> | string
    email?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CrmContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrmContact"> | Date | string
  }

  export type CrmAccountWhereInput = {
    AND?: CrmAccountWhereInput | CrmAccountWhereInput[]
    OR?: CrmAccountWhereInput[]
    NOT?: CrmAccountWhereInput | CrmAccountWhereInput[]
    id?: StringFilter<"CrmAccount"> | string
    workspace?: StringFilter<"CrmAccount"> | string
    app?: StringFilter<"CrmAccount"> | string
    name?: StringFilter<"CrmAccount"> | string
    type?: StringFilter<"CrmAccount"> | string
    createdAt?: DateTimeFilter<"CrmAccount"> | Date | string
    updatedAt?: DateTimeFilter<"CrmAccount"> | Date | string
    opportunities?: CrmOpportunityListRelationFilter
    activities?: CrmActivityListRelationFilter
  }

  export type CrmAccountOrderByWithRelationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunities?: CrmOpportunityOrderByRelationAggregateInput
    activities?: CrmActivityOrderByRelationAggregateInput
  }

  export type CrmAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmAccountWhereInput | CrmAccountWhereInput[]
    OR?: CrmAccountWhereInput[]
    NOT?: CrmAccountWhereInput | CrmAccountWhereInput[]
    workspace?: StringFilter<"CrmAccount"> | string
    app?: StringFilter<"CrmAccount"> | string
    name?: StringFilter<"CrmAccount"> | string
    type?: StringFilter<"CrmAccount"> | string
    createdAt?: DateTimeFilter<"CrmAccount"> | Date | string
    updatedAt?: DateTimeFilter<"CrmAccount"> | Date | string
    opportunities?: CrmOpportunityListRelationFilter
    activities?: CrmActivityListRelationFilter
  }, "id">

  export type CrmAccountOrderByWithAggregationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrmAccountCountOrderByAggregateInput
    _max?: CrmAccountMaxOrderByAggregateInput
    _min?: CrmAccountMinOrderByAggregateInput
  }

  export type CrmAccountScalarWhereWithAggregatesInput = {
    AND?: CrmAccountScalarWhereWithAggregatesInput | CrmAccountScalarWhereWithAggregatesInput[]
    OR?: CrmAccountScalarWhereWithAggregatesInput[]
    NOT?: CrmAccountScalarWhereWithAggregatesInput | CrmAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmAccount"> | string
    workspace?: StringWithAggregatesFilter<"CrmAccount"> | string
    app?: StringWithAggregatesFilter<"CrmAccount"> | string
    name?: StringWithAggregatesFilter<"CrmAccount"> | string
    type?: StringWithAggregatesFilter<"CrmAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CrmAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrmAccount"> | Date | string
  }

  export type CrmOpportunityWhereInput = {
    AND?: CrmOpportunityWhereInput | CrmOpportunityWhereInput[]
    OR?: CrmOpportunityWhereInput[]
    NOT?: CrmOpportunityWhereInput | CrmOpportunityWhereInput[]
    id?: StringFilter<"CrmOpportunity"> | string
    workspace?: StringFilter<"CrmOpportunity"> | string
    app?: StringFilter<"CrmOpportunity"> | string
    name?: StringFilter<"CrmOpportunity"> | string
    stage?: StringFilter<"CrmOpportunity"> | string
    status?: StringFilter<"CrmOpportunity"> | string
    contactId?: StringNullableFilter<"CrmOpportunity"> | string | null
    accountId?: StringNullableFilter<"CrmOpportunity"> | string | null
    amount?: DecimalNullableFilter<"CrmOpportunity"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
    contact?: XOR<CrmContactNullableRelationFilter, CrmContactWhereInput> | null
    account?: XOR<CrmAccountNullableRelationFilter, CrmAccountWhereInput> | null
    activities?: CrmActivityListRelationFilter
  }

  export type CrmOpportunityOrderByWithRelationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    contactId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: CrmContactOrderByWithRelationInput
    account?: CrmAccountOrderByWithRelationInput
    activities?: CrmActivityOrderByRelationAggregateInput
  }

  export type CrmOpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmOpportunityWhereInput | CrmOpportunityWhereInput[]
    OR?: CrmOpportunityWhereInput[]
    NOT?: CrmOpportunityWhereInput | CrmOpportunityWhereInput[]
    workspace?: StringFilter<"CrmOpportunity"> | string
    app?: StringFilter<"CrmOpportunity"> | string
    name?: StringFilter<"CrmOpportunity"> | string
    stage?: StringFilter<"CrmOpportunity"> | string
    status?: StringFilter<"CrmOpportunity"> | string
    contactId?: StringNullableFilter<"CrmOpportunity"> | string | null
    accountId?: StringNullableFilter<"CrmOpportunity"> | string | null
    amount?: DecimalNullableFilter<"CrmOpportunity"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
    contact?: XOR<CrmContactNullableRelationFilter, CrmContactWhereInput> | null
    account?: XOR<CrmAccountNullableRelationFilter, CrmAccountWhereInput> | null
    activities?: CrmActivityListRelationFilter
  }, "id">

  export type CrmOpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    contactId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrmOpportunityCountOrderByAggregateInput
    _avg?: CrmOpportunityAvgOrderByAggregateInput
    _max?: CrmOpportunityMaxOrderByAggregateInput
    _min?: CrmOpportunityMinOrderByAggregateInput
    _sum?: CrmOpportunitySumOrderByAggregateInput
  }

  export type CrmOpportunityScalarWhereWithAggregatesInput = {
    AND?: CrmOpportunityScalarWhereWithAggregatesInput | CrmOpportunityScalarWhereWithAggregatesInput[]
    OR?: CrmOpportunityScalarWhereWithAggregatesInput[]
    NOT?: CrmOpportunityScalarWhereWithAggregatesInput | CrmOpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    workspace?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    app?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    name?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    stage?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    status?: StringWithAggregatesFilter<"CrmOpportunity"> | string
    contactId?: StringNullableWithAggregatesFilter<"CrmOpportunity"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"CrmOpportunity"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"CrmOpportunity"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrmOpportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrmOpportunity"> | Date | string
  }

  export type CrmActivityWhereInput = {
    AND?: CrmActivityWhereInput | CrmActivityWhereInput[]
    OR?: CrmActivityWhereInput[]
    NOT?: CrmActivityWhereInput | CrmActivityWhereInput[]
    id?: StringFilter<"CrmActivity"> | string
    workspace?: StringFilter<"CrmActivity"> | string
    app?: StringFilter<"CrmActivity"> | string
    type?: StringFilter<"CrmActivity"> | string
    subject?: StringFilter<"CrmActivity"> | string
    contactId?: StringNullableFilter<"CrmActivity"> | string | null
    accountId?: StringNullableFilter<"CrmActivity"> | string | null
    opportunityId?: StringNullableFilter<"CrmActivity"> | string | null
    createdAt?: DateTimeFilter<"CrmActivity"> | Date | string
    contact?: XOR<CrmContactNullableRelationFilter, CrmContactWhereInput> | null
    account?: XOR<CrmAccountNullableRelationFilter, CrmAccountWhereInput> | null
    opportunity?: XOR<CrmOpportunityNullableRelationFilter, CrmOpportunityWhereInput> | null
  }

  export type CrmActivityOrderByWithRelationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    contactId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contact?: CrmContactOrderByWithRelationInput
    account?: CrmAccountOrderByWithRelationInput
    opportunity?: CrmOpportunityOrderByWithRelationInput
  }

  export type CrmActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrmActivityWhereInput | CrmActivityWhereInput[]
    OR?: CrmActivityWhereInput[]
    NOT?: CrmActivityWhereInput | CrmActivityWhereInput[]
    workspace?: StringFilter<"CrmActivity"> | string
    app?: StringFilter<"CrmActivity"> | string
    type?: StringFilter<"CrmActivity"> | string
    subject?: StringFilter<"CrmActivity"> | string
    contactId?: StringNullableFilter<"CrmActivity"> | string | null
    accountId?: StringNullableFilter<"CrmActivity"> | string | null
    opportunityId?: StringNullableFilter<"CrmActivity"> | string | null
    createdAt?: DateTimeFilter<"CrmActivity"> | Date | string
    contact?: XOR<CrmContactNullableRelationFilter, CrmContactWhereInput> | null
    account?: XOR<CrmAccountNullableRelationFilter, CrmAccountWhereInput> | null
    opportunity?: XOR<CrmOpportunityNullableRelationFilter, CrmOpportunityWhereInput> | null
  }, "id">

  export type CrmActivityOrderByWithAggregationInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    contactId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CrmActivityCountOrderByAggregateInput
    _max?: CrmActivityMaxOrderByAggregateInput
    _min?: CrmActivityMinOrderByAggregateInput
  }

  export type CrmActivityScalarWhereWithAggregatesInput = {
    AND?: CrmActivityScalarWhereWithAggregatesInput | CrmActivityScalarWhereWithAggregatesInput[]
    OR?: CrmActivityScalarWhereWithAggregatesInput[]
    NOT?: CrmActivityScalarWhereWithAggregatesInput | CrmActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrmActivity"> | string
    workspace?: StringWithAggregatesFilter<"CrmActivity"> | string
    app?: StringWithAggregatesFilter<"CrmActivity"> | string
    type?: StringWithAggregatesFilter<"CrmActivity"> | string
    subject?: StringWithAggregatesFilter<"CrmActivity"> | string
    contactId?: StringNullableWithAggregatesFilter<"CrmActivity"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"CrmActivity"> | string | null
    opportunityId?: StringNullableWithAggregatesFilter<"CrmActivity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CrmActivity"> | Date | string
  }

  export type PersonCreateInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameCreateInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutNamesInput
  }

  export type PersonNameUncheckedCreateInput = {
    id?: string
    personId: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutNamesNestedInput
  }

  export type PersonNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameCreateManyInput = {
    id?: string
    personId: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressCreateInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutEmailsInput
  }

  export type EmailAddressUncheckedCreateInput = {
    id?: string
    personId: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressCreateManyInput = {
    id?: string
    personId: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCreateInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateInput = {
    id?: string
    personId: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type PhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCreateManyInput = {
    id?: string
    personId: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    personId: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    personId: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoNotEngageGlobalCreateInput = {
    id?: string
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source: string
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    person: PersonCreateNestedOneWithoutDoNotEngageGlobalInput
  }

  export type DoNotEngageGlobalUncheckedCreateInput = {
    id?: string
    personId: string
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source: string
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type DoNotEngageGlobalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    person?: PersonUpdateOneRequiredWithoutDoNotEngageGlobalNestedInput
  }

  export type DoNotEngageGlobalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageGlobalCreateManyInput = {
    id?: string
    personId: string
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source: string
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type DoNotEngageGlobalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageGlobalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentCreateInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
    person: PersonCreateNestedOneWithoutDoNotEngageAgentsInput
  }

  export type DoNotEngageAgentUncheckedCreateInput = {
    id?: string
    personId: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
  }

  export type DoNotEngageAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    person?: PersonUpdateOneRequiredWithoutDoNotEngageAgentsNestedInput
  }

  export type DoNotEngageAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentCreateManyInput = {
    id?: string
    personId: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
  }

  export type DoNotEngageAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodCreateManyInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutCourseInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutCourseInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutCourseNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutCourseNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationCreateInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationCreateManyInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeCreateInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeCreateManyInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicProgramCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput
    credentials?: AcademicCredentialCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput
    credentials?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput
    credentials?: AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput
    credentials?: AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramCreateManyInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAcademicProgramsInput
    academicProgram: AcademicProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateInput = {
    id?: string
    studentId: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput
    academicProgram?: AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateManyInput = {
    id?: string
    studentId: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialCreateInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialCreateManyInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskCreateInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentRisksInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentRisksNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskCreateManyInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateCreateInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUncheckedCreateInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateCreateManyInput = {
    id?: string
    currentSimDate: Date | string
    lastTickDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentSimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTickDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityCreateNestedManyWithoutContactInput
    activities?: CrmActivityCreateNestedManyWithoutContactInput
  }

  export type CrmContactUncheckedCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityUncheckedCreateNestedManyWithoutContactInput
    activities?: CrmActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type CrmContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUpdateManyWithoutContactNestedInput
    activities?: CrmActivityUpdateManyWithoutContactNestedInput
  }

  export type CrmContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUncheckedUpdateManyWithoutContactNestedInput
    activities?: CrmActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CrmContactCreateManyInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmAccountCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityCreateNestedManyWithoutAccountInput
    activities?: CrmActivityCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountUncheckedCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityUncheckedCreateNestedManyWithoutAccountInput
    activities?: CrmActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUpdateManyWithoutAccountNestedInput
    activities?: CrmActivityUpdateManyWithoutAccountNestedInput
  }

  export type CrmAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUncheckedUpdateManyWithoutAccountNestedInput
    activities?: CrmActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CrmAccountCreateManyInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmOpportunityCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutOpportunitiesInput
    account?: CrmAccountCreateNestedOneWithoutOpportunitiesInput
    activities?: CrmActivityCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityUncheckedCreateInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId?: string | null
    accountId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutOpportunitiesNestedInput
    account?: CrmAccountUpdateOneWithoutOpportunitiesNestedInput
    activities?: CrmActivityUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityCreateManyInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId?: string | null
    accountId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmOpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmOpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityCreateInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    createdAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutActivitiesInput
    account?: CrmAccountCreateNestedOneWithoutActivitiesInput
    opportunity?: CrmOpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type CrmActivityUncheckedCreateInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    accountId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutActivitiesNestedInput
    account?: CrmAccountUpdateOneWithoutActivitiesNestedInput
    opportunity?: CrmOpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type CrmActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityCreateManyInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    accountId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PersonNameListRelationFilter = {
    every?: PersonNameWhereInput
    some?: PersonNameWhereInput
    none?: PersonNameWhereInput
  }

  export type EmailAddressListRelationFilter = {
    every?: EmailAddressWhereInput
    some?: EmailAddressWhereInput
    none?: EmailAddressWhereInput
  }

  export type PhoneListRelationFilter = {
    every?: PhoneWhereInput
    some?: PhoneWhereInput
    none?: PhoneWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type DoNotEngageGlobalNullableRelationFilter = {
    is?: DoNotEngageGlobalWhereInput | null
    isNot?: DoNotEngageGlobalWhereInput | null
  }

  export type DoNotEngageAgentListRelationFilter = {
    every?: DoNotEngageAgentWhereInput
    some?: DoNotEngageAgentWhereInput
    none?: DoNotEngageAgentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoNotEngageAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    citizenshipStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type PersonNameCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonNameMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonNameMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    given?: SortOrder
    middle?: SortOrder
    family?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmailAddressPersonIdAddressCompoundUniqueInput = {
    personId: string
    address: string
  }

  export type EmailAddressCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAddressMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    address?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    number?: SortOrder
    extension?: SortOrder
    type?: SortOrder
    preferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoNotEngageGlobalCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    emailBlocked?: SortOrder
    smsBlocked?: SortOrder
    phoneBlocked?: SortOrder
    source?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type DoNotEngageGlobalMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    emailBlocked?: SortOrder
    smsBlocked?: SortOrder
    phoneBlocked?: SortOrder
    source?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type DoNotEngageGlobalMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    emailBlocked?: SortOrder
    smsBlocked?: SortOrder
    phoneBlocked?: SortOrder
    source?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type DoNotEngageAgentPersonIdAgentIdCompoundUniqueInput = {
    personId: string
    agentId: string
  }

  export type DoNotEngageAgentCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DoNotEngageAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DoNotEngageAgentMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AcademicPeriodNullableRelationFilter = {
    is?: AcademicPeriodWhereInput | null
    isNot?: AcademicPeriodWhereInput | null
  }

  export type SectionRegistrationListRelationFilter = {
    every?: SectionRegistrationWhereInput
    some?: SectionRegistrationWhereInput
    none?: SectionRegistrationWhereInput
  }

  export type StudentAcademicProgramListRelationFilter = {
    every?: StudentAcademicProgramWhereInput
    some?: StudentAcademicProgramWhereInput
    none?: StudentAcademicProgramWhereInput
  }

  export type AcademicCredentialListRelationFilter = {
    every?: AcademicCredentialWhereInput
    some?: AcademicCredentialWhereInput
    none?: AcademicCredentialWhereInput
  }

  export type StudentTranscriptGradeListRelationFilter = {
    every?: StudentTranscriptGradeWhereInput
    some?: StudentTranscriptGradeWhereInput
    none?: StudentTranscriptGradeWhereInput
  }

  export type StudentRiskListRelationFilter = {
    every?: StudentRiskWhereInput
    some?: StudentRiskWhereInput
    none?: StudentRiskWhereInput
  }

  export type SectionRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAcademicProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTranscriptGradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentRiskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    entryAcademicPeriodId?: SortOrder
    academicLevel?: SortOrder
    residency?: SortOrder
    studentClassification?: SortOrder
    studentLoad?: SortOrder
    academicStandingCode?: SortOrder
    studentNumber?: SortOrder
    isFirstGen?: SortOrder
    isPellEligible?: SortOrder
    isInState?: SortOrder
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
    hasHousingInstability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    workHoursPerWeek?: SortOrder
    commuteMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    censusOn?: SortOrder
    registrationStartOn?: SortOrder
    registrationEndOn?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CourseSubjectCodeNumberCatalogYearCompoundUniqueInput = {
    subjectCode: string
    number: string
    catalogYear: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    subjectCode?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
    courseLevel?: SortOrder
    status?: SortOrder
    effectiveStartDate?: SortOrder
    effectiveEndDate?: SortOrder
    catalogYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    creditsIncrement?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type AcademicPeriodRelationFilter = {
    is?: AcademicPeriodWhereInput
    isNot?: AcademicPeriodWhereInput
  }

  export type PersonNullableRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type SectionAcademicPeriodIdCrnCompoundUniqueInput = {
    academicPeriodId: string
    crn: string
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    daysOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicPeriodId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    crn?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    instructionalMethodCode?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    building?: SortOrder
    roomNumber?: SortOrder
    creditType?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
    instructorPersonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    capacity?: SortOrder
    enrolled?: SortOrder
    available?: SortOrder
    waitlistCapacity?: SortOrder
    waitlistEnrolled?: SortOrder
    creditsMinimum?: SortOrder
    creditsMaximum?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type SectionRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type StudentTranscriptGradeNullableRelationFilter = {
    is?: StudentTranscriptGradeWhereInput | null
    isNot?: StudentTranscriptGradeWhereInput | null
  }

  export type SectionRegistrationStudentIdSectionIdCompoundUniqueInput = {
    studentId: string
    sectionId: string
  }

  export type SectionRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationAvgOrderByAggregateInput = {
    credits?: SortOrder
    attendanceRate?: SortOrder
  }

  export type SectionRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    statusCode?: SortOrder
    registrationDate?: SortOrder
    registeredOn?: SortOrder
    creditType?: SortOrder
    credits?: SortOrder
    gradingOptionCode?: SortOrder
    academicLoad?: SortOrder
    residencyStatus?: SortOrder
    attendanceRate?: SortOrder
    midtermGrade?: SortOrder
    finalGrade?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionRegistrationSumOrderByAggregateInput = {
    credits?: SortOrder
    attendanceRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SectionRegistrationRelationFilter = {
    is?: SectionRegistrationWhereInput
    isNot?: SectionRegistrationWhereInput
  }

  export type StudentTranscriptGradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeAvgOrderByAggregateInput = {
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
  }

  export type StudentTranscriptGradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sectionRegistrationId?: SortOrder
    sectionId?: SortOrder
    academicPeriodId?: SortOrder
    courseId?: SortOrder
    gradeSchemeCode?: SortOrder
    gradeValue?: SortOrder
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
    finalGradeDate?: SortOrder
    status?: SortOrder
    incomplete?: SortOrder
    repeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTranscriptGradeSumOrderByAggregateInput = {
    gradePoints?: SortOrder
    qualityPoints?: SortOrder
    creditsAttempted?: SortOrder
    creditsEarned?: SortOrder
  }

  export type AcademicProgramCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramAvgOrderByAggregateInput = {
    creditsRequired?: SortOrder
  }

  export type AcademicProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    type?: SortOrder
    level?: SortOrder
    degreeCode?: SortOrder
    status?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    accreditationCode?: SortOrder
    creditsRequired?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramSumOrderByAggregateInput = {
    creditsRequired?: SortOrder
  }

  export type AcademicProgramRelationFilter = {
    is?: AcademicProgramWhereInput
    isNot?: AcademicProgramWhereInput
  }

  export type StudentAcademicProgramCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAcademicProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAcademicProgramMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicProgramId?: SortOrder
    startOn?: SortOrder
    endOn?: SortOrder
    status?: SortOrder
    catalogYear?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicProgramNullableRelationFilter = {
    is?: AcademicProgramWhereInput | null
    isNot?: AcademicProgramWhereInput | null
  }

  export type AcademicCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    credentialCode?: SortOrder
    academicProgramId?: SortOrder
    awardedOn?: SortOrder
    status?: SortOrder
    academicPeriodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumRiskBucketFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketFilter<$PrismaModel> | $Enums.RiskBucket
  }

  export type StudentRiskStudentIdAcademicPeriodIdCompoundUniqueInput = {
    studentId: string
    academicPeriodId: string
  }

  export type StudentRiskCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskAvgOrderByAggregateInput = {
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
  }

  export type StudentRiskMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicPeriodId?: SortOrder
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
    overallRiskBucket?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentRiskSumOrderByAggregateInput = {
    attendanceRiskScore?: SortOrder
    academicSupportRiskScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumRiskBucketWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel> | $Enums.RiskBucket
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskBucketFilter<$PrismaModel>
    _max?: NestedEnumRiskBucketFilter<$PrismaModel>
  }

  export type SimulationStateCountOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateMaxOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationStateMinOrderByAggregateInput = {
    id?: SortOrder
    currentSimDate?: SortOrder
    lastTickDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmOpportunityListRelationFilter = {
    every?: CrmOpportunityWhereInput
    some?: CrmOpportunityWhereInput
    none?: CrmOpportunityWhereInput
  }

  export type CrmActivityListRelationFilter = {
    every?: CrmActivityWhereInput
    some?: CrmActivityWhereInput
    none?: CrmActivityWhereInput
  }

  export type CrmOpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrmActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrmContactCountOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMaxOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactMinOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmAccountCountOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmAccountMinOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmContactNullableRelationFilter = {
    is?: CrmContactWhereInput | null
    isNot?: CrmContactWhereInput | null
  }

  export type CrmAccountNullableRelationFilter = {
    is?: CrmAccountWhereInput | null
    isNot?: CrmAccountWhereInput | null
  }

  export type CrmOpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmOpportunityAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CrmOpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmOpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrmOpportunitySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CrmOpportunityNullableRelationFilter = {
    is?: CrmOpportunityWhereInput | null
    isNot?: CrmOpportunityWhereInput | null
  }

  export type CrmActivityCountOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
  }

  export type CrmActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
  }

  export type CrmActivityMinOrderByAggregateInput = {
    id?: SortOrder
    workspace?: SortOrder
    app?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonNameCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
  }

  export type EmailAddressCreateNestedManyWithoutPersonInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
  }

  export type PhoneCreateNestedManyWithoutPersonInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutPersonInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionCreateNestedManyWithoutInstructorInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type DoNotEngageGlobalCreateNestedOneWithoutPersonInput = {
    create?: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
    connectOrCreate?: DoNotEngageGlobalCreateOrConnectWithoutPersonInput
    connect?: DoNotEngageGlobalWhereUniqueInput
  }

  export type DoNotEngageAgentCreateNestedManyWithoutPersonInput = {
    create?: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput> | DoNotEngageAgentCreateWithoutPersonInput[] | DoNotEngageAgentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DoNotEngageAgentCreateOrConnectWithoutPersonInput | DoNotEngageAgentCreateOrConnectWithoutPersonInput[]
    createMany?: DoNotEngageAgentCreateManyPersonInputEnvelope
    connect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
  }

  export type PersonNameUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
  }

  export type EmailAddressUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
  }

  export type PhoneUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
    connectOrCreate?: DoNotEngageGlobalCreateOrConnectWithoutPersonInput
    connect?: DoNotEngageGlobalWhereUniqueInput
  }

  export type DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput> | DoNotEngageAgentCreateWithoutPersonInput[] | DoNotEngageAgentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DoNotEngageAgentCreateOrConnectWithoutPersonInput | DoNotEngageAgentCreateOrConnectWithoutPersonInput[]
    createMany?: DoNotEngageAgentCreateManyPersonInputEnvelope
    connect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonNameUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    upsert?: PersonNameUpsertWithWhereUniqueWithoutPersonInput | PersonNameUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    set?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    disconnect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    delete?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    update?: PersonNameUpdateWithWhereUniqueWithoutPersonInput | PersonNameUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonNameUpdateManyWithWhereWithoutPersonInput | PersonNameUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
  }

  export type EmailAddressUpdateManyWithoutPersonNestedInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    upsert?: EmailAddressUpsertWithWhereUniqueWithoutPersonInput | EmailAddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    set?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    disconnect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    delete?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    update?: EmailAddressUpdateWithWhereUniqueWithoutPersonInput | EmailAddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: EmailAddressUpdateManyWithWhereWithoutPersonInput | EmailAddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
  }

  export type PhoneUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    upsert?: PhoneUpsertWithWhereUniqueWithoutPersonInput | PhoneUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    set?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    disconnect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    delete?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    update?: PhoneUpdateWithWhereUniqueWithoutPersonInput | PhoneUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PhoneUpdateManyWithWhereWithoutPersonInput | PhoneUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutPersonNestedInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonInput | AddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonInput | AddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonInput | AddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type SectionUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutInstructorInput | SectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutInstructorInput | SectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutInstructorInput | SectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type DoNotEngageGlobalUpdateOneWithoutPersonNestedInput = {
    create?: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
    connectOrCreate?: DoNotEngageGlobalCreateOrConnectWithoutPersonInput
    upsert?: DoNotEngageGlobalUpsertWithoutPersonInput
    disconnect?: DoNotEngageGlobalWhereInput | boolean
    delete?: DoNotEngageGlobalWhereInput | boolean
    connect?: DoNotEngageGlobalWhereUniqueInput
    update?: XOR<XOR<DoNotEngageGlobalUpdateToOneWithWhereWithoutPersonInput, DoNotEngageGlobalUpdateWithoutPersonInput>, DoNotEngageGlobalUncheckedUpdateWithoutPersonInput>
  }

  export type DoNotEngageAgentUpdateManyWithoutPersonNestedInput = {
    create?: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput> | DoNotEngageAgentCreateWithoutPersonInput[] | DoNotEngageAgentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DoNotEngageAgentCreateOrConnectWithoutPersonInput | DoNotEngageAgentCreateOrConnectWithoutPersonInput[]
    upsert?: DoNotEngageAgentUpsertWithWhereUniqueWithoutPersonInput | DoNotEngageAgentUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: DoNotEngageAgentCreateManyPersonInputEnvelope
    set?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    disconnect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    delete?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    connect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    update?: DoNotEngageAgentUpdateWithWhereUniqueWithoutPersonInput | DoNotEngageAgentUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: DoNotEngageAgentUpdateManyWithWhereWithoutPersonInput | DoNotEngageAgentUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: DoNotEngageAgentScalarWhereInput | DoNotEngageAgentScalarWhereInput[]
  }

  export type PersonNameUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput> | PersonNameCreateWithoutPersonInput[] | PersonNameUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonNameCreateOrConnectWithoutPersonInput | PersonNameCreateOrConnectWithoutPersonInput[]
    upsert?: PersonNameUpsertWithWhereUniqueWithoutPersonInput | PersonNameUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonNameCreateManyPersonInputEnvelope
    set?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    disconnect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    delete?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    connect?: PersonNameWhereUniqueInput | PersonNameWhereUniqueInput[]
    update?: PersonNameUpdateWithWhereUniqueWithoutPersonInput | PersonNameUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonNameUpdateManyWithWhereWithoutPersonInput | PersonNameUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
  }

  export type EmailAddressUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput> | EmailAddressCreateWithoutPersonInput[] | EmailAddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: EmailAddressCreateOrConnectWithoutPersonInput | EmailAddressCreateOrConnectWithoutPersonInput[]
    upsert?: EmailAddressUpsertWithWhereUniqueWithoutPersonInput | EmailAddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: EmailAddressCreateManyPersonInputEnvelope
    set?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    disconnect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    delete?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    connect?: EmailAddressWhereUniqueInput | EmailAddressWhereUniqueInput[]
    update?: EmailAddressUpdateWithWhereUniqueWithoutPersonInput | EmailAddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: EmailAddressUpdateManyWithWhereWithoutPersonInput | EmailAddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
  }

  export type PhoneUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput> | PhoneCreateWithoutPersonInput[] | PhoneUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PhoneCreateOrConnectWithoutPersonInput | PhoneCreateOrConnectWithoutPersonInput[]
    upsert?: PhoneUpsertWithWhereUniqueWithoutPersonInput | PhoneUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PhoneCreateManyPersonInputEnvelope
    set?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    disconnect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    delete?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    connect?: PhoneWhereUniqueInput | PhoneWhereUniqueInput[]
    update?: PhoneUpdateWithWhereUniqueWithoutPersonInput | PhoneUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PhoneUpdateManyWithWhereWithoutPersonInput | PhoneUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput> | AddressCreateWithoutPersonInput[] | AddressUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonInput | AddressCreateOrConnectWithoutPersonInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonInput | AddressUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: AddressCreateManyPersonInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonInput | AddressUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonInput | AddressUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type SectionUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput> | SectionCreateWithoutInstructorInput[] | SectionUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutInstructorInput | SectionCreateOrConnectWithoutInstructorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutInstructorInput | SectionUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: SectionCreateManyInstructorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutInstructorInput | SectionUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutInstructorInput | SectionUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
    connectOrCreate?: DoNotEngageGlobalCreateOrConnectWithoutPersonInput
    upsert?: DoNotEngageGlobalUpsertWithoutPersonInput
    disconnect?: DoNotEngageGlobalWhereInput | boolean
    delete?: DoNotEngageGlobalWhereInput | boolean
    connect?: DoNotEngageGlobalWhereUniqueInput
    update?: XOR<XOR<DoNotEngageGlobalUpdateToOneWithWhereWithoutPersonInput, DoNotEngageGlobalUpdateWithoutPersonInput>, DoNotEngageGlobalUncheckedUpdateWithoutPersonInput>
  }

  export type DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput> | DoNotEngageAgentCreateWithoutPersonInput[] | DoNotEngageAgentUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DoNotEngageAgentCreateOrConnectWithoutPersonInput | DoNotEngageAgentCreateOrConnectWithoutPersonInput[]
    upsert?: DoNotEngageAgentUpsertWithWhereUniqueWithoutPersonInput | DoNotEngageAgentUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: DoNotEngageAgentCreateManyPersonInputEnvelope
    set?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    disconnect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    delete?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    connect?: DoNotEngageAgentWhereUniqueInput | DoNotEngageAgentWhereUniqueInput[]
    update?: DoNotEngageAgentUpdateWithWhereUniqueWithoutPersonInput | DoNotEngageAgentUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: DoNotEngageAgentUpdateManyWithWhereWithoutPersonInput | DoNotEngageAgentUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: DoNotEngageAgentScalarWhereInput | DoNotEngageAgentScalarWhereInput[]
  }

  export type PersonCreateNestedOneWithoutNamesInput = {
    create?: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutNamesInput
    connect?: PersonWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonUpdateOneRequiredWithoutNamesNestedInput = {
    create?: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutNamesInput
    upsert?: PersonUpsertWithoutNamesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutNamesInput, PersonUpdateWithoutNamesInput>, PersonUncheckedUpdateWithoutNamesInput>
  }

  export type PersonCreateNestedOneWithoutEmailsInput = {
    create?: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmailsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmailsInput
    upsert?: PersonUpsertWithoutEmailsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutEmailsInput, PersonUpdateWithoutEmailsInput>, PersonUncheckedUpdateWithoutEmailsInput>
  }

  export type PersonCreateNestedOneWithoutPhonesInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    upsert?: PersonUpsertWithoutPhonesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutPhonesInput, PersonUpdateWithoutPhonesInput>, PersonUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonCreateNestedOneWithoutAddressesInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    upsert?: PersonUpsertWithoutAddressesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutAddressesInput, PersonUpdateWithoutAddressesInput>, PersonUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonCreateNestedOneWithoutDoNotEngageGlobalInput = {
    create?: XOR<PersonCreateWithoutDoNotEngageGlobalInput, PersonUncheckedCreateWithoutDoNotEngageGlobalInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDoNotEngageGlobalInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutDoNotEngageGlobalNestedInput = {
    create?: XOR<PersonCreateWithoutDoNotEngageGlobalInput, PersonUncheckedCreateWithoutDoNotEngageGlobalInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDoNotEngageGlobalInput
    upsert?: PersonUpsertWithoutDoNotEngageGlobalInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutDoNotEngageGlobalInput, PersonUpdateWithoutDoNotEngageGlobalInput>, PersonUncheckedUpdateWithoutDoNotEngageGlobalInput>
  }

  export type PersonCreateNestedOneWithoutDoNotEngageAgentsInput = {
    create?: XOR<PersonCreateWithoutDoNotEngageAgentsInput, PersonUncheckedCreateWithoutDoNotEngageAgentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDoNotEngageAgentsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutDoNotEngageAgentsNestedInput = {
    create?: XOR<PersonCreateWithoutDoNotEngageAgentsInput, PersonUncheckedCreateWithoutDoNotEngageAgentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDoNotEngageAgentsInput
    upsert?: PersonUpsertWithoutDoNotEngageAgentsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutDoNotEngageAgentsInput, PersonUpdateWithoutDoNotEngageAgentsInput>, PersonUncheckedUpdateWithoutDoNotEngageAgentsInput>
  }

  export type PersonCreateNestedOneWithoutStudentInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    connect?: PersonWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutEntryStudentsInput = {
    create?: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEntryStudentsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedManyWithoutStudentInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentAcademicProgramCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentRiskCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentRiskUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    upsert?: PersonUpsertWithoutStudentInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutStudentInput, PersonUpdateWithoutStudentInput>, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutEntryStudentsInput
    upsert?: AcademicPeriodUpsertWithoutEntryStudentsInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutEntryStudentsInput, AcademicPeriodUpdateWithoutEntryStudentsInput>, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
  }

  export type SectionRegistrationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput | SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput | SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutStudentInput | SectionRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentAcademicProgramUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput | StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput | AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput | AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutStudentInput | AcademicCredentialUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput | StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentRiskUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutStudentInput | StudentRiskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutStudentInput | StudentRiskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutStudentInput | StudentRiskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput> | SectionRegistrationCreateWithoutStudentInput[] | SectionRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutStudentInput | SectionRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput | SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SectionRegistrationCreateManyStudentInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput | SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutStudentInput | SectionRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput> | StudentAcademicProgramCreateWithoutStudentInput[] | StudentAcademicProgramUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutStudentInput | StudentAcademicProgramCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicProgramCreateManyStudentInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput | StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput> | AcademicCredentialCreateWithoutStudentInput[] | AcademicCredentialUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutStudentInput | AcademicCredentialCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput | AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicCredentialCreateManyStudentInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput | AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutStudentInput | AcademicCredentialUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput> | StudentTranscriptGradeCreateWithoutStudentInput[] | StudentTranscriptGradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutStudentInput | StudentTranscriptGradeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTranscriptGradeCreateManyStudentInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput | StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentRiskUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput> | StudentRiskCreateWithoutStudentInput[] | StudentRiskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutStudentInput | StudentRiskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutStudentInput | StudentRiskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRiskCreateManyStudentInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutStudentInput | StudentRiskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutStudentInput | StudentRiskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutEntryAcademicPeriodInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentRiskCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
  }

  export type SectionUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutAcademicPeriodInput | SectionUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput | SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutEntryAcademicPeriodNestedInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput | StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentRiskUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput | StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput> | SectionCreateWithoutAcademicPeriodInput[] | SectionUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutAcademicPeriodInput | SectionCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionCreateManyAcademicPeriodInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutAcademicPeriodInput | SectionUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput> | SectionRegistrationCreateWithoutAcademicPeriodInput[] | SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput | SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: SectionRegistrationCreateManyAcademicPeriodInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput | SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput | SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput> | StudentTranscriptGradeCreateWithoutAcademicPeriodInput[] | StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput | StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput | StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput = {
    create?: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput> | StudentCreateWithoutEntryAcademicPeriodInput[] | StudentUncheckedCreateWithoutEntryAcademicPeriodInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutEntryAcademicPeriodInput | StudentCreateOrConnectWithoutEntryAcademicPeriodInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    createMany?: StudentCreateManyEntryAcademicPeriodInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput | StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput | StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput> | AcademicCredentialCreateWithoutAcademicPeriodInput[] | AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput | AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: AcademicCredentialCreateManyAcademicPeriodInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput = {
    create?: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput> | StudentRiskCreateWithoutAcademicPeriodInput[] | StudentRiskUncheckedCreateWithoutAcademicPeriodInput[]
    connectOrCreate?: StudentRiskCreateOrConnectWithoutAcademicPeriodInput | StudentRiskCreateOrConnectWithoutAcademicPeriodInput[]
    upsert?: StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput[]
    createMany?: StudentRiskCreateManyAcademicPeriodInputEnvelope
    set?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    disconnect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    delete?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    connect?: StudentRiskWhereUniqueInput | StudentRiskWhereUniqueInput[]
    update?: StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput | StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput[]
    updateMany?: StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput | StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput[]
    deleteMany?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
  }

  export type SectionCreateNestedManyWithoutCourseInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SectionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCourseInput | SectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCourseInput | SectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCourseInput | SectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput | StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput> | SectionCreateWithoutCourseInput[] | SectionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutCourseInput | SectionCreateOrConnectWithoutCourseInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutCourseInput | SectionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SectionCreateManyCourseInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutCourseInput | SectionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutCourseInput | SectionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput> | StudentTranscriptGradeCreateWithoutCourseInput[] | StudentTranscriptGradeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutCourseInput | StudentTranscriptGradeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTranscriptGradeCreateManyCourseInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput | StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionCreatedaysOfWeekInput = {
    set: string[]
  }

  export type CourseCreateNestedOneWithoutSectionsInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutSectionsInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutSectionsInput = {
    create?: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSectionsInput
    connect?: PersonWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
  }

  export type StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SectionUpdatedaysOfWeekInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSectionsInput
    upsert?: CourseUpsertWithoutSectionsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSectionsInput, CourseUpdateWithoutSectionsInput>, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionsInput
    upsert?: AcademicPeriodUpsertWithoutSectionsInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutSectionsInput, AcademicPeriodUpdateWithoutSectionsInput>, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
  }

  export type PersonUpdateOneWithoutSectionsNestedInput = {
    create?: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSectionsInput
    upsert?: PersonUpsertWithoutSectionsInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutSectionsInput, PersonUpdateWithoutSectionsInput>, PersonUncheckedUpdateWithoutSectionsInput>
  }

  export type SectionRegistrationUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput | SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput | SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutSectionInput | SectionRegistrationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput | StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput> | SectionRegistrationCreateWithoutSectionInput[] | SectionRegistrationUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutSectionInput | SectionRegistrationCreateOrConnectWithoutSectionInput[]
    upsert?: SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput | SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionRegistrationCreateManySectionInputEnvelope
    set?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    disconnect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    delete?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    connect?: SectionRegistrationWhereUniqueInput | SectionRegistrationWhereUniqueInput[]
    update?: SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput | SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionRegistrationUpdateManyWithWhereWithoutSectionInput | SectionRegistrationUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput> | StudentTranscriptGradeCreateWithoutSectionInput[] | StudentTranscriptGradeUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionInput | StudentTranscriptGradeCreateOrConnectWithoutSectionInput[]
    upsert?: StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: StudentTranscriptGradeCreateManySectionInputEnvelope
    set?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    disconnect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    delete?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    connect?: StudentTranscriptGradeWhereUniqueInput | StudentTranscriptGradeWhereUniqueInput[]
    update?: StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput | StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput | StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSectionRegistrationsInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSectionRegistrationsInput
    connect?: SectionWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    connect?: StudentTranscriptGradeWhereUniqueInput
  }

  export type StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    connect?: StudentTranscriptGradeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: StudentUpsertWithoutSectionRegistrationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSectionRegistrationsInput, StudentUpdateWithoutSectionRegistrationsInput>, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: SectionUpsertWithoutSectionRegistrationsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutSectionRegistrationsInput, SectionUpdateWithoutSectionRegistrationsInput>, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput
    upsert?: AcademicPeriodUpsertWithoutSectionRegistrationsInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutSectionRegistrationsInput, AcademicPeriodUpdateWithoutSectionRegistrationsInput>, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    upsert?: StudentTranscriptGradeUpsertWithoutSectionRegistrationInput
    disconnect?: StudentTranscriptGradeWhereInput | boolean
    delete?: StudentTranscriptGradeWhereInput | boolean
    connect?: StudentTranscriptGradeWhereUniqueInput
    update?: XOR<XOR<StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput, StudentTranscriptGradeUpdateWithoutSectionRegistrationInput>, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput = {
    create?: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    connectOrCreate?: StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput
    upsert?: StudentTranscriptGradeUpsertWithoutSectionRegistrationInput
    disconnect?: StudentTranscriptGradeWhereInput | boolean
    delete?: StudentTranscriptGradeWhereInput | boolean
    connect?: StudentTranscriptGradeWhereUniqueInput
    update?: XOR<XOR<StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput, StudentTranscriptGradeUpdateWithoutSectionRegistrationInput>, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput = {
    create?: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput
    connect?: SectionRegistrationWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTranscriptGradesInput
    connect?: SectionWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutTranscriptGradesInput = {
    create?: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTranscriptGradesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptGradesInput
    upsert?: StudentUpsertWithoutTranscriptGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTranscriptGradesInput, StudentUpdateWithoutTranscriptGradesInput>, StudentUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput = {
    create?: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    connectOrCreate?: SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput
    upsert?: SectionRegistrationUpsertWithoutTranscriptGradeInput
    connect?: SectionRegistrationWhereUniqueInput
    update?: XOR<XOR<SectionRegistrationUpdateToOneWithWhereWithoutTranscriptGradeInput, SectionRegistrationUpdateWithoutTranscriptGradeInput>, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
  }

  export type SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTranscriptGradesInput
    upsert?: SectionUpsertWithoutTranscriptGradesInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTranscriptGradesInput, SectionUpdateWithoutTranscriptGradesInput>, SectionUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput
    upsert?: AcademicPeriodUpsertWithoutTranscriptGradesInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutTranscriptGradesInput, AcademicPeriodUpdateWithoutTranscriptGradesInput>, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput = {
    create?: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTranscriptGradesInput
    upsert?: CourseUpsertWithoutTranscriptGradesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTranscriptGradesInput, CourseUpdateWithoutTranscriptGradesInput>, CourseUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
  }

  export type AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
  }

  export type StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput | StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput> | StudentAcademicProgramCreateWithoutAcademicProgramInput[] | StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput | StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: StudentAcademicProgramCreateManyAcademicProgramInputEnvelope
    set?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    disconnect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    delete?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    connect?: StudentAcademicProgramWhereUniqueInput | StudentAcademicProgramWhereUniqueInput[]
    update?: StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput | StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput | StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput = {
    create?: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput> | AcademicCredentialCreateWithoutAcademicProgramInput[] | AcademicCredentialUncheckedCreateWithoutAcademicProgramInput[]
    connectOrCreate?: AcademicCredentialCreateOrConnectWithoutAcademicProgramInput | AcademicCredentialCreateOrConnectWithoutAcademicProgramInput[]
    upsert?: AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput[]
    createMany?: AcademicCredentialCreateManyAcademicProgramInputEnvelope
    set?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    disconnect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    delete?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    connect?: AcademicCredentialWhereUniqueInput | AcademicCredentialWhereUniqueInput[]
    update?: AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput | AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput[]
    updateMany?: AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput | AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput[]
    deleteMany?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentAcademicProgramsInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicProgramsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicProgramCreateNestedOneWithoutStudentProgramsInput = {
    create?: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutStudentProgramsInput
    connect?: AcademicProgramWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicProgramsInput
    upsert?: StudentUpsertWithoutStudentAcademicProgramsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAcademicProgramsInput, StudentUpdateWithoutStudentAcademicProgramsInput>, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
  }

  export type AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput = {
    create?: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutStudentProgramsInput
    upsert?: AcademicProgramUpsertWithoutStudentProgramsInput
    connect?: AcademicProgramWhereUniqueInput
    update?: XOR<XOR<AcademicProgramUpdateToOneWithWhereWithoutStudentProgramsInput, AcademicProgramUpdateWithoutStudentProgramsInput>, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type StudentCreateNestedOneWithoutAcademicCredentialsInput = {
    create?: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicCredentialsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicProgramCreateNestedOneWithoutCredentialsInput = {
    create?: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutCredentialsInput
    connect?: AcademicProgramWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput = {
    create?: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicCredentialsInput
    upsert?: StudentUpsertWithoutAcademicCredentialsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicCredentialsInput, StudentUpdateWithoutAcademicCredentialsInput>, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
  }

  export type AcademicProgramUpdateOneWithoutCredentialsNestedInput = {
    create?: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    connectOrCreate?: AcademicProgramCreateOrConnectWithoutCredentialsInput
    upsert?: AcademicProgramUpsertWithoutCredentialsInput
    disconnect?: AcademicProgramWhereInput | boolean
    delete?: AcademicProgramWhereInput | boolean
    connect?: AcademicProgramWhereUniqueInput
    update?: XOR<XOR<AcademicProgramUpdateToOneWithWhereWithoutCredentialsInput, AcademicProgramUpdateWithoutCredentialsInput>, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
  }

  export type AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput
    upsert?: AcademicPeriodUpsertWithoutCredentialPeriodsInput
    disconnect?: AcademicPeriodWhereInput | boolean
    delete?: AcademicPeriodWhereInput | boolean
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutCredentialPeriodsInput, AcademicPeriodUpdateWithoutCredentialPeriodsInput>, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
  }

  export type StudentCreateNestedOneWithoutStudentRisksInput = {
    create?: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentRisksInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicPeriodCreateNestedOneWithoutStudentRisksInput = {
    create?: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutStudentRisksInput
    connect?: AcademicPeriodWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRiskBucketFieldUpdateOperationsInput = {
    set?: $Enums.RiskBucket
  }

  export type StudentUpdateOneRequiredWithoutStudentRisksNestedInput = {
    create?: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentRisksInput
    upsert?: StudentUpsertWithoutStudentRisksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentRisksInput, StudentUpdateWithoutStudentRisksInput>, StudentUncheckedUpdateWithoutStudentRisksInput>
  }

  export type AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput = {
    create?: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    connectOrCreate?: AcademicPeriodCreateOrConnectWithoutStudentRisksInput
    upsert?: AcademicPeriodUpsertWithoutStudentRisksInput
    connect?: AcademicPeriodWhereUniqueInput
    update?: XOR<XOR<AcademicPeriodUpdateToOneWithWhereWithoutStudentRisksInput, AcademicPeriodUpdateWithoutStudentRisksInput>, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
  }

  export type CrmOpportunityCreateNestedManyWithoutContactInput = {
    create?: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput> | CrmOpportunityCreateWithoutContactInput[] | CrmOpportunityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutContactInput | CrmOpportunityCreateOrConnectWithoutContactInput[]
    createMany?: CrmOpportunityCreateManyContactInputEnvelope
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
  }

  export type CrmActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput> | CrmActivityCreateWithoutContactInput[] | CrmActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutContactInput | CrmActivityCreateOrConnectWithoutContactInput[]
    createMany?: CrmActivityCreateManyContactInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmOpportunityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput> | CrmOpportunityCreateWithoutContactInput[] | CrmOpportunityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutContactInput | CrmOpportunityCreateOrConnectWithoutContactInput[]
    createMany?: CrmOpportunityCreateManyContactInputEnvelope
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
  }

  export type CrmActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput> | CrmActivityCreateWithoutContactInput[] | CrmActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutContactInput | CrmActivityCreateOrConnectWithoutContactInput[]
    createMany?: CrmActivityCreateManyContactInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmOpportunityUpdateManyWithoutContactNestedInput = {
    create?: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput> | CrmOpportunityCreateWithoutContactInput[] | CrmOpportunityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutContactInput | CrmOpportunityCreateOrConnectWithoutContactInput[]
    upsert?: CrmOpportunityUpsertWithWhereUniqueWithoutContactInput | CrmOpportunityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CrmOpportunityCreateManyContactInputEnvelope
    set?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    disconnect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    delete?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    update?: CrmOpportunityUpdateWithWhereUniqueWithoutContactInput | CrmOpportunityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CrmOpportunityUpdateManyWithWhereWithoutContactInput | CrmOpportunityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
  }

  export type CrmActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput> | CrmActivityCreateWithoutContactInput[] | CrmActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutContactInput | CrmActivityCreateOrConnectWithoutContactInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutContactInput | CrmActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CrmActivityCreateManyContactInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutContactInput | CrmActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutContactInput | CrmActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmOpportunityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput> | CrmOpportunityCreateWithoutContactInput[] | CrmOpportunityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutContactInput | CrmOpportunityCreateOrConnectWithoutContactInput[]
    upsert?: CrmOpportunityUpsertWithWhereUniqueWithoutContactInput | CrmOpportunityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CrmOpportunityCreateManyContactInputEnvelope
    set?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    disconnect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    delete?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    update?: CrmOpportunityUpdateWithWhereUniqueWithoutContactInput | CrmOpportunityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CrmOpportunityUpdateManyWithWhereWithoutContactInput | CrmOpportunityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
  }

  export type CrmActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput> | CrmActivityCreateWithoutContactInput[] | CrmActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutContactInput | CrmActivityCreateOrConnectWithoutContactInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutContactInput | CrmActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CrmActivityCreateManyContactInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutContactInput | CrmActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutContactInput | CrmActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmOpportunityCreateNestedManyWithoutAccountInput = {
    create?: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput> | CrmOpportunityCreateWithoutAccountInput[] | CrmOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutAccountInput | CrmOpportunityCreateOrConnectWithoutAccountInput[]
    createMany?: CrmOpportunityCreateManyAccountInputEnvelope
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
  }

  export type CrmActivityCreateNestedManyWithoutAccountInput = {
    create?: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput> | CrmActivityCreateWithoutAccountInput[] | CrmActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutAccountInput | CrmActivityCreateOrConnectWithoutAccountInput[]
    createMany?: CrmActivityCreateManyAccountInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmOpportunityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput> | CrmOpportunityCreateWithoutAccountInput[] | CrmOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutAccountInput | CrmOpportunityCreateOrConnectWithoutAccountInput[]
    createMany?: CrmOpportunityCreateManyAccountInputEnvelope
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
  }

  export type CrmActivityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput> | CrmActivityCreateWithoutAccountInput[] | CrmActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutAccountInput | CrmActivityCreateOrConnectWithoutAccountInput[]
    createMany?: CrmActivityCreateManyAccountInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmOpportunityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput> | CrmOpportunityCreateWithoutAccountInput[] | CrmOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutAccountInput | CrmOpportunityCreateOrConnectWithoutAccountInput[]
    upsert?: CrmOpportunityUpsertWithWhereUniqueWithoutAccountInput | CrmOpportunityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CrmOpportunityCreateManyAccountInputEnvelope
    set?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    disconnect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    delete?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    update?: CrmOpportunityUpdateWithWhereUniqueWithoutAccountInput | CrmOpportunityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CrmOpportunityUpdateManyWithWhereWithoutAccountInput | CrmOpportunityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
  }

  export type CrmActivityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput> | CrmActivityCreateWithoutAccountInput[] | CrmActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutAccountInput | CrmActivityCreateOrConnectWithoutAccountInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutAccountInput | CrmActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CrmActivityCreateManyAccountInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutAccountInput | CrmActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutAccountInput | CrmActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmOpportunityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput> | CrmOpportunityCreateWithoutAccountInput[] | CrmOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutAccountInput | CrmOpportunityCreateOrConnectWithoutAccountInput[]
    upsert?: CrmOpportunityUpsertWithWhereUniqueWithoutAccountInput | CrmOpportunityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CrmOpportunityCreateManyAccountInputEnvelope
    set?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    disconnect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    delete?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    connect?: CrmOpportunityWhereUniqueInput | CrmOpportunityWhereUniqueInput[]
    update?: CrmOpportunityUpdateWithWhereUniqueWithoutAccountInput | CrmOpportunityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CrmOpportunityUpdateManyWithWhereWithoutAccountInput | CrmOpportunityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
  }

  export type CrmActivityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput> | CrmActivityCreateWithoutAccountInput[] | CrmActivityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutAccountInput | CrmActivityCreateOrConnectWithoutAccountInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutAccountInput | CrmActivityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CrmActivityCreateManyAccountInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutAccountInput | CrmActivityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutAccountInput | CrmActivityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmContactCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<CrmContactCreateWithoutOpportunitiesInput, CrmContactUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CrmContactCreateOrConnectWithoutOpportunitiesInput
    connect?: CrmContactWhereUniqueInput
  }

  export type CrmAccountCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<CrmAccountCreateWithoutOpportunitiesInput, CrmAccountUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CrmAccountCreateOrConnectWithoutOpportunitiesInput
    connect?: CrmAccountWhereUniqueInput
  }

  export type CrmActivityCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput> | CrmActivityCreateWithoutOpportunityInput[] | CrmActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutOpportunityInput | CrmActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: CrmActivityCreateManyOpportunityInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmActivityUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput> | CrmActivityCreateWithoutOpportunityInput[] | CrmActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutOpportunityInput | CrmActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: CrmActivityCreateManyOpportunityInputEnvelope
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
  }

  export type CrmContactUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<CrmContactCreateWithoutOpportunitiesInput, CrmContactUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CrmContactCreateOrConnectWithoutOpportunitiesInput
    upsert?: CrmContactUpsertWithoutOpportunitiesInput
    disconnect?: CrmContactWhereInput | boolean
    delete?: CrmContactWhereInput | boolean
    connect?: CrmContactWhereUniqueInput
    update?: XOR<XOR<CrmContactUpdateToOneWithWhereWithoutOpportunitiesInput, CrmContactUpdateWithoutOpportunitiesInput>, CrmContactUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CrmAccountUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<CrmAccountCreateWithoutOpportunitiesInput, CrmAccountUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CrmAccountCreateOrConnectWithoutOpportunitiesInput
    upsert?: CrmAccountUpsertWithoutOpportunitiesInput
    disconnect?: CrmAccountWhereInput | boolean
    delete?: CrmAccountWhereInput | boolean
    connect?: CrmAccountWhereUniqueInput
    update?: XOR<XOR<CrmAccountUpdateToOneWithWhereWithoutOpportunitiesInput, CrmAccountUpdateWithoutOpportunitiesInput>, CrmAccountUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CrmActivityUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput> | CrmActivityCreateWithoutOpportunityInput[] | CrmActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutOpportunityInput | CrmActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutOpportunityInput | CrmActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CrmActivityCreateManyOpportunityInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutOpportunityInput | CrmActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutOpportunityInput | CrmActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmActivityUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput> | CrmActivityCreateWithoutOpportunityInput[] | CrmActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CrmActivityCreateOrConnectWithoutOpportunityInput | CrmActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: CrmActivityUpsertWithWhereUniqueWithoutOpportunityInput | CrmActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CrmActivityCreateManyOpportunityInputEnvelope
    set?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    disconnect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    delete?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    connect?: CrmActivityWhereUniqueInput | CrmActivityWhereUniqueInput[]
    update?: CrmActivityUpdateWithWhereUniqueWithoutOpportunityInput | CrmActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CrmActivityUpdateManyWithWhereWithoutOpportunityInput | CrmActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
  }

  export type CrmContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CrmContactCreateWithoutActivitiesInput, CrmContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmContactCreateOrConnectWithoutActivitiesInput
    connect?: CrmContactWhereUniqueInput
  }

  export type CrmAccountCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CrmAccountCreateWithoutActivitiesInput, CrmAccountUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmAccountCreateOrConnectWithoutActivitiesInput
    connect?: CrmAccountWhereUniqueInput
  }

  export type CrmOpportunityCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CrmOpportunityCreateWithoutActivitiesInput, CrmOpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutActivitiesInput
    connect?: CrmOpportunityWhereUniqueInput
  }

  export type CrmContactUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<CrmContactCreateWithoutActivitiesInput, CrmContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmContactCreateOrConnectWithoutActivitiesInput
    upsert?: CrmContactUpsertWithoutActivitiesInput
    disconnect?: CrmContactWhereInput | boolean
    delete?: CrmContactWhereInput | boolean
    connect?: CrmContactWhereUniqueInput
    update?: XOR<XOR<CrmContactUpdateToOneWithWhereWithoutActivitiesInput, CrmContactUpdateWithoutActivitiesInput>, CrmContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type CrmAccountUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<CrmAccountCreateWithoutActivitiesInput, CrmAccountUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmAccountCreateOrConnectWithoutActivitiesInput
    upsert?: CrmAccountUpsertWithoutActivitiesInput
    disconnect?: CrmAccountWhereInput | boolean
    delete?: CrmAccountWhereInput | boolean
    connect?: CrmAccountWhereUniqueInput
    update?: XOR<XOR<CrmAccountUpdateToOneWithWhereWithoutActivitiesInput, CrmAccountUpdateWithoutActivitiesInput>, CrmAccountUncheckedUpdateWithoutActivitiesInput>
  }

  export type CrmOpportunityUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<CrmOpportunityCreateWithoutActivitiesInput, CrmOpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CrmOpportunityCreateOrConnectWithoutActivitiesInput
    upsert?: CrmOpportunityUpsertWithoutActivitiesInput
    disconnect?: CrmOpportunityWhereInput | boolean
    delete?: CrmOpportunityWhereInput | boolean
    connect?: CrmOpportunityWhereUniqueInput
    update?: XOR<XOR<CrmOpportunityUpdateToOneWithWhereWithoutActivitiesInput, CrmOpportunityUpdateWithoutActivitiesInput>, CrmOpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRiskBucketFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketFilter<$PrismaModel> | $Enums.RiskBucket
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskBucket | EnumRiskBucketFieldRefInput<$PrismaModel>
    in?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskBucket[] | ListEnumRiskBucketFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskBucketWithAggregatesFilter<$PrismaModel> | $Enums.RiskBucket
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskBucketFilter<$PrismaModel>
    _max?: NestedEnumRiskBucketFilter<$PrismaModel>
  }

  export type PersonNameCreateWithoutPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameUncheckedCreateWithoutPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonNameCreateOrConnectWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    create: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput>
  }

  export type PersonNameCreateManyPersonInputEnvelope = {
    data: PersonNameCreateManyPersonInput | PersonNameCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type EmailAddressCreateWithoutPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressUncheckedCreateWithoutPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressCreateOrConnectWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    create: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput>
  }

  export type EmailAddressCreateManyPersonInputEnvelope = {
    data: EmailAddressCreateManyPersonInput | EmailAddressCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type PhoneCreateWithoutPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUncheckedCreateWithoutPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneCreateOrConnectWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput>
  }

  export type PhoneCreateManyPersonInputEnvelope = {
    data: PhoneCreateManyPersonInput | PhoneCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutPersonInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput>
  }

  export type AddressCreateManyPersonInputEnvelope = {
    data: AddressCreateManyPersonInput | AddressCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutPersonInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPersonInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPersonInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
  }

  export type SectionCreateWithoutInstructorInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutInstructorInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput>
  }

  export type SectionCreateManyInstructorInputEnvelope = {
    data: SectionCreateManyInstructorInput | SectionCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type DoNotEngageGlobalCreateWithoutPersonInput = {
    id?: string
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source: string
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type DoNotEngageGlobalUncheckedCreateWithoutPersonInput = {
    id?: string
    emailBlocked?: boolean
    smsBlocked?: boolean
    phoneBlocked?: boolean
    source: string
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type DoNotEngageGlobalCreateOrConnectWithoutPersonInput = {
    where: DoNotEngageGlobalWhereUniqueInput
    create: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
  }

  export type DoNotEngageAgentCreateWithoutPersonInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
  }

  export type DoNotEngageAgentUncheckedCreateWithoutPersonInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
  }

  export type DoNotEngageAgentCreateOrConnectWithoutPersonInput = {
    where: DoNotEngageAgentWhereUniqueInput
    create: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput>
  }

  export type DoNotEngageAgentCreateManyPersonInputEnvelope = {
    data: DoNotEngageAgentCreateManyPersonInput | DoNotEngageAgentCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type PersonNameUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    update: XOR<PersonNameUpdateWithoutPersonInput, PersonNameUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonNameCreateWithoutPersonInput, PersonNameUncheckedCreateWithoutPersonInput>
  }

  export type PersonNameUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonNameWhereUniqueInput
    data: XOR<PersonNameUpdateWithoutPersonInput, PersonNameUncheckedUpdateWithoutPersonInput>
  }

  export type PersonNameUpdateManyWithWhereWithoutPersonInput = {
    where: PersonNameScalarWhereInput
    data: XOR<PersonNameUpdateManyMutationInput, PersonNameUncheckedUpdateManyWithoutPersonInput>
  }

  export type PersonNameScalarWhereInput = {
    AND?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
    OR?: PersonNameScalarWhereInput[]
    NOT?: PersonNameScalarWhereInput | PersonNameScalarWhereInput[]
    id?: StringFilter<"PersonName"> | string
    personId?: StringFilter<"PersonName"> | string
    given?: StringFilter<"PersonName"> | string
    middle?: StringNullableFilter<"PersonName"> | string | null
    family?: StringFilter<"PersonName"> | string
    type?: StringFilter<"PersonName"> | string
    preferred?: BoolFilter<"PersonName"> | boolean
    createdAt?: DateTimeFilter<"PersonName"> | Date | string
    updatedAt?: DateTimeFilter<"PersonName"> | Date | string
  }

  export type EmailAddressUpsertWithWhereUniqueWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    update: XOR<EmailAddressUpdateWithoutPersonInput, EmailAddressUncheckedUpdateWithoutPersonInput>
    create: XOR<EmailAddressCreateWithoutPersonInput, EmailAddressUncheckedCreateWithoutPersonInput>
  }

  export type EmailAddressUpdateWithWhereUniqueWithoutPersonInput = {
    where: EmailAddressWhereUniqueInput
    data: XOR<EmailAddressUpdateWithoutPersonInput, EmailAddressUncheckedUpdateWithoutPersonInput>
  }

  export type EmailAddressUpdateManyWithWhereWithoutPersonInput = {
    where: EmailAddressScalarWhereInput
    data: XOR<EmailAddressUpdateManyMutationInput, EmailAddressUncheckedUpdateManyWithoutPersonInput>
  }

  export type EmailAddressScalarWhereInput = {
    AND?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
    OR?: EmailAddressScalarWhereInput[]
    NOT?: EmailAddressScalarWhereInput | EmailAddressScalarWhereInput[]
    id?: StringFilter<"EmailAddress"> | string
    personId?: StringFilter<"EmailAddress"> | string
    address?: StringFilter<"EmailAddress"> | string
    type?: StringFilter<"EmailAddress"> | string
    preferred?: BoolFilter<"EmailAddress"> | boolean
    createdAt?: DateTimeFilter<"EmailAddress"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAddress"> | Date | string
  }

  export type PhoneUpsertWithWhereUniqueWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    update: XOR<PhoneUpdateWithoutPersonInput, PhoneUncheckedUpdateWithoutPersonInput>
    create: XOR<PhoneCreateWithoutPersonInput, PhoneUncheckedCreateWithoutPersonInput>
  }

  export type PhoneUpdateWithWhereUniqueWithoutPersonInput = {
    where: PhoneWhereUniqueInput
    data: XOR<PhoneUpdateWithoutPersonInput, PhoneUncheckedUpdateWithoutPersonInput>
  }

  export type PhoneUpdateManyWithWhereWithoutPersonInput = {
    where: PhoneScalarWhereInput
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyWithoutPersonInput>
  }

  export type PhoneScalarWhereInput = {
    AND?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
    OR?: PhoneScalarWhereInput[]
    NOT?: PhoneScalarWhereInput | PhoneScalarWhereInput[]
    id?: StringFilter<"Phone"> | string
    personId?: StringFilter<"Phone"> | string
    number?: StringFilter<"Phone"> | string
    extension?: StringNullableFilter<"Phone"> | string | null
    type?: StringFilter<"Phone"> | string
    preferred?: BoolFilter<"Phone"> | boolean
    createdAt?: DateTimeFilter<"Phone"> | Date | string
    updatedAt?: DateTimeFilter<"Phone"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutPersonInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutPersonInput, AddressUncheckedUpdateWithoutPersonInput>
    create: XOR<AddressCreateWithoutPersonInput, AddressUncheckedCreateWithoutPersonInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutPersonInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutPersonInput, AddressUncheckedUpdateWithoutPersonInput>
  }

  export type AddressUpdateManyWithWhereWithoutPersonInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutPersonInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    personId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type StudentUpsertWithoutPersonInput = {
    update: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPersonInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type StudentUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionUpsertWithWhereUniqueWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutInstructorInput, SectionUncheckedUpdateWithoutInstructorInput>
    create: XOR<SectionCreateWithoutInstructorInput, SectionUncheckedCreateWithoutInstructorInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutInstructorInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutInstructorInput, SectionUncheckedUpdateWithoutInstructorInput>
  }

  export type SectionUpdateManyWithWhereWithoutInstructorInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutInstructorInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: StringFilter<"Section"> | string
    courseId?: StringFilter<"Section"> | string
    academicPeriodId?: StringFilter<"Section"> | string
    number?: StringFilter<"Section"> | string
    title?: StringNullableFilter<"Section"> | string | null
    crn?: StringFilter<"Section"> | string
    startOn?: DateTimeFilter<"Section"> | Date | string
    endOn?: DateTimeFilter<"Section"> | Date | string
    status?: StringFilter<"Section"> | string
    capacity?: IntFilter<"Section"> | number
    enrolled?: IntFilter<"Section"> | number
    available?: IntFilter<"Section"> | number
    waitlistCapacity?: IntNullableFilter<"Section"> | number | null
    waitlistEnrolled?: IntNullableFilter<"Section"> | number | null
    instructionalMethodCode?: StringNullableFilter<"Section"> | string | null
    daysOfWeek?: StringNullableListFilter<"Section">
    startTime?: StringNullableFilter<"Section"> | string | null
    endTime?: StringNullableFilter<"Section"> | string | null
    building?: StringNullableFilter<"Section"> | string | null
    roomNumber?: StringNullableFilter<"Section"> | string | null
    creditType?: StringFilter<"Section"> | string
    creditsMinimum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFilter<"Section"> | Decimal | DecimalJsLike | number | string
    instructorPersonId?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
  }

  export type DoNotEngageGlobalUpsertWithoutPersonInput = {
    update: XOR<DoNotEngageGlobalUpdateWithoutPersonInput, DoNotEngageGlobalUncheckedUpdateWithoutPersonInput>
    create: XOR<DoNotEngageGlobalCreateWithoutPersonInput, DoNotEngageGlobalUncheckedCreateWithoutPersonInput>
    where?: DoNotEngageGlobalWhereInput
  }

  export type DoNotEngageGlobalUpdateToOneWithWhereWithoutPersonInput = {
    where?: DoNotEngageGlobalWhereInput
    data: XOR<DoNotEngageGlobalUpdateWithoutPersonInput, DoNotEngageGlobalUncheckedUpdateWithoutPersonInput>
  }

  export type DoNotEngageGlobalUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageGlobalUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailBlocked?: BoolFieldUpdateOperationsInput | boolean
    smsBlocked?: BoolFieldUpdateOperationsInput | boolean
    phoneBlocked?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentUpsertWithWhereUniqueWithoutPersonInput = {
    where: DoNotEngageAgentWhereUniqueInput
    update: XOR<DoNotEngageAgentUpdateWithoutPersonInput, DoNotEngageAgentUncheckedUpdateWithoutPersonInput>
    create: XOR<DoNotEngageAgentCreateWithoutPersonInput, DoNotEngageAgentUncheckedCreateWithoutPersonInput>
  }

  export type DoNotEngageAgentUpdateWithWhereUniqueWithoutPersonInput = {
    where: DoNotEngageAgentWhereUniqueInput
    data: XOR<DoNotEngageAgentUpdateWithoutPersonInput, DoNotEngageAgentUncheckedUpdateWithoutPersonInput>
  }

  export type DoNotEngageAgentUpdateManyWithWhereWithoutPersonInput = {
    where: DoNotEngageAgentScalarWhereInput
    data: XOR<DoNotEngageAgentUpdateManyMutationInput, DoNotEngageAgentUncheckedUpdateManyWithoutPersonInput>
  }

  export type DoNotEngageAgentScalarWhereInput = {
    AND?: DoNotEngageAgentScalarWhereInput | DoNotEngageAgentScalarWhereInput[]
    OR?: DoNotEngageAgentScalarWhereInput[]
    NOT?: DoNotEngageAgentScalarWhereInput | DoNotEngageAgentScalarWhereInput[]
    id?: StringFilter<"DoNotEngageAgent"> | string
    personId?: StringFilter<"DoNotEngageAgent"> | string
    agentId?: StringFilter<"DoNotEngageAgent"> | string
    createdAt?: DateTimeFilter<"DoNotEngageAgent"> | Date | string
    createdById?: StringNullableFilter<"DoNotEngageAgent"> | string | null
  }

  export type PersonCreateWithoutNamesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutNamesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutNamesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
  }

  export type PersonUpsertWithoutNamesInput = {
    update: XOR<PersonUpdateWithoutNamesInput, PersonUncheckedUpdateWithoutNamesInput>
    create: XOR<PersonCreateWithoutNamesInput, PersonUncheckedCreateWithoutNamesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutNamesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutNamesInput, PersonUncheckedUpdateWithoutNamesInput>
  }

  export type PersonUpdateWithoutNamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutNamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutEmailsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutEmailsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutEmailsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
  }

  export type PersonUpsertWithoutEmailsInput = {
    update: XOR<PersonUpdateWithoutEmailsInput, PersonUncheckedUpdateWithoutEmailsInput>
    create: XOR<PersonCreateWithoutEmailsInput, PersonUncheckedCreateWithoutEmailsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutEmailsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutEmailsInput, PersonUncheckedUpdateWithoutEmailsInput>
  }

  export type PersonUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutPhonesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutPhonesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutPhonesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
  }

  export type PersonUpsertWithoutPhonesInput = {
    update: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutPhonesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutAddressesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutAddressesInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutAddressesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
  }

  export type PersonUpsertWithoutAddressesInput = {
    update: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutAddressesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutDoNotEngageGlobalInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDoNotEngageGlobalInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDoNotEngageGlobalInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDoNotEngageGlobalInput, PersonUncheckedCreateWithoutDoNotEngageGlobalInput>
  }

  export type PersonUpsertWithoutDoNotEngageGlobalInput = {
    update: XOR<PersonUpdateWithoutDoNotEngageGlobalInput, PersonUncheckedUpdateWithoutDoNotEngageGlobalInput>
    create: XOR<PersonCreateWithoutDoNotEngageGlobalInput, PersonUncheckedCreateWithoutDoNotEngageGlobalInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutDoNotEngageGlobalInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutDoNotEngageGlobalInput, PersonUncheckedUpdateWithoutDoNotEngageGlobalInput>
  }

  export type PersonUpdateWithoutDoNotEngageGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutDoNotEngageGlobalInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutDoNotEngageAgentsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDoNotEngageAgentsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDoNotEngageAgentsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDoNotEngageAgentsInput, PersonUncheckedCreateWithoutDoNotEngageAgentsInput>
  }

  export type PersonUpsertWithoutDoNotEngageAgentsInput = {
    update: XOR<PersonUpdateWithoutDoNotEngageAgentsInput, PersonUncheckedUpdateWithoutDoNotEngageAgentsInput>
    create: XOR<PersonCreateWithoutDoNotEngageAgentsInput, PersonUncheckedCreateWithoutDoNotEngageAgentsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutDoNotEngageAgentsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutDoNotEngageAgentsInput, PersonUncheckedUpdateWithoutDoNotEngageAgentsInput>
  }

  export type PersonUpdateWithoutDoNotEngageAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutDoNotEngageAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
  }

  export type PersonCreateWithoutStudentInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    sections?: SectionCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutStudentInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    sections?: SectionUncheckedCreateNestedManyWithoutInstructorInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutStudentInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
  }

  export type AcademicPeriodCreateWithoutEntryStudentsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutEntryStudentsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutEntryStudentsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
  }

  export type SectionRegistrationCreateWithoutStudentInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type SectionRegistrationCreateManyStudentInputEnvelope = {
    data: SectionRegistrationCreateManyStudentInput | SectionRegistrationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicProgramCreateWithoutStudentInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    academicProgram: AcademicProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateWithoutStudentInput = {
    id?: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateOrConnectWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    create: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicProgramCreateManyStudentInputEnvelope = {
    data: StudentAcademicProgramCreateManyStudentInput | StudentAcademicProgramCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutStudentInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutStudentInput = {
    id?: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput>
  }

  export type AcademicCredentialCreateManyStudentInputEnvelope = {
    data: AcademicCredentialCreateManyStudentInput | AcademicCredentialCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutStudentInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutStudentInput = {
    id?: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentTranscriptGradeCreateManyStudentInputEnvelope = {
    data: StudentTranscriptGradeCreateManyStudentInput | StudentTranscriptGradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentRiskCreateWithoutStudentInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    academicPeriod: AcademicPeriodCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateWithoutStudentInput = {
    id?: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskCreateOrConnectWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    create: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput>
  }

  export type StudentRiskCreateManyStudentInputEnvelope = {
    data: StudentRiskCreateManyStudentInput | StudentRiskCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutStudentInput = {
    update: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutStudentInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type PersonUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    sections?: SectionUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    sections?: SectionUncheckedUpdateManyWithoutInstructorNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type AcademicPeriodUpsertWithoutEntryStudentsInput = {
    update: XOR<AcademicPeriodUpdateWithoutEntryStudentsInput, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
    create: XOR<AcademicPeriodCreateWithoutEntryStudentsInput, AcademicPeriodUncheckedCreateWithoutEntryStudentsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutEntryStudentsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutEntryStudentsInput, AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput>
  }

  export type AcademicPeriodUpdateWithoutEntryStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutEntryStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutStudentInput, SectionRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<SectionRegistrationCreateWithoutStudentInput, SectionRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutStudentInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutStudentInput, SectionRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutStudentInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutStudentInput>
  }

  export type SectionRegistrationScalarWhereInput = {
    AND?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
    OR?: SectionRegistrationScalarWhereInput[]
    NOT?: SectionRegistrationScalarWhereInput | SectionRegistrationScalarWhereInput[]
    id?: StringFilter<"SectionRegistration"> | string
    studentId?: StringFilter<"SectionRegistration"> | string
    sectionId?: StringFilter<"SectionRegistration"> | string
    academicPeriodId?: StringFilter<"SectionRegistration"> | string
    statusCode?: StringFilter<"SectionRegistration"> | string
    registrationDate?: DateTimeFilter<"SectionRegistration"> | Date | string
    registeredOn?: DateTimeFilter<"SectionRegistration"> | Date | string
    creditType?: StringFilter<"SectionRegistration"> | string
    credits?: DecimalFilter<"SectionRegistration"> | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: StringNullableFilter<"SectionRegistration"> | string | null
    academicLoad?: StringNullableFilter<"SectionRegistration"> | string | null
    residencyStatus?: StringNullableFilter<"SectionRegistration"> | string | null
    attendanceRate?: FloatNullableFilter<"SectionRegistration"> | number | null
    midtermGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    finalGrade?: StringNullableFilter<"SectionRegistration"> | string | null
    createdAt?: DateTimeFilter<"SectionRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SectionRegistration"> | Date | string
  }

  export type StudentAcademicProgramUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    update: XOR<StudentAcademicProgramUpdateWithoutStudentInput, StudentAcademicProgramUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAcademicProgramCreateWithoutStudentInput, StudentAcademicProgramUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicProgramUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicProgramWhereUniqueInput
    data: XOR<StudentAcademicProgramUpdateWithoutStudentInput, StudentAcademicProgramUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAcademicProgramUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAcademicProgramScalarWhereInput
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicProgramScalarWhereInput = {
    AND?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
    OR?: StudentAcademicProgramScalarWhereInput[]
    NOT?: StudentAcademicProgramScalarWhereInput | StudentAcademicProgramScalarWhereInput[]
    id?: StringFilter<"StudentAcademicProgram"> | string
    studentId?: StringFilter<"StudentAcademicProgram"> | string
    academicProgramId?: StringFilter<"StudentAcademicProgram"> | string
    startOn?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    endOn?: DateTimeNullableFilter<"StudentAcademicProgram"> | Date | string | null
    status?: StringFilter<"StudentAcademicProgram"> | string
    catalogYear?: StringNullableFilter<"StudentAcademicProgram"> | string | null
    primary?: BoolFilter<"StudentAcademicProgram"> | boolean
    createdAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicProgram"> | Date | string
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutStudentInput, AcademicCredentialUncheckedUpdateWithoutStudentInput>
    create: XOR<AcademicCredentialCreateWithoutStudentInput, AcademicCredentialUncheckedCreateWithoutStudentInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutStudentInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutStudentInput, AcademicCredentialUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutStudentInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutStudentInput>
  }

  export type AcademicCredentialScalarWhereInput = {
    AND?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
    OR?: AcademicCredentialScalarWhereInput[]
    NOT?: AcademicCredentialScalarWhereInput | AcademicCredentialScalarWhereInput[]
    id?: StringFilter<"AcademicCredential"> | string
    studentId?: StringFilter<"AcademicCredential"> | string
    credentialCode?: StringFilter<"AcademicCredential"> | string
    academicProgramId?: StringNullableFilter<"AcademicCredential"> | string | null
    awardedOn?: DateTimeFilter<"AcademicCredential"> | Date | string
    status?: StringFilter<"AcademicCredential"> | string
    academicPeriodId?: StringNullableFilter<"AcademicCredential"> | string | null
    createdAt?: DateTimeFilter<"AcademicCredential"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicCredential"> | Date | string
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutStudentInput, StudentTranscriptGradeUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTranscriptGradeCreateWithoutStudentInput, StudentTranscriptGradeUncheckedCreateWithoutStudentInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutStudentInput, StudentTranscriptGradeUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentTranscriptGradeScalarWhereInput = {
    AND?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
    OR?: StudentTranscriptGradeScalarWhereInput[]
    NOT?: StudentTranscriptGradeScalarWhereInput | StudentTranscriptGradeScalarWhereInput[]
    id?: StringFilter<"StudentTranscriptGrade"> | string
    studentId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionRegistrationId?: StringFilter<"StudentTranscriptGrade"> | string
    sectionId?: StringFilter<"StudentTranscriptGrade"> | string
    academicPeriodId?: StringFilter<"StudentTranscriptGrade"> | string
    courseId?: StringFilter<"StudentTranscriptGrade"> | string
    gradeSchemeCode?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradeValue?: StringNullableFilter<"StudentTranscriptGrade"> | string | null
    gradePoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: DecimalNullableFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFilter<"StudentTranscriptGrade"> | Decimal | DecimalJsLike | number | string
    finalGradeDate?: DateTimeNullableFilter<"StudentTranscriptGrade"> | Date | string | null
    status?: StringFilter<"StudentTranscriptGrade"> | string
    incomplete?: BoolFilter<"StudentTranscriptGrade"> | boolean
    repeat?: BoolFilter<"StudentTranscriptGrade"> | boolean
    createdAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTranscriptGrade"> | Date | string
  }

  export type StudentRiskUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    update: XOR<StudentRiskUpdateWithoutStudentInput, StudentRiskUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentRiskCreateWithoutStudentInput, StudentRiskUncheckedCreateWithoutStudentInput>
  }

  export type StudentRiskUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentRiskWhereUniqueInput
    data: XOR<StudentRiskUpdateWithoutStudentInput, StudentRiskUncheckedUpdateWithoutStudentInput>
  }

  export type StudentRiskUpdateManyWithWhereWithoutStudentInput = {
    where: StudentRiskScalarWhereInput
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentRiskScalarWhereInput = {
    AND?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
    OR?: StudentRiskScalarWhereInput[]
    NOT?: StudentRiskScalarWhereInput | StudentRiskScalarWhereInput[]
    id?: StringFilter<"StudentRisk"> | string
    studentId?: StringFilter<"StudentRisk"> | string
    academicPeriodId?: StringFilter<"StudentRisk"> | string
    attendanceRiskScore?: FloatFilter<"StudentRisk"> | number
    academicSupportRiskScore?: FloatFilter<"StudentRisk"> | number
    overallRiskBucket?: EnumRiskBucketFilter<"StudentRisk"> | $Enums.RiskBucket
    updatedAt?: DateTimeFilter<"StudentRisk"> | Date | string
    createdAt?: DateTimeFilter<"StudentRisk"> | Date | string
  }

  export type SectionCreateWithoutAcademicPeriodInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    courseId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionCreateManyAcademicPeriodInputEnvelope = {
    data: SectionCreateManyAcademicPeriodInput | SectionCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type SectionRegistrationCreateWithoutAcademicPeriodInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationCreateManyAcademicPeriodInputEnvelope = {
    data: SectionRegistrationCreateManyAcademicPeriodInput | SectionRegistrationCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutAcademicPeriodInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeCreateManyAcademicPeriodInputEnvelope = {
    data: StudentTranscriptGradeCreateManyAcademicPeriodInput | StudentTranscriptGradeCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutEntryAcademicPeriodInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEntryAcademicPeriodInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput>
  }

  export type StudentCreateManyEntryAcademicPeriodInputEnvelope = {
    data: StudentCreateManyEntryAcademicPeriodInput | StudentCreateManyEntryAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutAcademicPeriodInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicProgram?: AcademicProgramCreateNestedOneWithoutCredentialsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialCreateManyAcademicPeriodInputEnvelope = {
    data: AcademicCredentialCreateManyAcademicPeriodInput | AcademicCredentialCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type StudentRiskCreateWithoutAcademicPeriodInput = {
    id?: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentRisksInput
  }

  export type StudentRiskUncheckedCreateWithoutAcademicPeriodInput = {
    id?: string
    studentId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type StudentRiskCreateOrConnectWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    create: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentRiskCreateManyAcademicPeriodInputEnvelope = {
    data: StudentRiskCreateManyAcademicPeriodInput | StudentRiskCreateManyAcademicPeriodInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutAcademicPeriodInput, SectionUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<SectionCreateWithoutAcademicPeriodInput, SectionUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutAcademicPeriodInput, SectionUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type SectionUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutAcademicPeriodInput, SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<SectionRegistrationCreateWithoutAcademicPeriodInput, SectionRegistrationUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutAcademicPeriodInput, SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<StudentTranscriptGradeCreateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutAcademicPeriodInput, StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutEntryAcademicPeriodInput, StudentUncheckedUpdateWithoutEntryAcademicPeriodInput>
    create: XOR<StudentCreateWithoutEntryAcademicPeriodInput, StudentUncheckedCreateWithoutEntryAcademicPeriodInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutEntryAcademicPeriodInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutEntryAcademicPeriodInput, StudentUncheckedUpdateWithoutEntryAcademicPeriodInput>
  }

  export type StudentUpdateManyWithWhereWithoutEntryAcademicPeriodInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutEntryAcademicPeriodInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    personId?: StringFilter<"Student"> | string
    type?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    startOn?: DateTimeFilter<"Student"> | Date | string
    entryAcademicPeriodId?: StringNullableFilter<"Student"> | string | null
    academicLevel?: StringNullableFilter<"Student"> | string | null
    residency?: StringNullableFilter<"Student"> | string | null
    studentClassification?: StringNullableFilter<"Student"> | string | null
    studentLoad?: StringNullableFilter<"Student"> | string | null
    academicStandingCode?: StringNullableFilter<"Student"> | string | null
    studentNumber?: StringFilter<"Student"> | string
    isFirstGen?: BoolFilter<"Student"> | boolean
    isPellEligible?: BoolFilter<"Student"> | boolean
    isInState?: BoolFilter<"Student"> | boolean
    workHoursPerWeek?: IntFilter<"Student"> | number
    commuteMinutes?: IntFilter<"Student"> | number
    hasHousingInstability?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutAcademicPeriodInput, AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<AcademicCredentialCreateWithoutAcademicPeriodInput, AcademicCredentialUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutAcademicPeriodInput, AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpsertWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    update: XOR<StudentRiskUpdateWithoutAcademicPeriodInput, StudentRiskUncheckedUpdateWithoutAcademicPeriodInput>
    create: XOR<StudentRiskCreateWithoutAcademicPeriodInput, StudentRiskUncheckedCreateWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpdateWithWhereUniqueWithoutAcademicPeriodInput = {
    where: StudentRiskWhereUniqueInput
    data: XOR<StudentRiskUpdateWithoutAcademicPeriodInput, StudentRiskUncheckedUpdateWithoutAcademicPeriodInput>
  }

  export type StudentRiskUpdateManyWithWhereWithoutAcademicPeriodInput = {
    where: StudentRiskScalarWhereInput
    data: XOR<StudentRiskUpdateManyMutationInput, StudentRiskUncheckedUpdateManyWithoutAcademicPeriodInput>
  }

  export type SectionCreateWithoutCourseInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCourseInput = {
    id?: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCourseInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput>
  }

  export type SectionCreateManyCourseInputEnvelope = {
    data: SectionCreateManyCourseInput | SectionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutCourseInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutCourseInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput>
  }

  export type StudentTranscriptGradeCreateManyCourseInputEnvelope = {
    data: StudentTranscriptGradeCreateManyCourseInput | StudentTranscriptGradeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutCourseInput, SectionUncheckedUpdateWithoutCourseInput>
    create: XOR<SectionCreateWithoutCourseInput, SectionUncheckedCreateWithoutCourseInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutCourseInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutCourseInput, SectionUncheckedUpdateWithoutCourseInput>
  }

  export type SectionUpdateManyWithWhereWithoutCourseInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutCourseInput, StudentTranscriptGradeUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentTranscriptGradeCreateWithoutCourseInput, StudentTranscriptGradeUncheckedCreateWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutCourseInput, StudentTranscriptGradeUncheckedUpdateWithoutCourseInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutCourseInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutSectionsInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSectionsInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSectionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
  }

  export type AcademicPeriodCreateWithoutSectionsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutSectionsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutSectionsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
  }

  export type PersonCreateWithoutSectionsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameCreateNestedManyWithoutPersonInput
    emails?: EmailAddressCreateNestedManyWithoutPersonInput
    phones?: PhoneCreateNestedManyWithoutPersonInput
    addresses?: AddressCreateNestedManyWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    doNotEngageGlobal?: DoNotEngageGlobalCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutSectionsInput = {
    id?: string
    birthDate?: Date | string | null
    gender?: string | null
    citizenshipStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    names?: PersonNameUncheckedCreateNestedManyWithoutPersonInput
    emails?: EmailAddressUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhoneUncheckedCreateNestedManyWithoutPersonInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedCreateNestedOneWithoutPersonInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutSectionsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
  }

  export type SectionRegistrationCreateWithoutSectionInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
    transcriptGrade?: StudentTranscriptGradeCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationUncheckedCreateWithoutSectionInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedCreateNestedOneWithoutSectionRegistrationInput
  }

  export type SectionRegistrationCreateOrConnectWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput>
  }

  export type SectionRegistrationCreateManySectionInputEnvelope = {
    data: SectionRegistrationCreateManySectionInput | SectionRegistrationCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentTranscriptGradeCreateWithoutSectionInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    sectionRegistration: SectionRegistrationCreateNestedOneWithoutTranscriptGradeInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutSectionInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput>
  }

  export type StudentTranscriptGradeCreateManySectionInputEnvelope = {
    data: StudentTranscriptGradeCreateManySectionInput | StudentTranscriptGradeCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutSectionsInput = {
    update: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
    create: XOR<CourseCreateWithoutSectionsInput, CourseUncheckedCreateWithoutSectionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSectionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSectionsInput, CourseUncheckedUpdateWithoutSectionsInput>
  }

  export type CourseUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicPeriodUpsertWithoutSectionsInput = {
    update: XOR<AcademicPeriodUpdateWithoutSectionsInput, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
    create: XOR<AcademicPeriodCreateWithoutSectionsInput, AcademicPeriodUncheckedCreateWithoutSectionsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutSectionsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutSectionsInput, AcademicPeriodUncheckedUpdateWithoutSectionsInput>
  }

  export type AcademicPeriodUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type PersonUpsertWithoutSectionsInput = {
    update: XOR<PersonUpdateWithoutSectionsInput, PersonUncheckedUpdateWithoutSectionsInput>
    create: XOR<PersonCreateWithoutSectionsInput, PersonUncheckedCreateWithoutSectionsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutSectionsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutSectionsInput, PersonUncheckedUpdateWithoutSectionsInput>
  }

  export type PersonUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUpdateManyWithoutPersonNestedInput
    phones?: PhoneUpdateManyWithoutPersonNestedInput
    addresses?: AddressUpdateManyWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    citizenshipStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    names?: PersonNameUncheckedUpdateManyWithoutPersonNestedInput
    emails?: EmailAddressUncheckedUpdateManyWithoutPersonNestedInput
    phones?: PhoneUncheckedUpdateManyWithoutPersonNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageGlobal?: DoNotEngageGlobalUncheckedUpdateOneWithoutPersonNestedInput
    doNotEngageAgents?: DoNotEngageAgentUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type SectionRegistrationUpsertWithWhereUniqueWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    update: XOR<SectionRegistrationUpdateWithoutSectionInput, SectionRegistrationUncheckedUpdateWithoutSectionInput>
    create: XOR<SectionRegistrationCreateWithoutSectionInput, SectionRegistrationUncheckedCreateWithoutSectionInput>
  }

  export type SectionRegistrationUpdateWithWhereUniqueWithoutSectionInput = {
    where: SectionRegistrationWhereUniqueInput
    data: XOR<SectionRegistrationUpdateWithoutSectionInput, SectionRegistrationUncheckedUpdateWithoutSectionInput>
  }

  export type SectionRegistrationUpdateManyWithWhereWithoutSectionInput = {
    where: SectionRegistrationScalarWhereInput
    data: XOR<SectionRegistrationUpdateManyMutationInput, SectionRegistrationUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpsertWithWhereUniqueWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    update: XOR<StudentTranscriptGradeUpdateWithoutSectionInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionInput>
    create: XOR<StudentTranscriptGradeCreateWithoutSectionInput, StudentTranscriptGradeUncheckedCreateWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpdateWithWhereUniqueWithoutSectionInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    data: XOR<StudentTranscriptGradeUpdateWithoutSectionInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionInput>
  }

  export type StudentTranscriptGradeUpdateManyWithWhereWithoutSectionInput = {
    where: StudentTranscriptGradeScalarWhereInput
    data: XOR<StudentTranscriptGradeUpdateManyMutationInput, StudentTranscriptGradeUncheckedUpdateManyWithoutSectionInput>
  }

  export type StudentCreateWithoutSectionRegistrationsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSectionRegistrationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type SectionCreateWithoutSectionRegistrationsInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutSectionRegistrationsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodCreateWithoutSectionRegistrationsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutSectionRegistrationsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
  }

  export type StudentTranscriptGradeCreateWithoutSectionRegistrationInput = {
    id?: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutTranscriptGradesInput
    section: SectionCreateNestedOneWithoutTranscriptGradesInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutTranscriptGradesInput
    course: CourseCreateNestedOneWithoutTranscriptGradesInput
  }

  export type StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateOrConnectWithoutSectionRegistrationInput = {
    where: StudentTranscriptGradeWhereUniqueInput
    create: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
  }

  export type StudentUpsertWithoutSectionRegistrationsInput = {
    update: XOR<StudentUpdateWithoutSectionRegistrationsInput, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<StudentCreateWithoutSectionRegistrationsInput, StudentUncheckedCreateWithoutSectionRegistrationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSectionRegistrationsInput, StudentUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type StudentUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionUpsertWithoutSectionRegistrationsInput = {
    update: XOR<SectionUpdateWithoutSectionRegistrationsInput, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<SectionCreateWithoutSectionRegistrationsInput, SectionUncheckedCreateWithoutSectionRegistrationsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutSectionRegistrationsInput, SectionUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type SectionUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type AcademicPeriodUpsertWithoutSectionRegistrationsInput = {
    update: XOR<AcademicPeriodUpdateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
    create: XOR<AcademicPeriodCreateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedCreateWithoutSectionRegistrationsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutSectionRegistrationsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutSectionRegistrationsInput, AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput>
  }

  export type AcademicPeriodUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutSectionRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type StudentTranscriptGradeUpsertWithoutSectionRegistrationInput = {
    update: XOR<StudentTranscriptGradeUpdateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
    create: XOR<StudentTranscriptGradeCreateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedCreateWithoutSectionRegistrationInput>
    where?: StudentTranscriptGradeWhereInput
  }

  export type StudentTranscriptGradeUpdateToOneWithWhereWithoutSectionRegistrationInput = {
    where?: StudentTranscriptGradeWhereInput
    data: XOR<StudentTranscriptGradeUpdateWithoutSectionRegistrationInput, StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput>
  }

  export type StudentTranscriptGradeUpdateWithoutSectionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutSectionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutTranscriptGradesInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTranscriptGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type SectionRegistrationCreateWithoutTranscriptGradeInput = {
    id?: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSectionRegistrationsInput
    section: SectionCreateNestedOneWithoutSectionRegistrationsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionRegistrationsInput
  }

  export type SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput = {
    id?: string
    studentId: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationCreateOrConnectWithoutTranscriptGradeInput = {
    where: SectionRegistrationWhereUniqueInput
    create: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
  }

  export type SectionCreateWithoutTranscriptGradesInput = {
    id?: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutSectionsInput
    academicPeriod: AcademicPeriodCreateNestedOneWithoutSectionsInput
    instructor?: PersonCreateNestedOneWithoutSectionsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTranscriptGradesInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodCreateWithoutTranscriptGradesInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutTranscriptGradesInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type CourseCreateWithoutTranscriptGradesInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTranscriptGradesInput = {
    id?: string
    subjectCode: string
    number: string
    title: string
    description?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    creditsIncrement?: Decimal | DecimalJsLike | number | string | null
    courseLevel: string
    status: string
    effectiveStartDate?: Date | string | null
    effectiveEndDate?: Date | string | null
    catalogYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTranscriptGradesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
  }

  export type StudentUpsertWithoutTranscriptGradesInput = {
    update: XOR<StudentUpdateWithoutTranscriptGradesInput, StudentUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<StudentCreateWithoutTranscriptGradesInput, StudentUncheckedCreateWithoutTranscriptGradesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTranscriptGradesInput, StudentUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type StudentUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SectionRegistrationUpsertWithoutTranscriptGradeInput = {
    update: XOR<SectionRegistrationUpdateWithoutTranscriptGradeInput, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
    create: XOR<SectionRegistrationCreateWithoutTranscriptGradeInput, SectionRegistrationUncheckedCreateWithoutTranscriptGradeInput>
    where?: SectionRegistrationWhereInput
  }

  export type SectionRegistrationUpdateToOneWithWhereWithoutTranscriptGradeInput = {
    where?: SectionRegistrationWhereInput
    data: XOR<SectionRegistrationUpdateWithoutTranscriptGradeInput, SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput>
  }

  export type SectionRegistrationUpdateWithoutTranscriptGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutTranscriptGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpsertWithoutTranscriptGradesInput = {
    update: XOR<SectionUpdateWithoutTranscriptGradesInput, SectionUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<SectionCreateWithoutTranscriptGradesInput, SectionUncheckedCreateWithoutTranscriptGradesInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTranscriptGradesInput, SectionUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type SectionUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type AcademicPeriodUpsertWithoutTranscriptGradesInput = {
    update: XOR<AcademicPeriodUpdateWithoutTranscriptGradesInput, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<AcademicPeriodCreateWithoutTranscriptGradesInput, AcademicPeriodUncheckedCreateWithoutTranscriptGradesInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutTranscriptGradesInput, AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type AcademicPeriodUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type CourseUpsertWithoutTranscriptGradesInput = {
    update: XOR<CourseUpdateWithoutTranscriptGradesInput, CourseUncheckedUpdateWithoutTranscriptGradesInput>
    create: XOR<CourseCreateWithoutTranscriptGradesInput, CourseUncheckedCreateWithoutTranscriptGradesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTranscriptGradesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTranscriptGradesInput, CourseUncheckedUpdateWithoutTranscriptGradesInput>
  }

  export type CourseUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTranscriptGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectCode?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsIncrement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    courseLevel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentAcademicProgramCreateWithoutAcademicProgramInput = {
    id?: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentAcademicProgramsInput
  }

  export type StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput = {
    id?: string
    studentId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateOrConnectWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    create: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramCreateManyAcademicProgramInputEnvelope = {
    data: StudentAcademicProgramCreateManyAcademicProgramInput | StudentAcademicProgramCreateManyAcademicProgramInput[]
    skipDuplicates?: boolean
  }

  export type AcademicCredentialCreateWithoutAcademicProgramInput = {
    id?: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAcademicCredentialsInput
    academicPeriod?: AcademicPeriodCreateNestedOneWithoutCredentialPeriodsInput
  }

  export type AcademicCredentialUncheckedCreateWithoutAcademicProgramInput = {
    id?: string
    studentId: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateOrConnectWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    create: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialCreateManyAcademicProgramInputEnvelope = {
    data: AcademicCredentialCreateManyAcademicProgramInput | AcademicCredentialCreateManyAcademicProgramInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicProgramUpsertWithWhereUniqueWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    update: XOR<StudentAcademicProgramUpdateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput>
    create: XOR<StudentAcademicProgramCreateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedCreateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramUpdateWithWhereUniqueWithoutAcademicProgramInput = {
    where: StudentAcademicProgramWhereUniqueInput
    data: XOR<StudentAcademicProgramUpdateWithoutAcademicProgramInput, StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput>
  }

  export type StudentAcademicProgramUpdateManyWithWhereWithoutAcademicProgramInput = {
    where: StudentAcademicProgramScalarWhereInput
    data: XOR<StudentAcademicProgramUpdateManyMutationInput, StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpsertWithWhereUniqueWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    update: XOR<AcademicCredentialUpdateWithoutAcademicProgramInput, AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput>
    create: XOR<AcademicCredentialCreateWithoutAcademicProgramInput, AcademicCredentialUncheckedCreateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpdateWithWhereUniqueWithoutAcademicProgramInput = {
    where: AcademicCredentialWhereUniqueInput
    data: XOR<AcademicCredentialUpdateWithoutAcademicProgramInput, AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput>
  }

  export type AcademicCredentialUpdateManyWithWhereWithoutAcademicProgramInput = {
    where: AcademicCredentialScalarWhereInput
    data: XOR<AcademicCredentialUpdateManyMutationInput, AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramInput>
  }

  export type StudentCreateWithoutStudentAcademicProgramsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAcademicProgramsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAcademicProgramsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
  }

  export type AcademicProgramCreateWithoutStudentProgramsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credentials?: AcademicCredentialCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateWithoutStudentProgramsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credentials?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramCreateOrConnectWithoutStudentProgramsInput = {
    where: AcademicProgramWhereUniqueInput
    create: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
  }

  export type StudentUpsertWithoutStudentAcademicProgramsInput = {
    update: XOR<StudentUpdateWithoutStudentAcademicProgramsInput, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
    create: XOR<StudentCreateWithoutStudentAcademicProgramsInput, StudentUncheckedCreateWithoutStudentAcademicProgramsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAcademicProgramsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAcademicProgramsInput, StudentUncheckedUpdateWithoutStudentAcademicProgramsInput>
  }

  export type StudentUpdateWithoutStudentAcademicProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAcademicProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicProgramUpsertWithoutStudentProgramsInput = {
    update: XOR<AcademicProgramUpdateWithoutStudentProgramsInput, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
    create: XOR<AcademicProgramCreateWithoutStudentProgramsInput, AcademicProgramUncheckedCreateWithoutStudentProgramsInput>
    where?: AcademicProgramWhereInput
  }

  export type AcademicProgramUpdateToOneWithWhereWithoutStudentProgramsInput = {
    where?: AcademicProgramWhereInput
    data: XOR<AcademicProgramUpdateWithoutStudentProgramsInput, AcademicProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type AcademicProgramUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentials?: AcademicCredentialUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credentials?: AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type StudentCreateWithoutAcademicCredentialsInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicCredentialsInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicCredentialsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
  }

  export type AcademicProgramCreateWithoutCredentialsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramUncheckedCreateWithoutCredentialsInput = {
    id?: string
    code: string
    title: string
    type: string
    level: string
    degreeCode?: string | null
    status: string
    startOn?: Date | string | null
    endOn?: Date | string | null
    accreditationCode?: string | null
    creditsRequired: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutAcademicProgramInput
  }

  export type AcademicProgramCreateOrConnectWithoutCredentialsInput = {
    where: AcademicProgramWhereUniqueInput
    create: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
  }

  export type AcademicPeriodCreateWithoutCredentialPeriodsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    studentRisks?: StudentRiskCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    studentRisks?: StudentRiskUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutCredentialPeriodsInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
  }

  export type StudentUpsertWithoutAcademicCredentialsInput = {
    update: XOR<StudentUpdateWithoutAcademicCredentialsInput, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
    create: XOR<StudentCreateWithoutAcademicCredentialsInput, StudentUncheckedCreateWithoutAcademicCredentialsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicCredentialsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicCredentialsInput, StudentUncheckedUpdateWithoutAcademicCredentialsInput>
  }

  export type StudentUpdateWithoutAcademicCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicProgramUpsertWithoutCredentialsInput = {
    update: XOR<AcademicProgramUpdateWithoutCredentialsInput, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
    create: XOR<AcademicProgramCreateWithoutCredentialsInput, AcademicProgramUncheckedCreateWithoutCredentialsInput>
    where?: AcademicProgramWhereInput
  }

  export type AcademicProgramUpdateToOneWithWhereWithoutCredentialsInput = {
    where?: AcademicProgramWhereInput
    data: XOR<AcademicProgramUpdateWithoutCredentialsInput, AcademicProgramUncheckedUpdateWithoutCredentialsInput>
  }

  export type AcademicProgramUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicProgramUncheckedUpdateWithoutCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    degreeCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accreditationCode?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRequired?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramNestedInput
  }

  export type AcademicPeriodUpsertWithoutCredentialPeriodsInput = {
    update: XOR<AcademicPeriodUpdateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
    create: XOR<AcademicPeriodCreateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedCreateWithoutCredentialPeriodsInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutCredentialPeriodsInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutCredentialPeriodsInput, AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput>
  }

  export type AcademicPeriodUpdateWithoutCredentialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutCredentialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type StudentCreateWithoutStudentRisksInput = {
    id?: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    person: PersonCreateNestedOneWithoutStudentInput
    entryAcademicPeriod?: AcademicPeriodCreateNestedOneWithoutEntryStudentsInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentRisksInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    entryAcademicPeriodId?: string | null
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedCreateNestedManyWithoutStudentInput
    academicCredentials?: AcademicCredentialUncheckedCreateNestedManyWithoutStudentInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentRisksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
  }

  export type AcademicPeriodCreateWithoutStudentRisksInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodUncheckedCreateWithoutStudentRisksInput = {
    id?: string
    code: string
    title: string
    type: string
    startOn: Date | string
    endOn: Date | string
    censusOn?: Date | string | null
    registrationStartOn?: Date | string | null
    registrationEndOn?: Date | string | null
    academicYear: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutAcademicPeriodInput
    sectionRegistrations?: SectionRegistrationUncheckedCreateNestedManyWithoutAcademicPeriodInput
    transcriptGrades?: StudentTranscriptGradeUncheckedCreateNestedManyWithoutAcademicPeriodInput
    entryStudents?: StudentUncheckedCreateNestedManyWithoutEntryAcademicPeriodInput
    credentialPeriods?: AcademicCredentialUncheckedCreateNestedManyWithoutAcademicPeriodInput
  }

  export type AcademicPeriodCreateOrConnectWithoutStudentRisksInput = {
    where: AcademicPeriodWhereUniqueInput
    create: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
  }

  export type StudentUpsertWithoutStudentRisksInput = {
    update: XOR<StudentUpdateWithoutStudentRisksInput, StudentUncheckedUpdateWithoutStudentRisksInput>
    create: XOR<StudentCreateWithoutStudentRisksInput, StudentUncheckedCreateWithoutStudentRisksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentRisksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentRisksInput, StudentUncheckedUpdateWithoutStudentRisksInput>
  }

  export type StudentUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    entryAcademicPeriod?: AcademicPeriodUpdateOneWithoutEntryStudentsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    entryAcademicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicPeriodUpsertWithoutStudentRisksInput = {
    update: XOR<AcademicPeriodUpdateWithoutStudentRisksInput, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
    create: XOR<AcademicPeriodCreateWithoutStudentRisksInput, AcademicPeriodUncheckedCreateWithoutStudentRisksInput>
    where?: AcademicPeriodWhereInput
  }

  export type AcademicPeriodUpdateToOneWithWhereWithoutStudentRisksInput = {
    where?: AcademicPeriodWhereInput
    data: XOR<AcademicPeriodUpdateWithoutStudentRisksInput, AcademicPeriodUncheckedUpdateWithoutStudentRisksInput>
  }

  export type AcademicPeriodUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type AcademicPeriodUncheckedUpdateWithoutStudentRisksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    censusOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodNestedInput
    entryStudents?: StudentUncheckedUpdateManyWithoutEntryAcademicPeriodNestedInput
    credentialPeriods?: AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodNestedInput
  }

  export type CrmOpportunityCreateWithoutContactInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: CrmAccountCreateNestedOneWithoutOpportunitiesInput
    activities?: CrmActivityCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityUncheckedCreateWithoutContactInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    accountId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityCreateOrConnectWithoutContactInput = {
    where: CrmOpportunityWhereUniqueInput
    create: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput>
  }

  export type CrmOpportunityCreateManyContactInputEnvelope = {
    data: CrmOpportunityCreateManyContactInput | CrmOpportunityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CrmActivityCreateWithoutContactInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    createdAt?: Date | string
    account?: CrmAccountCreateNestedOneWithoutActivitiesInput
    opportunity?: CrmOpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type CrmActivityUncheckedCreateWithoutContactInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    accountId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityCreateOrConnectWithoutContactInput = {
    where: CrmActivityWhereUniqueInput
    create: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput>
  }

  export type CrmActivityCreateManyContactInputEnvelope = {
    data: CrmActivityCreateManyContactInput | CrmActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CrmOpportunityUpsertWithWhereUniqueWithoutContactInput = {
    where: CrmOpportunityWhereUniqueInput
    update: XOR<CrmOpportunityUpdateWithoutContactInput, CrmOpportunityUncheckedUpdateWithoutContactInput>
    create: XOR<CrmOpportunityCreateWithoutContactInput, CrmOpportunityUncheckedCreateWithoutContactInput>
  }

  export type CrmOpportunityUpdateWithWhereUniqueWithoutContactInput = {
    where: CrmOpportunityWhereUniqueInput
    data: XOR<CrmOpportunityUpdateWithoutContactInput, CrmOpportunityUncheckedUpdateWithoutContactInput>
  }

  export type CrmOpportunityUpdateManyWithWhereWithoutContactInput = {
    where: CrmOpportunityScalarWhereInput
    data: XOR<CrmOpportunityUpdateManyMutationInput, CrmOpportunityUncheckedUpdateManyWithoutContactInput>
  }

  export type CrmOpportunityScalarWhereInput = {
    AND?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
    OR?: CrmOpportunityScalarWhereInput[]
    NOT?: CrmOpportunityScalarWhereInput | CrmOpportunityScalarWhereInput[]
    id?: StringFilter<"CrmOpportunity"> | string
    workspace?: StringFilter<"CrmOpportunity"> | string
    app?: StringFilter<"CrmOpportunity"> | string
    name?: StringFilter<"CrmOpportunity"> | string
    stage?: StringFilter<"CrmOpportunity"> | string
    status?: StringFilter<"CrmOpportunity"> | string
    contactId?: StringNullableFilter<"CrmOpportunity"> | string | null
    accountId?: StringNullableFilter<"CrmOpportunity"> | string | null
    amount?: DecimalNullableFilter<"CrmOpportunity"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"CrmOpportunity"> | Date | string
  }

  export type CrmActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: CrmActivityWhereUniqueInput
    update: XOR<CrmActivityUpdateWithoutContactInput, CrmActivityUncheckedUpdateWithoutContactInput>
    create: XOR<CrmActivityCreateWithoutContactInput, CrmActivityUncheckedCreateWithoutContactInput>
  }

  export type CrmActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: CrmActivityWhereUniqueInput
    data: XOR<CrmActivityUpdateWithoutContactInput, CrmActivityUncheckedUpdateWithoutContactInput>
  }

  export type CrmActivityUpdateManyWithWhereWithoutContactInput = {
    where: CrmActivityScalarWhereInput
    data: XOR<CrmActivityUpdateManyMutationInput, CrmActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type CrmActivityScalarWhereInput = {
    AND?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
    OR?: CrmActivityScalarWhereInput[]
    NOT?: CrmActivityScalarWhereInput | CrmActivityScalarWhereInput[]
    id?: StringFilter<"CrmActivity"> | string
    workspace?: StringFilter<"CrmActivity"> | string
    app?: StringFilter<"CrmActivity"> | string
    type?: StringFilter<"CrmActivity"> | string
    subject?: StringFilter<"CrmActivity"> | string
    contactId?: StringNullableFilter<"CrmActivity"> | string | null
    accountId?: StringNullableFilter<"CrmActivity"> | string | null
    opportunityId?: StringNullableFilter<"CrmActivity"> | string | null
    createdAt?: DateTimeFilter<"CrmActivity"> | Date | string
  }

  export type CrmOpportunityCreateWithoutAccountInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutOpportunitiesInput
    activities?: CrmActivityCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityUncheckedCreateWithoutAccountInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type CrmOpportunityCreateOrConnectWithoutAccountInput = {
    where: CrmOpportunityWhereUniqueInput
    create: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput>
  }

  export type CrmOpportunityCreateManyAccountInputEnvelope = {
    data: CrmOpportunityCreateManyAccountInput | CrmOpportunityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CrmActivityCreateWithoutAccountInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    createdAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutActivitiesInput
    opportunity?: CrmOpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type CrmActivityUncheckedCreateWithoutAccountInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityCreateOrConnectWithoutAccountInput = {
    where: CrmActivityWhereUniqueInput
    create: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput>
  }

  export type CrmActivityCreateManyAccountInputEnvelope = {
    data: CrmActivityCreateManyAccountInput | CrmActivityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CrmOpportunityUpsertWithWhereUniqueWithoutAccountInput = {
    where: CrmOpportunityWhereUniqueInput
    update: XOR<CrmOpportunityUpdateWithoutAccountInput, CrmOpportunityUncheckedUpdateWithoutAccountInput>
    create: XOR<CrmOpportunityCreateWithoutAccountInput, CrmOpportunityUncheckedCreateWithoutAccountInput>
  }

  export type CrmOpportunityUpdateWithWhereUniqueWithoutAccountInput = {
    where: CrmOpportunityWhereUniqueInput
    data: XOR<CrmOpportunityUpdateWithoutAccountInput, CrmOpportunityUncheckedUpdateWithoutAccountInput>
  }

  export type CrmOpportunityUpdateManyWithWhereWithoutAccountInput = {
    where: CrmOpportunityScalarWhereInput
    data: XOR<CrmOpportunityUpdateManyMutationInput, CrmOpportunityUncheckedUpdateManyWithoutAccountInput>
  }

  export type CrmActivityUpsertWithWhereUniqueWithoutAccountInput = {
    where: CrmActivityWhereUniqueInput
    update: XOR<CrmActivityUpdateWithoutAccountInput, CrmActivityUncheckedUpdateWithoutAccountInput>
    create: XOR<CrmActivityCreateWithoutAccountInput, CrmActivityUncheckedCreateWithoutAccountInput>
  }

  export type CrmActivityUpdateWithWhereUniqueWithoutAccountInput = {
    where: CrmActivityWhereUniqueInput
    data: XOR<CrmActivityUpdateWithoutAccountInput, CrmActivityUncheckedUpdateWithoutAccountInput>
  }

  export type CrmActivityUpdateManyWithWhereWithoutAccountInput = {
    where: CrmActivityScalarWhereInput
    data: XOR<CrmActivityUpdateManyMutationInput, CrmActivityUncheckedUpdateManyWithoutAccountInput>
  }

  export type CrmContactCreateWithoutOpportunitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityCreateNestedManyWithoutContactInput
  }

  export type CrmContactUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type CrmContactCreateOrConnectWithoutOpportunitiesInput = {
    where: CrmContactWhereUniqueInput
    create: XOR<CrmContactCreateWithoutOpportunitiesInput, CrmContactUncheckedCreateWithoutOpportunitiesInput>
  }

  export type CrmAccountCreateWithoutOpportunitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: CrmActivityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountCreateOrConnectWithoutOpportunitiesInput = {
    where: CrmAccountWhereUniqueInput
    create: XOR<CrmAccountCreateWithoutOpportunitiesInput, CrmAccountUncheckedCreateWithoutOpportunitiesInput>
  }

  export type CrmActivityCreateWithoutOpportunityInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    createdAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutActivitiesInput
    account?: CrmAccountCreateNestedOneWithoutActivitiesInput
  }

  export type CrmActivityUncheckedCreateWithoutOpportunityInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    accountId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityCreateOrConnectWithoutOpportunityInput = {
    where: CrmActivityWhereUniqueInput
    create: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type CrmActivityCreateManyOpportunityInputEnvelope = {
    data: CrmActivityCreateManyOpportunityInput | CrmActivityCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type CrmContactUpsertWithoutOpportunitiesInput = {
    update: XOR<CrmContactUpdateWithoutOpportunitiesInput, CrmContactUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<CrmContactCreateWithoutOpportunitiesInput, CrmContactUncheckedCreateWithoutOpportunitiesInput>
    where?: CrmContactWhereInput
  }

  export type CrmContactUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: CrmContactWhereInput
    data: XOR<CrmContactUpdateWithoutOpportunitiesInput, CrmContactUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CrmContactUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUpdateManyWithoutContactNestedInput
  }

  export type CrmContactUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CrmAccountUpsertWithoutOpportunitiesInput = {
    update: XOR<CrmAccountUpdateWithoutOpportunitiesInput, CrmAccountUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<CrmAccountCreateWithoutOpportunitiesInput, CrmAccountUncheckedCreateWithoutOpportunitiesInput>
    where?: CrmAccountWhereInput
  }

  export type CrmAccountUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: CrmAccountWhereInput
    data: XOR<CrmAccountUpdateWithoutOpportunitiesInput, CrmAccountUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CrmAccountUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUpdateManyWithoutAccountNestedInput
  }

  export type CrmAccountUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CrmActivityUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: CrmActivityWhereUniqueInput
    update: XOR<CrmActivityUpdateWithoutOpportunityInput, CrmActivityUncheckedUpdateWithoutOpportunityInput>
    create: XOR<CrmActivityCreateWithoutOpportunityInput, CrmActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type CrmActivityUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: CrmActivityWhereUniqueInput
    data: XOR<CrmActivityUpdateWithoutOpportunityInput, CrmActivityUncheckedUpdateWithoutOpportunityInput>
  }

  export type CrmActivityUpdateManyWithWhereWithoutOpportunityInput = {
    where: CrmActivityScalarWhereInput
    data: XOR<CrmActivityUpdateManyMutationInput, CrmActivityUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type CrmContactCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityCreateNestedManyWithoutContactInput
  }

  export type CrmContactUncheckedCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityUncheckedCreateNestedManyWithoutContactInput
  }

  export type CrmContactCreateOrConnectWithoutActivitiesInput = {
    where: CrmContactWhereUniqueInput
    create: XOR<CrmContactCreateWithoutActivitiesInput, CrmContactUncheckedCreateWithoutActivitiesInput>
  }

  export type CrmAccountCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountUncheckedCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: CrmOpportunityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type CrmAccountCreateOrConnectWithoutActivitiesInput = {
    where: CrmAccountWhereUniqueInput
    create: XOR<CrmAccountCreateWithoutActivitiesInput, CrmAccountUncheckedCreateWithoutActivitiesInput>
  }

  export type CrmOpportunityCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: CrmContactCreateNestedOneWithoutOpportunitiesInput
    account?: CrmAccountCreateNestedOneWithoutOpportunitiesInput
  }

  export type CrmOpportunityUncheckedCreateWithoutActivitiesInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId?: string | null
    accountId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmOpportunityCreateOrConnectWithoutActivitiesInput = {
    where: CrmOpportunityWhereUniqueInput
    create: XOR<CrmOpportunityCreateWithoutActivitiesInput, CrmOpportunityUncheckedCreateWithoutActivitiesInput>
  }

  export type CrmContactUpsertWithoutActivitiesInput = {
    update: XOR<CrmContactUpdateWithoutActivitiesInput, CrmContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CrmContactCreateWithoutActivitiesInput, CrmContactUncheckedCreateWithoutActivitiesInput>
    where?: CrmContactWhereInput
  }

  export type CrmContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: CrmContactWhereInput
    data: XOR<CrmContactUpdateWithoutActivitiesInput, CrmContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type CrmContactUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUpdateManyWithoutContactNestedInput
  }

  export type CrmContactUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CrmAccountUpsertWithoutActivitiesInput = {
    update: XOR<CrmAccountUpdateWithoutActivitiesInput, CrmAccountUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CrmAccountCreateWithoutActivitiesInput, CrmAccountUncheckedCreateWithoutActivitiesInput>
    where?: CrmAccountWhereInput
  }

  export type CrmAccountUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: CrmAccountWhereInput
    data: XOR<CrmAccountUpdateWithoutActivitiesInput, CrmAccountUncheckedUpdateWithoutActivitiesInput>
  }

  export type CrmAccountUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUpdateManyWithoutAccountNestedInput
  }

  export type CrmAccountUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: CrmOpportunityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CrmOpportunityUpsertWithoutActivitiesInput = {
    update: XOR<CrmOpportunityUpdateWithoutActivitiesInput, CrmOpportunityUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CrmOpportunityCreateWithoutActivitiesInput, CrmOpportunityUncheckedCreateWithoutActivitiesInput>
    where?: CrmOpportunityWhereInput
  }

  export type CrmOpportunityUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: CrmOpportunityWhereInput
    data: XOR<CrmOpportunityUpdateWithoutActivitiesInput, CrmOpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type CrmOpportunityUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutOpportunitiesNestedInput
    account?: CrmAccountUpdateOneWithoutOpportunitiesNestedInput
  }

  export type CrmOpportunityUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameCreateManyPersonInput = {
    id?: string
    given: string
    middle?: string | null
    family: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAddressCreateManyPersonInput = {
    id?: string
    address: string
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneCreateManyPersonInput = {
    id?: string
    number: string
    extension?: string | null
    type: string
    preferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyPersonInput = {
    id?: string
    type: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionCreateManyInstructorInput = {
    id?: string
    courseId: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoNotEngageAgentCreateManyPersonInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    createdById?: string | null
  }

  export type PersonNameUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonNameUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    given?: StringFieldUpdateOperationsInput | string
    middle?: NullableStringFieldUpdateOperationsInput | string | null
    family?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAddressUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    preferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoNotEngageAgentUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoNotEngageAgentUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionRegistrationCreateManyStudentInput = {
    id?: string
    sectionId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramCreateManyStudentInput = {
    id?: string
    academicProgramId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyStudentInput = {
    id?: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyStudentInput = {
    id?: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentRiskCreateManyStudentInput = {
    id?: string
    academicPeriodId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicProgram?: AcademicProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicProgramId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyAcademicPeriodInput = {
    id?: string
    courseId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyEntryAcademicPeriodInput = {
    id?: string
    personId: string
    type: string
    status: string
    startOn: Date | string
    academicLevel?: string | null
    residency?: string | null
    studentClassification?: string | null
    studentLoad?: string | null
    academicStandingCode?: string | null
    studentNumber: string
    isFirstGen?: boolean
    isPellEligible?: boolean
    isInState?: boolean
    workHoursPerWeek?: number
    commuteMinutes?: number
    hasHousingInstability?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    credentialCode: string
    academicProgramId?: string | null
    awardedOn: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentRiskCreateManyAcademicPeriodInput = {
    id?: string
    studentId: string
    attendanceRiskScore: number
    academicSupportRiskScore: number
    overallRiskBucket: $Enums.RiskBucket
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    section?: SectionUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutStudentNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicPrograms?: StudentAcademicProgramUncheckedUpdateManyWithoutStudentNestedInput
    academicCredentials?: AcademicCredentialUncheckedUpdateManyWithoutStudentNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutStudentNestedInput
    studentRisks?: StudentRiskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutEntryAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    academicLevel?: NullableStringFieldUpdateOperationsInput | string | null
    residency?: NullableStringFieldUpdateOperationsInput | string | null
    studentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    studentLoad?: NullableStringFieldUpdateOperationsInput | string | null
    academicStandingCode?: NullableStringFieldUpdateOperationsInput | string | null
    studentNumber?: StringFieldUpdateOperationsInput | string
    isFirstGen?: BoolFieldUpdateOperationsInput | boolean
    isPellEligible?: BoolFieldUpdateOperationsInput | boolean
    isInState?: BoolFieldUpdateOperationsInput | boolean
    workHoursPerWeek?: IntFieldUpdateOperationsInput | number
    commuteMinutes?: IntFieldUpdateOperationsInput | number
    hasHousingInstability?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicProgram?: AcademicProgramUpdateOneWithoutCredentialsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    academicProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentRisksNestedInput
  }

  export type StudentRiskUncheckedUpdateWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRiskUncheckedUpdateManyWithoutAcademicPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    attendanceRiskScore?: FloatFieldUpdateOperationsInput | number
    academicSupportRiskScore?: FloatFieldUpdateOperationsInput | number
    overallRiskBucket?: EnumRiskBucketFieldUpdateOperationsInput | $Enums.RiskBucket
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyCourseInput = {
    id?: string
    academicPeriodId: string
    number: string
    title?: string | null
    crn: string
    startOn: Date | string
    endOn: Date | string
    status: string
    capacity: number
    enrolled?: number
    available?: number
    waitlistCapacity?: number | null
    waitlistEnrolled?: number | null
    instructionalMethodCode?: string | null
    daysOfWeek?: SectionCreatedaysOfWeekInput | string[]
    startTime?: string | null
    endTime?: string | null
    building?: string | null
    roomNumber?: string | null
    creditType: string
    creditsMinimum: Decimal | DecimalJsLike | number | string
    creditsMaximum: Decimal | DecimalJsLike | number | string
    instructorPersonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManyCourseInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    sectionId: string
    academicPeriodId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionsNestedInput
    instructor?: PersonUpdateOneWithoutSectionsNestedInput
    sectionRegistrations?: SectionRegistrationUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sectionRegistrations?: SectionRegistrationUncheckedUpdateManyWithoutSectionNestedInput
    transcriptGrades?: StudentTranscriptGradeUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    enrolled?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    waitlistCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    waitlistEnrolled?: NullableIntFieldUpdateOperationsInput | number | null
    instructionalMethodCode?: NullableStringFieldUpdateOperationsInput | string | null
    daysOfWeek?: SectionUpdatedaysOfWeekInput | string[]
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    creditType?: StringFieldUpdateOperationsInput | string
    creditsMinimum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsMaximum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    instructorPersonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    section?: SectionUpdateOneRequiredWithoutTranscriptGradesNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionRegistrationCreateManySectionInput = {
    id?: string
    studentId: string
    academicPeriodId: string
    statusCode: string
    registrationDate: Date | string
    registeredOn: Date | string
    creditType: string
    credits: Decimal | DecimalJsLike | number | string
    gradingOptionCode?: string | null
    academicLoad?: string | null
    residencyStatus?: string | null
    attendanceRate?: number | null
    midtermGrade?: string | null
    finalGrade?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTranscriptGradeCreateManySectionInput = {
    id?: string
    studentId: string
    sectionRegistrationId: string
    academicPeriodId: string
    courseId: string
    gradeSchemeCode?: string | null
    gradeValue?: string | null
    gradePoints?: Decimal | DecimalJsLike | number | string | null
    qualityPoints?: Decimal | DecimalJsLike | number | string | null
    creditsAttempted: Decimal | DecimalJsLike | number | string
    creditsEarned: Decimal | DecimalJsLike | number | string
    finalGradeDate?: Date | string | null
    status: string
    incomplete?: boolean
    repeat?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionRegistrationUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutSectionRegistrationsNestedInput
    transcriptGrade?: StudentTranscriptGradeUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptGrade?: StudentTranscriptGradeUncheckedUpdateOneWithoutSectionRegistrationNestedInput
  }

  export type SectionRegistrationUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    statusCode?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredOn?: DateTimeFieldUpdateOperationsInput | Date | string
    creditType?: StringFieldUpdateOperationsInput | string
    credits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gradingOptionCode?: NullableStringFieldUpdateOperationsInput | string | null
    academicLoad?: NullableStringFieldUpdateOperationsInput | string | null
    residencyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    midtermGrade?: NullableStringFieldUpdateOperationsInput | string | null
    finalGrade?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutTranscriptGradesNestedInput
    sectionRegistration?: SectionRegistrationUpdateOneRequiredWithoutTranscriptGradeNestedInput
    academicPeriod?: AcademicPeriodUpdateOneRequiredWithoutTranscriptGradesNestedInput
    course?: CourseUpdateOneRequiredWithoutTranscriptGradesNestedInput
  }

  export type StudentTranscriptGradeUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTranscriptGradeUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sectionRegistrationId?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    gradeSchemeCode?: NullableStringFieldUpdateOperationsInput | string | null
    gradeValue?: NullableStringFieldUpdateOperationsInput | string | null
    gradePoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    creditsAttempted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsEarned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalGradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    incomplete?: BoolFieldUpdateOperationsInput | boolean
    repeat?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramCreateManyAcademicProgramInput = {
    id?: string
    studentId: string
    startOn: Date | string
    endOn?: Date | string | null
    status: string
    catalogYear?: string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicCredentialCreateManyAcademicProgramInput = {
    id?: string
    studentId: string
    credentialCode: string
    awardedOn: Date | string
    status: string
    academicPeriodId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAcademicProgramUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentAcademicProgramsNestedInput
  }

  export type StudentAcademicProgramUncheckedUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAcademicProgramUncheckedUpdateManyWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startOn?: DateTimeFieldUpdateOperationsInput | Date | string
    endOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    catalogYear?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAcademicCredentialsNestedInput
    academicPeriod?: AcademicPeriodUpdateOneWithoutCredentialPeriodsNestedInput
  }

  export type AcademicCredentialUncheckedUpdateWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicCredentialUncheckedUpdateManyWithoutAcademicProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    credentialCode?: StringFieldUpdateOperationsInput | string
    awardedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    academicPeriodId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmOpportunityCreateManyContactInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    accountId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmActivityCreateManyContactInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    accountId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmOpportunityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: CrmAccountUpdateOneWithoutOpportunitiesNestedInput
    activities?: CrmActivityUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: CrmAccountUpdateOneWithoutActivitiesNestedInput
    opportunity?: CrmOpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type CrmActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmOpportunityCreateManyAccountInput = {
    id?: string
    workspace: string
    app: string
    name: string
    stage: string
    status: string
    contactId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrmActivityCreateManyAccountInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    opportunityId?: string | null
    createdAt?: Date | string
  }

  export type CrmOpportunityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutOpportunitiesNestedInput
    activities?: CrmActivityUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: CrmActivityUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type CrmOpportunityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutActivitiesNestedInput
    opportunity?: CrmOpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type CrmActivityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityCreateManyOpportunityInput = {
    id?: string
    workspace: string
    app: string
    type: string
    subject: string
    contactId?: string | null
    accountId?: string | null
    createdAt?: Date | string
  }

  export type CrmActivityUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: CrmContactUpdateOneWithoutActivitiesNestedInput
    account?: CrmAccountUpdateOneWithoutActivitiesNestedInput
  }

  export type CrmActivityUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrmActivityUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: StringFieldUpdateOperationsInput | string
    app?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PersonCountOutputTypeDefaultArgs instead
     */
    export type PersonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicPeriodCountOutputTypeDefaultArgs instead
     */
    export type AcademicPeriodCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicPeriodCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionCountOutputTypeDefaultArgs instead
     */
    export type SectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicProgramCountOutputTypeDefaultArgs instead
     */
    export type AcademicProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmContactCountOutputTypeDefaultArgs instead
     */
    export type CrmContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmAccountCountOutputTypeDefaultArgs instead
     */
    export type CrmAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmOpportunityCountOutputTypeDefaultArgs instead
     */
    export type CrmOpportunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmOpportunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonDefaultArgs instead
     */
    export type PersonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonNameDefaultArgs instead
     */
    export type PersonNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonNameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAddressDefaultArgs instead
     */
    export type EmailAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhoneDefaultArgs instead
     */
    export type PhoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoNotEngageGlobalDefaultArgs instead
     */
    export type DoNotEngageGlobalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoNotEngageGlobalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoNotEngageAgentDefaultArgs instead
     */
    export type DoNotEngageAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoNotEngageAgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicPeriodDefaultArgs instead
     */
    export type AcademicPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionDefaultArgs instead
     */
    export type SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionRegistrationDefaultArgs instead
     */
    export type SectionRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTranscriptGradeDefaultArgs instead
     */
    export type StudentTranscriptGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTranscriptGradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicProgramDefaultArgs instead
     */
    export type AcademicProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentAcademicProgramDefaultArgs instead
     */
    export type StudentAcademicProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentAcademicProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicCredentialDefaultArgs instead
     */
    export type AcademicCredentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicCredentialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentRiskDefaultArgs instead
     */
    export type StudentRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentRiskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimulationStateDefaultArgs instead
     */
    export type SimulationStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimulationStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmContactDefaultArgs instead
     */
    export type CrmContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmAccountDefaultArgs instead
     */
    export type CrmAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmOpportunityDefaultArgs instead
     */
    export type CrmOpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmOpportunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrmActivityDefaultArgs instead
     */
    export type CrmActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrmActivityDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}